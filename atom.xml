<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ji的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2026-02-22T04:46:06.269Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>liangji</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stm32-esp32s3-imx 存储架构讨论</title>
    <link href="http://example.com/2026/02/21/stm32-esp32s3-imx-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E8%AE%A8%E8%AE%BA/"/>
    <id>http://example.com/2026/02/21/stm32-esp32s3-imx-%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E8%AE%A8%E8%AE%BA/</id>
    <published>2026-02-21T06:11:06.000Z</published>
    <updated>2026-02-22T04:46:06.269Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E4%BB%8B%E7%BB%8D">介绍</a></li><li><a href="#%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94">存储架构对比</a><ul><li><a href="#stm32f103zet6">stm32f103zet6</a></li><li><a href="#esp32s3-n16r8">esp32s3-N16R8</a></li><li><a href="#imx6ull">imx6ull</a></li><li><a href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94">总结对比</a></li></ul></li><li><a href="#cache">cache</a></li><li><a href="#%E6%80%BB%E7%BA%BF%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BA%BF">总线，数据总线，指令总线</a><ul><li><a href="#%E4%B8%A4%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC-vs-%E5%93%88%E4%BD%9B">两种基础架构：冯·诺依曼 vs. 哈佛</a></li><li><a href="#stm32%E7%9A%84%E6%80%BB%E7%BA%BF">stm32的总线</a></li><li><a href="#imx%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BA%BF">imx中的总线</a></li><li><a href="#esp32%E7%9A%84%E6%80%BB%E7%BA%BF">esp32的总线</a></li><li><a href="#%E5%93%88%E4%BD%9B%E6%9E%B6%E6%9E%84%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">哈佛架构的工作模式</a></li><li><a href="#cache-%E7%9A%84%E5%8A%A8%E6%80%81%E6%90%AC%E8%BF%90%E8%BF%87%E7%A8%8B">Cache 的“动态搬运”过程</a></li></ul></li><li><a href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5%E5%92%8C%E5%AD%98%E5%82%A8%E5%99%A8">程序段和存储器</a><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%85%E9%83%A8-rom-%E5%9C%B0%E5%9D%80%E6%98%AF%E5%88%86%E6%88%90%E4%B8%A4%E5%9D%97%E7%9A%84">1. 为什么内部 ROM 地址是分成两块的？</a></li><li><a href="#2-icache-%E5%92%8C-dcache-%E6%98%AF%E4%BB%8E%E5%86%85%E9%83%A8-ram-%E5%88%86%E5%87%BA%E6%9D%A5%E7%9A%84%E5%90%97">2. ICache 和 DCache 是从内部 RAM 分出来的吗？</a></li><li><a href="#%E5%90%8C%E4%B8%80%E5%9D%97%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%97%A2%E8%B5%B0%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BA%BF%E5%8F%88%E8%B5%B0%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF">同一块存储空间，既走指令总线，又走数据总线</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%B0%E5%9D%80%E8%A6%81%E6%98%A0%E5%B0%84%E6%88%90%E4%B8%A4%E4%BB%BD%E6%B6%88%E9%99%A4%E7%AB%9E%E4%BA%89">为什么地址要映射成两份？（消除竞争）</a></li></ul></li><li><a href="#esp32s3%E4%BB%8B%E7%BB%8D">esp32s3介绍</a><ul><li><a href="#%E5%86%85%E5%AD%98%E5%A0%86%E7%9A%84%E7%94%B3%E8%AF%B7">内存，堆的申请</a></li><li><a href="#%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6">访问速度</a></li></ul></li><li><a href="#mmu%E6%80%BB%E7%BA%BF%E7%9F%A9%E9%98%B5">mmu,总线矩阵</a><ul><li><a href="#%E6%80%BB%E7%BA%BF">总线</a><ul><li><a href="#esp32%E7%9A%84%E5%A4%96%E9%83%A8ram-%E5%AF%B9%E6%AF%94-imx%E7%9A%84ddr">esp32的外部RAM 对比 imx的ddr</a></li></ul></li><li><a href="#%E6%98%A0%E5%B0%84%E5%88%B0%E4%B8%80%E5%A5%97%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">映射到一套地址空间</a></li></ul></li><li><a href="#%E5%A4%87%E6%B3%A8">备注</a><ul><li><a href="#1-%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E6%9C%80%E9%A1%B6%E5%B1%82%E7%9A%84%E6%A0%B9">1. 内核架构（最顶层的“根”）</a></li><li><a href="#2-%E5%AD%98%E5%82%A8%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E8%AF%B4%E7%9A%84%E5%AE%8C%E5%85%A8%E5%AF%B9">2. 存储器架构（你说的完全对）</a></li><li><a href="#3-%E6%80%BB%E7%BA%BF%E6%9E%B6%E6%9E%84%E4%BD%A0%E6%8A%93%E4%BD%8F%E5%85%B3%E9%94%AE%E4%BA%86">3. 总线架构（你抓住关键了）</a></li><li><a href="#4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">4. 运行时内存模型（代码内存结构）</a></li><li><a href="#5-cache%E4%BD%A0%E5%86%99%E5%BE%97%E5%BE%88%E6%A0%87%E5%87%86">5. Cache（你写得很标准）</a></li><li><a href="#6-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E4%BD%A0%E8%AF%B4%E7%9A%84-mmu-%E5%B1%9E%E4%BA%8E%E8%BF%99%E9%87%8C">6. 地址空间与地址翻译（你说的 MMU 属于这里）</a></li><li><a href="#7-%E6%97%B6%E9%92%9F%E4%B8%8E%E5%A4%8D%E4%BD%8D%E5%BA%95%E5%B1%82%E6%9C%80%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BF%83%E8%B7%B3">7. 时钟与复位（底层最基础的“心跳”）</a></li><li><a href="#8-%E5%A4%96%E8%AE%BE%E4%B8%8E-io-%E5%AD%90%E7%B3%BB%E7%BB%9F">8. 外设与 IO 子系统</a></li><li><a href="#9-%E5%90%AF%E5%8A%A8%E4%B8%8E-boot-%E6%B5%81%E7%A8%8B%E7%9C%9F%E6%AD%A3%E5%BA%95%E5%B1%82%E5%88%B0%E5%BA%95">9. 启动与 Boot 流程（真正“底层到底”）</a></li></ul></li><li><a href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93%E4%BD%A0%E5%8E%9F%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">一句话总结你原来的问题：</a><ul><li><a href="#1-mmu-%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A1%B5%E8%A1%A8%E5%9C%A8%E5%93%AA%E9%87%8C%E6%8F%90%E4%BE%9B%E7%BB%99%E5%AE%83">1. MMU 是怎么控制的？页表在哪里提供给它？</a></li><li><a href="#2-%E6%88%91%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E6%8C%87%E5%AE%9A%E8%B5%B0%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BA%BF%E8%BF%98%E6%98%AF%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF%E5%90%97">2. 我需要自己指定走指令总线还是数据总线吗？</a></li><li><a href="#3-%E6%88%91%E9%9C%80%E8%A6%81%E7%81%B5%E6%B4%BB%E5%AE%89%E6%8E%92%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%90%97">3. 我需要灵活安排代码运行模式吗？</a></li><li><a href="#4-linux-%E5%86%85%E6%A0%B8%E4%B8%8E-mmu-%E7%9A%84%E7%BB%88%E6%9E%81%E4%BA%A4%E4%BA%92%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8-page-fault">4. Linux 内核与 MMU 的终极交互：缺页异常 (Page Fault)</a></li><li><a href="#%E6%80%BB%E7%BB%93%E4%BD%A0%E7%9A%84%E6%88%90%E9%95%BF%E8%B7%AF%E5%BE%84">总结：你的成长路径</a></li></ul></li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这篇文档，主要记录我在初步认识esp32s3开发板的存储架构的时候，和stm32, imx6ull的存储架构的不同的讨论</p><p>借这个机会，了解启动流程，代码运行，mmu，哈佛架构，数据总线，指令总线，寻址地址，块设备，存储架构,cache这些的了解。</p><h1 id="存储架构对比"><a href="#存储架构对比" class="headerlink" title="存储架构对比"></a>存储架构对比</h1><p>下面先来对比一下，stm32,esp32s3,imx的存储器架构</p><h2 id="stm32f103zet6"><a href="#stm32f103zet6" class="headerlink" title="stm32f103zet6"></a>stm32f103zet6</h2><p>这个的存储器架构，之前就已经分析过了，就是内部ROM，内部RAM。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ ARM Cortex-M3 ]</span><br><span class="line">             |</span><br><span class="line">    +--------+--------+ </span><br><span class="line">    |  System Bus     |</span><br><span class="line">    +---|---------|---+</span><br><span class="line">        |         |</span><br><span class="line">+-------v---+ +---v-------+</span><br><span class="line">| Int. ROM  | | Int. RAM  |</span><br><span class="line">| (<span class="number">512</span> KB)  | | (<span class="number">64</span> KB)   |</span><br><span class="line">| 存放/运行  | | 存放变量  |</span><br><span class="line">| 程序代码   | | 堆栈      |</span><br><span class="line">+-----------+ +-----------+</span><br></pre></td></tr></table></figure><p>stm32的bin用户代码，就烧录在内部ROM里面，上电后，start.S会把.data,.bss拷贝到内部RAM中，这样来运行。</p><blockquote><p>由于都是内部ROM，RAM，所以<strong>无需mmu映射</strong>，单纯靠总线矩阵，就可以实现存储空间到寻址空间的映射</p></blockquote><h2 id="esp32s3-N16R8"><a href="#esp32s3-N16R8" class="headerlink" title="esp32s3-N16R8"></a>esp32s3-N16R8</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            [ Xtensa® Dual-Core LX7 ]</span><br><span class="line">                         |</span><br><span class="line">            +------------v------------+</span><br><span class="line">            | Cache / MMU (地址映射中心) |</span><br><span class="line">            +------------|------------+</span><br><span class="line">                         |</span><br><span class="line">      +------------------+------------------+</span><br><span class="line">      |                  |                  |</span><br><span class="line">+-----v-----+      +-----v-----+      +-----v-----+</span><br><span class="line">| Int. ROM  |      | Int. RAM  |      |  SPI Bus  |</span><br><span class="line">| (<span class="number">384</span> KB)  |      | (<span class="number">512</span> KB)  |      | (外部总线) |</span><br><span class="line">| 固化Boot/ |      | 极速数据  |      +-----|-----+</span><br><span class="line">| 算法库    |      | 关键代码  |            |</span><br><span class="line">+-----------+      +-----------+     /------+------\</span><br><span class="line">                                    |              |</span><br><span class="line">                           +--------v-------+ +----v-----------+</span><br><span class="line">                           | Ext. SPI Flash | | Ext. SPI RAM   |</span><br><span class="line">                           | (N16: <span class="number">16</span> MB)   | | (R8: <span class="number">8</span> MB)     |</span><br><span class="line">                           | 存放固件/文件   | | 存放UI/大数据库 |</span><br><span class="line">                           +----------------+ +----------------+</span><br></pre></td></tr></table></figure><p>esp32和单片机stm32的存储架构有些不同，他和跑linux的系统，有些类似，但是同时具备单片机的轻量和系统a核的那种性能，他同时具备：</p><ul><li>内部ROM（384KB）<ul><li>内部相当于存放bootROM代码</li></ul></li><li>内部RAM<ul><li>内存要求不高时，充当内存ram</li></ul></li><li>外部ROM<ul><li>实际bin文件存储的位置</li></ul></li><li>外部RAM<ul><li>用于扩展内存，比如需要存储很大的图片，原来的512KB肯定不够。</li></ul></li></ul><blockquote><p>esp32s3和imx不同，他的外部存储器（ROM，RAM）都是通过SPI来进行访问的，所以：</p><ul><li>如果<strong>没有启用MMU</strong>，那么外部存储器全部都是普通的块设备。</li><li>如果<strong>开启MMU</strong>，则外部存储器，比如外部ROM，就可以通过MMU来把物理存储空间，映射到寻址空间中</li></ul></blockquote><p><strong>为什么esp32s3不像imx一样，用外部RAM？</strong></p><p><code>ESP32-S3</code> 支持外接<code>高达 1GB</code> 的外部 RAM（通常是 <code>PSRAM</code>，即伪静态随机存储器）。</p><ul><li><p><strong>为什么你在基础教程里没看到</strong>？ 因为内置的 512KB SRAM 对跑一个简单的 Wi-Fi 联网或 LED 闪烁程序已经绰绰有余了。</p></li><li><p><strong>什么时候会用</strong>？ 当你要跑 LVGL 图形界面、摄像头拍照、AI 语音识别或者本地 Web 服务器时，512KB 瞬间就会满，这时候你买的开发板通常会带一个 8MB 或 16MB 的 PSRAM 颗粒。</p></li></ul><hr><p>当你按下复位键，<strong>ESP32-S3 的内存会经历这个过程</strong>：</p><ul><li><p><strong>代码段 (.text)</strong>: 留在外部 Flash 里，通过 ICache 映射到 0x4200_0000。</p></li><li><p><strong>常量 (.rodata)</strong>: 留在外部 Flash 里，通过 DCache 映射到 0x3C00_0000。</p></li><li><p><strong>变量 (.data &#x2F; .bss)</strong>: 必须搬运到 内部 SRAM，地址在 0x3FC8_0000 附近。</p></li><li><p>如果你开启了 <code>PSRAM</code>(<strong>外部RAM</strong>): 那么你可以通过 <code>heap_caps_malloc</code>(<code>MALLOC_CAP_SPIRAM</code>) 在外部 RAM 里开辟巨大的缓冲区。</p></li></ul><h2 id="imx6ull"><a href="#imx6ull" class="headerlink" title="imx6ull"></a>imx6ull</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            [ ARM Cortex-A7 ]</span><br><span class="line">                   |</span><br><span class="line">          +--------v--------+</span><br><span class="line">          |   Bus Matrix    |</span><br><span class="line">          +---|--------|----+</span><br><span class="line">              |        |</span><br><span class="line">      +-------+        +-------+--------------+</span><br><span class="line">      |                        |              |</span><br><span class="line">+-----v-----+            +-----v-----+  +-----v-------+</span><br><span class="line">| Boot ROM  |            | Int. RAM  |  | DDR Control |</span><br><span class="line">| (<span class="number">96</span> KB)   |            | (OCRAM)   |  | (高速控制器) |</span><br><span class="line">| 芯片自检  |            | (<span class="number">128</span> KB)  |  +-----|-------+</span><br><span class="line">| 找启动介质|            | 搬运代码用|        |</span><br><span class="line">+-----------+            +-----------+  +-----v-------+</span><br><span class="line">      |                                 | Ext. DDR3   |</span><br><span class="line">+-----v-------------+                   | (<span class="number">256</span>/<span class="number">512</span> MB)|</span><br><span class="line">| Ext. eMMC / NAND  |                   | 真正的运行区 |</span><br><span class="line">| (几个GB的程序镜像)| ----------------&gt; | (代码+系统)  |</span><br><span class="line">+-------------------+ (由Bootloader搬运) +-------------+</span><br></pre></td></tr></table></figure><p>这个架构就是标准的linux开发板的架构，具体不多说了。</p><blockquote><p>imx的外部存储器和esp32不太一样。</p><ul><li><strong>外部ROM</strong>，imx的是sd卡，emmc这些，因为存储空间非常大，16G，32G，寻址空间没这么多，所以一般不用MMU映射到寻址空间，而是<strong>单纯的用作块设备</strong>。</li><li><strong>外部RAM</strong>，也就是DDR，imx是有<strong>独立的ddr总线</strong>进行连接，所以是可以映射到寻址空间的。</li></ul></blockquote><blockquote><p>注意，这三个都是哈佛架构，也就是CPU有数据总线和指令总线，具体使用在下面讲</p></blockquote><h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">特性,       STM32 (F1系列),     ESP32-S3 (及类似芯片),              i.MX (及其他 MPU)</span><br><span class="line">代码位置,   内部 Flash (片上),      外部 Flash,                     外部 Flash / eMMC</span><br><span class="line">运行内存,   内部 SRAM (小),         内部 SRAM + 外部 PSRAM,         外部 DDR RAM</span><br><span class="line">核心机制,    直接寻址 (简单直接),    XIP (就地执行) + Cache,          Bootloader 搬运到 RAM 运行</span><br><span class="line">角色定位,   纯种单片机,             “缝合怪” (单片机皮，电脑心),        小型电脑处理器</span><br></pre></td></tr></table></figure><p><strong>为什么 ESP32-S3 的过程感觉像 i.MX？</strong></p><p>你感觉像 i.MX 是因为它们都引入了 MMU (内存管理单元) 和 Cache (缓存)。</p><ul><li><p><strong>i.MX 的逻辑</strong>： 外部存储（Flash&#x2F;SD卡）太慢，必须在上电后把整个 Linux 内核和大程序全部搬运到外部 DDR RAM 里跑。</p></li><li><p><strong>ESP32-S3 的逻辑 (XIP)</strong>： 外部 Flash 虽然慢，但我有一个聪明的 Cache。CPU 想读哪段代码，Cache 就去 Flash 搬哪段，映射到虚拟地址空间。</p></li></ul><p>这就是为什么 ESP32 即使不接外部 RAM 也能跑： 它把内部 SRAM 的一部分临时当成了外部 Flash 的“窗口”。</p><hr><p><strong>既然像 i.MX，为什么不默认全用外部 RAM？</strong></p><p>既然可以外接 1GB，为什么不干脆像 i.MX 那样全跑在外部 RAM？主要有三个考量：</p><ul><li><p><strong>功耗控制</strong>： 访问外部总线（SPI&#x2F;QPI）非常耗电。单片机首要任务是低功耗，能用内部 SRAM 解决的就绝不出门。</p></li><li><p><strong>延迟 (Latency)</strong>： 内部 SRAM 是单周期访问（快如闪电）；外部 RAM 即使有 Cache，也存在未命中时的等待时间。</p></li><li><p><strong>引脚资源</strong>： i.MX 为了接 DDR 动辄占用几十个引脚；ESP32-S3 常用 SPI 接口，虽然节省了引脚，但带宽上限封死了。</p></li></ul><h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p>上面，已经整理了stm32,esp32,imx的存储架构的区别。下面来具体讨论，经常看到说，<strong>cache可以加速访问RAM，ROM，为什么</strong>？</p><p><strong>如果最终都要从慢速的外部 ROM 搬东西，那 Cache 凭什么能快？</strong></p><ul><li>Cache 聪明的点在于：它不是“按需取一个”，而是“<strong>顺便带一堆</strong>”<ul><li><p><strong>第一次读取</strong> (<code>Cache Miss</code>): 当 CPU 第一次要读某个地址的代码时，Cache 确实得苦哈哈地去外部 Flash 搬运。这时候 CPU 必须等待（Stall），<code>速度确实慢</code>。</p></li><li><p><strong>空间局部性</strong> (<code>Spatial Locality</code>): 你的代码通常是<code>顺序执行的</code>。当你读地址 0x01 时，Cache 预判你马上要读 0x02, 0x03… 所以它会<strong>一次性从 Flash 搬回一个缓存行 (Cache Line)</strong>，比如 32 字节或 64 字节。</p></li><li><p><strong>时间局部性</strong> (<code>Temporal Locality</code>): 代码里有很多 for 循环或函数调用。一段代码被搬进 Cache 后，循环 1000 次，除了第一次是慢的，剩下的 999 次都是直接从内部 SRAM 读。</p></li></ul></li></ul><hr><p><strong>cache，相当于是内部RAM中，对于外部ROM的一段动态窗口映射</strong></p><p>在 ESP32-S3 中，确实会划出一部分 Internal SRAM（比如 SRAM 0 的一部分）专门给 Cache 使用。但这块 SRAM 并不是死死地对应 Flash 的某一段，而是一个动态池子。</p><ul><li><p><strong>标签 (Tag) 机制</strong>： Cache 内部会维护一张表。它记录了：“我现在这块 SRAM 里存的到底是从 Flash 哪个地址搬过来的东西？”</p></li><li><p><strong>动态替换</strong>： 比如你划了 <code>32KB</code> 的 SRAM 做 <code>Cache</code>。</p><ul><li><p>当你运行程序 A 段时，这 32KB 填满了 A 段的代码。</p></li><li><p>当你突然跳转到程序 B 段（在 Flash 另一个很远的地方），Cache 发现这 32KB 里没有 B，它就会把旧的 A 代码踢出去，从 Flash 搬 B 段进来覆盖掉。</p></li></ul></li></ul><hr><p><strong>ESP32-S3 的特殊性：ICache 与 DCache</strong></p><p>ESP32-S3 把这个“替身”分得更细：</p><ul><li><p><code>ICache (Instruction Cache)</code>: 专门给指令总线用。CPU 读代码去执行时走这里。它只读不写，所以逻辑简单，速度极快。</p></li><li><p><code>DCache (Data Cache)</code>: 专门给数据总线用。如果你在 Flash 里存了一些大的图片、常量表，CPU 读取它们时走这里。</p></li></ul><blockquote><p>注意： 在 ESP32-S3 中，你可以通过配置，决定到底拿多少 SRAM 出来当 Cache。</p></blockquote><ul><li><p>如果你<strong>不设 Cache</strong>，那这部分 SRAM 就能当普通的 RAM 存变量。</p></li><li><p>如果你<strong>设了 Cache</strong>，这部分 SRAM 就不再受你控制，而是受 <code>MMU</code> (内存管理单元) <code>自动管理</code>，专门负责和外部 Flash 对接。</p></li></ul><p>–</p><blockquote><p>以上就是对cache的一些认识，它本质上是一块SRAM区域，只不过这里面不是存储固定的内容，而是对其他存储器空间的一个动态映射。这样一次拷贝，可以把一整个映射区域的内容都拷贝过来，cpu读取内容就是在SRAM的cache中，而不是每次等待长时间来访问外部ROM</p></blockquote><h1 id="总线，数据总线，指令总线"><a href="#总线，数据总线，指令总线" class="headerlink" title="总线，数据总线，指令总线"></a>总线，数据总线，指令总线</h1><p>既然上面提到了总线，我看stm32，imx里面都没有提到数据总线，指令总线，<strong>当时就只是单纯的说cpu取PC指针的指令，执行</strong>。</p><p>事实是：<strong>STM32 和 i.MX 都有指令总线和数据总线</strong>，只是它们的表现形式和重视程度不同</p><h2 id="两种基础架构：冯·诺依曼-vs-哈佛"><a href="#两种基础架构：冯·诺依曼-vs-哈佛" class="headerlink" title="两种基础架构：冯·诺依曼 vs. 哈佛"></a>两种基础架构：冯·诺依曼 vs. 哈佛</h2><ul><li><p><strong>冯·诺依曼架构 (Von Neumann)</strong>: 指令和数据全都挤在一根总线上。就像一条单行道，CPU 要么取指令，要么取数据，不能同时干。</p></li><li><p><strong>哈佛架构 (Harvard)</strong>: 指令和数据有各自独立的总线。就像双向八车道，CPU 可以一边取下一条指令，一边读内存里的变量。</p></li></ul><h2 id="stm32的总线"><a href="#stm32的总线" class="headerlink" title="stm32的总线"></a>stm32的总线</h2><p>在 <code>STM32F103 (Cortex-M3)</code> 中：<br>其实它也是<strong>哈佛架构</strong>。如果你翻开《STM32参考手册》的“存储器架构”一节，你会看到三根总线：</p><ul><li><p><strong>I-Code 总线</strong>： 专门去 Flash 取指令。</p></li><li><p><strong>D-Code 总线</strong>： 专门去 Flash 取常量（Literal data）。</p></li><li><p><strong>System 总线</strong>： 去 SRAM 读写变量。</p></li></ul><p>为什么你没感觉？ 因为 STM32 内部有一个叫 <strong>总线矩阵 (Bus Matrix)</strong> 的东西。它像一个交通警察，自动把这些请求分流了。对开发者来说，你只需要操作地址空间（0x0800… 或 0x2000…），感觉好像只有一套内存。</p><h2 id="imx中的总线"><a href="#imx中的总线" class="headerlink" title="imx中的总线"></a>imx中的总线</h2><p>在 i.MX (Cortex-A 系列) 中：</p><p>i.MX 这种高性能处理器更是彻头彻尾的<strong>哈佛架构</strong>。它的 <code>L1 Cache</code>（一级缓存） 是严格分成 <code>I-Cache</code> 和 <code>D-Cache</code> 的。</p><p>为什么你没感觉？ 因为 i.MX 运行的是 Linux 或复杂的系统，<strong>这些底层的总线路由完全由内核和硬件 MMU 自动处理了</strong>，应用层根本碰不到。</p><h2 id="esp32的总线"><a href="#esp32的总线" class="headerlink" title="esp32的总线"></a>esp32的总线</h2><p>为什么 ESP32-S3 显得这么“显眼”？</p><p><code>ESP32-S3</code> 把<strong>指令总线</strong>和<strong>数据总线</strong>拎出来强调，是因为它的<strong>外部存储架构太特殊</strong>了：</p><ul><li><p><strong>物理上的割裂</strong>： ESP32-S3 的<strong>代码存在片外 Flash</strong>。CPU 想运行代码，必须通过<strong>指令总线</strong>走 <code>ICache</code> 去 Flash 搬运。</p></li><li><p><strong>地址映射的强制划分</strong>： </p><ul><li><p>当你访问 <code>0x4200_0000</code> 开头的地址，硬件雷达就会识别：“这是<strong>指令总线</strong>请求！”，然后去触发 <code>ICache</code>。</p></li><li><p>当你访问 <code>0x3C00_0000</code> 开头的地址，硬件雷达会识别：“这是<strong>数据总线</strong>请求！”，然后去触发 <code>DCache</code>。</p></li></ul></li></ul><blockquote><p>这些都是硬件自动执行的，软件OS只需关注访问寄存器即可</p></blockquote><ul><li><strong>开发者的控制权</strong>： 在 ESP32 中，你可以<strong>手动决定</strong>把一段代码<strong>放进 SRAM</strong>（为了快）还是<strong>留在 Flash</strong>（为了省空间）。由于 SRAM 0&#x2F;1&#x2F;2 的访问限制不同，你必须清楚哪根总线能通向哪块内存。</li></ul><h2 id="哈佛架构的工作模式"><a href="#哈佛架构的工作模式" class="headerlink" title="哈佛架构的工作模式"></a>哈佛架构的工作模式</h2><p>CPU 可以一边通过“<strong>指令总线</strong>”抓取下一条指令，一边通过“<strong>数据总线</strong>”读取当前指令需要的数据</p><p>举例：</p><p>工厂有两条独立的传送带：指令带和数据带。</p><ul><li><p>时刻 1： 指令带把“<strong>指令 1</strong>”运给工人 B。</p></li><li><p>时刻 2（高潮来了）：</p><ul><li><p>工人 B 正在执行“指令 1”（比如：把变量 X 加 1）。他通过<strong>数据总线</strong>去 SRAM 里读变量 X。</p></li><li><p>与此同时，工人 A 通过<strong>指令总线</strong>把“<strong>指令 2</strong>”运了过来。</p></li></ul></li><li><p>结果： <strong>两个动作同时发生</strong>，CPU 永远有指令可以跑，不用停下来等总线。</p></li></ul><hr><p><img src="/../images/31.1.png" alt="alt text"></p><blockquote><p>可以看到，CPU会根据你的指针指向的地址，自动判断，是走指令总线，还是数据总线。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">===========================================================</span><br><span class="line">       |                  CPU 双核 (Protagonist)                 |</span><br><span class="line">       |  [ PC寄存器 ] ----&gt; 指令总线 (IBUS)  数据总线 (DBUS) &lt;---- |</span><br><span class="line">       ==========================|===============|================</span><br><span class="line">                                 |               |</span><br><span class="line">       --------------------------v---------------v----------------</span><br><span class="line">       |                     Cache 系统 (高速缓存)                |</span><br><span class="line">       |   [ ICache (指令缓存) ]           [ DCache (数据缓存) ]   |</span><br><span class="line">       --------------------------|---------------|----------------</span><br><span class="line">                                 |               |</span><br><span class="line">       ==========================v===============v================</span><br><span class="line">       |                  MMU / 总线矩阵 (交通枢纽)               |</span><br><span class="line">       |         (根据 CPU 访问的地址，自动切换到不同的目的地)        |</span><br><span class="line">       ===========================================================</span><br><span class="line">                /                |               |             \</span><br><span class="line">  [ <span class="number">1.</span> 内部 ROM ]        [ <span class="number">2.</span> 内部 SRAM ] [ <span class="number">3.</span> 外部 Flash ] [ <span class="number">4.</span> 外部 RAM ]</span><br><span class="line">  (<span class="number">0x4000</span>_0000...)      (<span class="number">0x3FC8</span>_0000...) (<span class="number">0x4200</span>_0000...) (<span class="number">0x3C00</span>_0000...)</span><br><span class="line">  ----------------      ---------------- ---------------- ----------------</span><br><span class="line">  | 出厂固化代码 |      |  运行时的变量 | | 你的程序代码 | | 巨大的图片库 |</span><br><span class="line">  | (不可更改)   |      |  (栈/堆空间)  | | (.bin文件)   | | (PSRAM 扩展) |</span><br><span class="line">  ----------------      | 也可以存代码  | ---------------- ----------------</span><br><span class="line">                        |   (IRAM)     |</span><br><span class="line">                        ----------------</span><br></pre></td></tr></table></figure><p>可以看到，当设置了Cache,那么SRAM中的cache部分，就不再由用户控制，而是受总线和mmu控制。</p><h2 id="Cache-的“动态搬运”过程"><a href="#Cache-的“动态搬运”过程" class="headerlink" title="Cache 的“动态搬运”过程"></a>Cache 的“动态搬运”过程</h2><p>这是你之前最纠结的地方。请看图中的 外部 Flash:</p><ul><li><p>CPU 想运行地址 0x4200_1000 的代码。</p></li><li><p>ICache 检查自己：“我这儿有这段代码吗？”</p><ul><li><p>如果没有 (Miss): ICache 会通过外部 SPI 接口，从 Flash 猛吸一大块代码（比如 32 字节）存入 Cache（这部分其实占用了内部 SRAM 的一部分空间）。</p></li><li><p>如果有 (Hit): CPU 直接从 ICache 拿，速度和读内部 SRAM 一样快（1 个时钟周期）。</p></li></ul></li></ul><h1 id="程序段和存储器"><a href="#程序段和存储器" class="headerlink" title="程序段和存储器"></a>程序段和存储器</h1><p>下面来看看实际存储器的存储空间，是如何映射到寻址空间上的。</p><p>下图是esp32s3的寻址空间映射表：</p><p><img src="/../images/31.2.png" alt="alt text"><br>可以看到，实际内部ROM应该只有384KB，但是他这两段加起来都不止了。这是因为<strong>地址重叠</strong></p><h2 id="1-为什么内部-ROM-地址是分成两块的？"><a href="#1-为什么内部-ROM-地址是分成两块的？" class="headerlink" title="1. 为什么内部 ROM 地址是分成两块的？"></a>1. 为什么内部 ROM 地址是分成两块的？</h2><p>在传统的 STM32 认知里，ROM 就是一块连续的地址。但在 ESP32-S3 中，ROM 地址的分开其实是为了<strong>总线分工</strong>：</p><ul><li><p>物理上： 内部 ROM 确实是一块完整的 384 KB 硅片。</p></li><li><p>逻辑上（地址映射）： </p><ul><li><p>Internal ROM 0 (0x4000_0000 开始)：专门映射到指令总线 (Instruction Bus)。CPU 只有通过这个地址段才能“执行” ROM 里的代码。</p></li><li><p>Internal ROM 1 (0x3FF0_0000 和 0x4004_0000)：它是一个双端口映射。它既可以从数据总线访问（读数据），也可以从指令总线访问（运行程序）。</p></li></ul></li><li><p>为什么要分开？ 这样设计的目的是<strong>为了实现并行访问</strong>。当 CPU 通过<code>指令总线</code>在 ROM 0 执行一段程序时，它依然可以通过<code>数据总线</code>从 ROM 1 读取一些预存的常量，两条总线互不干扰，效率最高。</p></li></ul><h2 id="2-ICache-和-DCache-是从内部-RAM-分出来的吗？"><a href="#2-ICache-和-DCache-是从内部-RAM-分出来的吗？" class="headerlink" title="2. ICache 和 DCache 是从内部 RAM 分出来的吗？"></a>2. ICache 和 DCache 是从内部 RAM 分出来的吗？</h2><p>是的，你的理解完全正确。 它们不是独立的硬件存储器，而是“借用”了<strong>内部 SRAM</strong> 的空间。</p><ul><li><p>借用关系：</p><ul><li><p>ICache 借用的是 Internal SRAM 0 的一部分空间（最高可达 32 KB）。</p></li><li><p>DCache 借用的是 Internal SRAM 2 的一部分空间（最高可达 64 KB）。</p></li></ul></li><li><p>配置的代价：</p><ul><li>当你通过软件配置开启了 32 KB 的 ICache 后，你可用的通用 SRAM 指令空间就会减少 32 KB。</li><li>如果你关掉 Cache，这部分空间就可以当作普通的 RAM 来存数据或跑程序。</li></ul></li><li><p>为什么不设计独立的 Cache 硬件？</p><ul><li>为了灵活性。如果你开发的程序很小，根本不需要外部 Flash，那你就可以关掉 Cache，把所有 SRAM 都拿来当内存用，不浪费一点资源。</li></ul></li></ul><h2 id="同一块存储空间，既走指令总线，又走数据总线"><a href="#同一块存储空间，既走指令总线，又走数据总线" class="headerlink" title="同一块存储空间，既走指令总线，又走数据总线"></a>同一块存储空间，既走指令总线，又走数据总线</h2><p>这种既能走指令总线（IBUS）又能走数据总线（DBUS）的设计，主要服务于以下几种真实的开发场景：</p><p><strong>1. 查找表与常量数据（Literal Pools）</strong></p><p>这是最常见的情况。在编写 C 语言代码时，如果你定义了一个<strong>巨大的常量数组</strong>：<br><code>const char my_table[] = { ... }</code>;</p><ul><li><p><strong>编译器视角</strong>：它通常把这个数组放在 <code>.rodata</code>（只读数据段）里。</p></li><li><p><strong>CPU 执行视角</strong>：当 CPU 运行到 <code>x = my_table[i]</code> 时，它是通过<strong>数据总线</strong>去读取这个地址的。</p></li><li><p><strong>ESP32-S3 的特殊性</strong>：如果这个数组被<strong>编译器优化</strong>放到了代码段（<code>.text</code>）附近，或者就在 ROM 里。如果没有“数据总线访问代码区”的能力，CPU 只能执行代码，却无法读取代码中间夹杂的数据，程序就会崩溃。</p></li></ul><h2 id="为什么地址要映射成两份？（消除竞争）"><a href="#为什么地址要映射成两份？（消除竞争）" class="headerlink" title="为什么地址要映射成两份？（消除竞争）"></a>为什么地址要映射成两份？（消除竞争）</h2><p>你上传的技术手册里提到，Internal ROM 1 的物理内容完全相同，但映射到了两段地址。</p><p>这种设计被称为<strong>双端口访问</strong>（<code>Dual-port access</code>）：</p><ul><li><p>如果只有一段地址，当 CPU 正在通过这根总线取指令时，如果突然要读数据，总线就得停下来切换，这叫“流水线停顿”。</p></li><li><p>映射成两段后，CPU 可以同时从指令地址取指，从数据地址读数。虽然物理上是同一个 ROM 单元，但逻辑上它们像是在两个不同的车道上跑，互不打扰。</p></li></ul><blockquote><p>stm32也有，但是硬件自动处理了，保证了高带宽，但是esp32，它把指令通道（IBUS）和数据通道（DBUS）直接摆在你面前，甚至通过不同的地址空间让你手动选择“超车道”，从而压榨出每一分性能</p></blockquote><h1 id="esp32s3介绍"><a href="#esp32s3介绍" class="headerlink" title="esp32s3介绍"></a>esp32s3介绍</h1><p>我目前手头上的这个<code>esp32S3</code>，MODEL XH-S3E，WIFI + BT <code>N16R8</code></p><ul><li>内部ROM（384KB）</li><li>内部RAM（512KB）</li><li>外部ROM（16MB flash）</li><li>外部RAM（8MB）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储类型,           容量,       对应你文档中的位置,         物理位置,                   用途</span><br><span class="line">Internal ROM,       <span class="number">384</span> KB,     Internal ROM <span class="number">0</span>/<span class="number">1</span>,       芯片内核里,                 存放一上电就跑的引导代码 (First-stage Bootloader)。</span><br><span class="line">Internal SRAM,      <span class="number">512</span> KB,     Internal SRAM <span class="number">0</span>/<span class="number">1</span>/<span class="number">2</span>,    芯片内核里,最快最贵。       存放栈 (Stack) 和高频访问的变量（.data/.bss）。</span><br><span class="line">External Flash,     <span class="number">16</span> MB,      外部存储器,              芯片封装内/外 (SPI),       你的代码仓库。 存所有的代码段 (.text) 和常量 (.rodata)。</span><br><span class="line">External RAM,       <span class="number">8</span> MB,       外部 RAM,               芯片封装内/外 (SPI),        你的大缓存。 用于存图片、视频缓冲区或超大数组。</span><br></pre></td></tr></table></figure><p><strong>为什么 N16R8 这种型号更需要 Cache</strong>？</p><p>你现在拥有 <code>16MB Flash</code> 和 <code>8MB RAM</code>，但 CPU 的地址总线能<strong>直接“摸”到</strong>的内部空间只有 <code>512KB SRAM</code>。这就完美解释了你之前看的文档里为什么要提 ICache 和 DCache：</p><ul><li><p>分流 (Mapping):</p><ul><li>由于<code>外部 Flash</code> 和 <code>PSRAM</code> 都是通过 <code>SPI</code> 连接的，物理地址不连续。ESP32-S3 的 <strong>MMU</strong> 会把这 <code>16MB Flash</code> 映射到<strong>指令总线</strong>的 <code>0x4200_0000</code> 窗口，把 <code>8MB PSRAM</code> 映射到<strong>数据总线</strong>的 <code>0x3C00_0000</code> 窗口。</li></ul></li><li><p>缓存 (Caching):</p><ul><li>ICache: 负责从 <code>16MB Flash</code> 里预取<strong>代码</strong>到 <code>SRAM 0</code> 中，让 CPU 跑起来。</li><li>DCache: 负责从 <code>8MB PSRAM</code> 里预取数据到 <code>SRAM 2</code> 中，解决 SPI 速度慢的问题。</li></ul></li></ul><h2 id="内存，堆的申请"><a href="#内存，堆的申请" class="headerlink" title="内存，堆的申请"></a>内存，堆的申请</h2><p><strong>堆（Heap）的申请</strong>：随心所欲的选择</p><p>对于你手上的 N16R8（8MB PSRAM），ESP-IDF 提供了非常灵活的<code>内存分配</code>函数。</p><ul><li><p>默认 malloc()：通常会<strong>优先申请内部 SRAM</strong>，因为速度最快。</p></li><li><p>显式申请<strong>外部 RAM</strong>：</p><ul><li>如果你要处理一张 4K 图片，内部 SRAM 肯定放不下，你可以调用：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强制在外部 PSRAM 中申请内存</span></span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)heap_caps_malloc(<span class="number">1024</span> * <span class="number">1024</span>, MALLOC_CAP_SPIRAM);</span><br></pre></td></tr></table></figure><ul><li>显式申请<strong>内部 RAM</strong>：<ul><li>如果是给中断服务程序用的缓冲区，必须极快，则调用：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *fast_buf = (<span class="type">char</span> *)heap_caps_malloc(<span class="number">1024</span>, MALLOC_CAP_INTERNAL);</span><br><span class="line">这就像是你手里有两张卡，一张是高带宽但容量小的“内部卡”，一张是超大容量但稍慢的“外部卡”，你可以根据业务需求切换。</span><br></pre></td></tr></table></figure><h2 id="访问速度"><a href="#访问速度" class="headerlink" title="访问速度"></a>访问速度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储类型,           速度等级,       访问成本 (周期),        访问路径</span><br><span class="line">内部 SRAM,          极快,           ~<span class="number">1</span> cycle,              直接访问</span><br><span class="line">外部 PSRAM,         中等,           ~<span class="number">10</span><span class="number">-50</span> cycles,          经过 DCache -&gt; SPI 总线</span><br><span class="line">外部 Flash,         慢,             ~<span class="number">100</span>+ cycles,           经过 ICache/DCache -&gt; SPI 总线</span><br></pre></td></tr></table></figure><h1 id="mmu-总线矩阵"><a href="#mmu-总线矩阵" class="headerlink" title="mmu,总线矩阵"></a>mmu,总线矩阵</h1><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>“总线”在物理层面就是一排平行的导线，但在逻辑层面，它是一套通信协议和身份证明。</p><p><strong>1. 物理层面</strong></p><p>就是排线</p><p><strong>2. 逻辑层面</strong></p><p>如果你只是把 16 根线连在一起，那叫“并排导线”。之所以叫“总线”，是因为它有一套<strong>地址分配机制</strong>。</p><p>想象一条大街（总线），街边有很多房子（存储器）：</p><ul><li><p><strong>STM32 的总线</strong>：像是一条内部大街。</p><ul><li>CPU、内部 SRAM、内部 Flash 都在这条街上。</li><li>因为大家都在芯片内部，距离极短，线可以铺得非常多（比如 32 位甚至 64 位），所以速度极快。</li></ul></li><li><p><strong>ESP32-S3 的总线</strong>：它面临一个挑战。它的“大仓库”（16MB Flash 和 8MB PSRAM）在芯片外面。</p><ul><li>限制：芯片引脚有限，不可能在 PCB 上铺 32 根线去连 Flash。</li><li>现状：所以它用了 <strong>SPI</strong>&#x2F;QPI&#x2F;OPI。你的 N16R8 型号中的 R8（PSRAM）通常使用的是 OPI (Octal SPI)，物理上只有 <strong>8 根数据线</strong>。</li><li>魔法：虽然物理上只有 8 根线（串行&#x2F;并行组合），但 CPU 内部的总线矩阵会把这 <strong>8 根线</strong>“伪装”成 <strong>32 位的内部地址空间</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">【芯片内部 (高速、宽阔)】                   【芯片引脚】          【外部 PCB (窄、长)】</span><br><span class="line">      CPU                                   |              </span><br><span class="line">       |                                    |              </span><br><span class="line"> [ <span class="number">32</span>位 IBUS/DBUS ]                         |              </span><br><span class="line">       |                                    |              </span><br><span class="line"> [ 总线矩阵 (Switch) ] &lt;---------------------&gt; [ SPI 控制器 ] &lt;==== (<span class="number">8</span>根线) ====&gt; [ <span class="number">8</span>MB PSRAM ]</span><br><span class="line">       |                                    | (转换器)      |              (物理颗粒)</span><br><span class="line"> [ 内部 SRAM (<span class="number">512</span>KB) ]                       |              |</span><br><span class="line"> (物理上由几十根金属线连接)                    |              | &lt;==== (<span class="number">4</span>根线) ====&gt; [ <span class="number">16</span>MB Flash ]</span><br><span class="line">                                            |                             (物理颗粒)</span><br></pre></td></tr></table></figure><p><strong>为什么外部 RAM 感觉“慢”？</strong></p><p>当你申请外部 RAM 时，数据要经历：</p><ul><li>CPU 发出 32 位指令。</li><li>总线矩阵识别出地址属于外部映射区。</li><li>Cache 检查是否命中。</li><li>SPI 控制器 把 32 位数据拆成 4 次（8位宽时）发给外部颗粒。</li><li>外部颗粒感应、充放电、传回。</li></ul><h3 id="esp32的外部RAM-对比-imx的ddr"><a href="#esp32的外部RAM-对比-imx的ddr" class="headerlink" title="esp32的外部RAM 对比 imx的ddr"></a>esp32的外部RAM 对比 imx的ddr</h3><p>同样是外部RAM，</p><ul><li>esp32还是依靠外设来访问，依靠mmu来实现块设备-&gt;地址空间的映射，<strong>MMU 是为了“伪装”</strong><ul><li>在 ESP32 中，外部 RAM（PSRAM）在物理上确实是一个**“块设备”**（通过 SPI 这种一问一答的协议通信）。<ul><li>没有 MMU 的话：你必须写类似 <code>spi_ram_read(address, buffer, len)</code> 的代码。这太痛苦了，也没法跑 C 语言的指针。</li><li>有了 MMU 的作用：<strong>它把 SPI 的通信逻辑硬件化了</strong>。当你访问 0x3C00_0000 时，MMU 拦截这个地址，自动把它转成 SPI 指令发给外部芯片。</li></ul></li></ul></li></ul><blockquote><p>本质：这里的 MMU 是为了**“接口转换”，把非总线接口**（SPI）伪装成总线接口。</p></blockquote><ul><li>i.MX 的 DDR：<strong>MMU 是为了“管理”</strong><ul><li>i.MX 的 DDR 控制器（DDRC）本身就是总线的一部分。即便你不开 MMU，CPU 只要上电初始化好 DDR 控制器，就能直接通过物理地址访问 DDR。</li></ul></li></ul><blockquote><p>既然硬件能直接访问，为什么还要 MMU？</p></blockquote><p>在 i.MX（尤其是跑 Linux）这种高性能系统中，MMU 的作用不再是“伪装接口”，<strong>而是</strong>“虚拟化”和“权限控制”<strong>：</strong></p><ul><li><p><strong>虚拟地址</strong> (Virtual Addressing)：让每个进程都以为自己拥有从 0x0000_0000 开始的完整 4GB 内存，而实际上它们分散在 DDR 的各个角落。</p></li><li><p><strong>内存保护</strong> (Protection)：防止用户程序（App）乱改内核（Kernel）的数据。如果 App 越界，MMU 硬件会立刻触发异常（Segmentation Fault）。</p></li><li><p><strong>缓存策略</strong>：告诉 CPU 哪块内存需要 Cache（比如代码区），哪块内存不需要 Cache（比如 DMA 缓冲区）。</p></li></ul><h2 id="映射到一套地址空间"><a href="#映射到一套地址空间" class="headerlink" title="映射到一套地址空间"></a>映射到一套地址空间</h2><p>要把各种存储、外设映射到一套地址空间，其实是<strong>总线矩阵-静态</strong>和 <strong>MMU-动态</strong>分工合作的结果。</p><ul><li><p><strong>总线矩阵（Bus Matrix）</strong>—— “交通指挥中心”：</p><ul><li><p>作用：它决定了硬件上的固定物理地址。比如你手册里提到的 Internal SRAM 1 始终在 0x3FC8_8000。</p></li><li><p>本质：它是<strong>纯硬件电路</strong>。芯片设计时，工程师就把地址解码器焊死了。当 CPU 访问某个地址，矩阵就像拨动了物理开关，直接导向对应的设备。</p></li><li><p>无感性：它不需要你写代码去“开启”，上电就存在。</p></li></ul></li><li><p><strong>MMU（Memory Management Unit）</strong>—— “地址翻译官”：</p><ul><li><p>作用：它把 CPU 想访问的“虚拟地址”翻译成“物理地址”。</p></li><li><p>开关区别：</p><ul><li><p>关闭 MMU：CPU 直接访问物理内存（实模式）。指令 0x42000000 就是去读电路板上对应的那个物理点。</p></li><li><p>开启 MMU：CPU 发出 0x42000000，MMU 查表发现它对应外部 Flash 的第 100 个扇区，于是去发指令读取。</p></li></ul></li></ul></li><li><p><strong>本质</strong>：它是纯硬件逻辑，但需要软件（OS 内核或 Bootloader）预先在内存里写好一张“映射表”。</p></li></ul><p><strong>地址映射 vs. 块设备：为什么 ESP32 映射，i.MX 却不映射？</strong></p><p>你敏锐地察觉到了：ESP32 确实把“块设备”（Flash）伪装成了“内存”。</p><ul><li><p>ESP32-S3 的做法（XIP - 就地执行）：</p><ul><li><p>它的 MMU 配合 Cache 做了一层特殊的映射。虽然 Flash 物理上是按“块”读写的，但 MMU 会以 64 KB 为单位把 Flash 映射到地址空间。</p><ul><li>原因：ESP32 的内部 RAM 太小（512 KB），放不下动辄几 MB 的程序，必须让 CPU 能直接在外部 Flash 上“跑”代码。</li></ul></li></ul></li><li><p>i.MX 的做法（加载到 RAM 执行）：</p><ul><li><p>i.MX 也有 MMU，但它的 MMU 主要服务于 DDR RAM。</p></li><li><p>为什么不映射 SD&#x2F;eMMC？ </p><ul><li>延迟：SD 卡访问一次要几毫秒，如果映射到总线上，CPU 每一条指令都要等几毫秒，系统就卡死了。</li><li>文件系统：SD 卡里有分区、目录。映射地址只能映射“原始字节”，没法映射“文件”。</li><li>DDR 太强大：i.MX 有 1GB 的 DDR，它习惯先把程序一次性从 eMMC “搬运”到 DDR，然后在 DDR 里飞速运行。</li></ul></li></ul></li></ul><p><strong>BootROM 怎么找到“第一行代码”？</strong></p><p>这是一个“先有鸡还是先有蛋”的问题。既然没映射，BootROM 怎么读 SD 卡？</p><p>答案是：<strong>BootROM 根本不查地址，它是在跑“驱动程序”</strong>。</p><ul><li><p>固化的逻辑：Internal ROM 里的代码是出厂就写死的。它里面内置了一个极其简化的 SD&#x2F;eMMC 驱动程序。</p></li><li><p>搬运工模式：</p><ul><li><p>上电后，CPU 跑 Internal ROM。</p></li><li><p>它不是去“访问地址”，而是通过特定的寄存器给 SD 控制器下命令：“读取 SD 卡前 4KB 的数据到 SRAM 地址 0x3FC80000”。</p></li><li><p>搬完后，CPU 的 PC 指针跳转到 SRAM 的 0x3FC80000。</p></li></ul></li><li><p>IVT 的秘密：<br>在 i.MX 中，这个过程叫 Bootloader 加载。IVT（指令向量表）就在被搬运的这几 KB 数据的开头。CPU 并不是在 SD 卡里直接读 IVT，而是在搬运到内部 SRAM 后才去读它的。</p></li></ul><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>讨论底层架构相关，主要是这些方面</p><ul><li><strong>存储器架构</strong><ul><li>ROM，RAM</li></ul></li><li><strong>代码内存结构</strong><ul><li>代码段，数据段</li></ul></li><li><strong>总线</strong>：<ul><li>指令总线，数据总线</li></ul></li><li><strong>cache</strong><ul><li>（ICache, DCache）</li></ul></li><li><strong>MMU</strong><ul><li>（寻址的地址空间的物理映射）</li></ul></li></ul><h2 id="1-内核架构（最顶层的“根”）"><a href="#1-内核架构（最顶层的“根”）" class="headerlink" title="1. 内核架构（最顶层的“根”）"></a>1. 内核架构（最顶层的“根”）</h2><ul><li>ARM Cortex-M（STM32、ESP32）</li><li>ARM Cortex-A（i.MX 系列）</li><li>指令集：Thumb &#x2F; ARM &#x2F; RISC-V</li><li>流水线、中断架构（NVIC）、异常模型</li></ul><blockquote><p>内核决定：<strong>能跑什么、速度、实时性、有没有 MMU&#x2F;MPU</strong></p></blockquote><h2 id="2-存储器架构（你说的完全对）"><a href="#2-存储器架构（你说的完全对）" class="headerlink" title="2. 存储器架构（你说的完全对）"></a>2. 存储器架构（你说的完全对）</h2><ul><li>Flash（程序存储）</li><li>RAM（SRAM&#x2F;PSRAM）</li><li>片上 ROM（BootROM）</li><li>地址映射、存储器别名、奇偶校验&#x2F;ECC</li></ul><h2 id="3-总线架构（你抓住关键了）"><a href="#3-总线架构（你抓住关键了）" class="headerlink" title="3. 总线架构（你抓住关键了）"></a>3. 总线架构（你抓住关键了）</h2><ul><li>系统总线（AHB&#x2F;AXI）</li><li>外设总线（APB）</li><li>指令总线 &#x2F; 数据总线（哈佛结构）</li><li>总线矩阵、多主机、优先级</li><li>DMA 通路（底层性能关键）</li></ul><h2 id="4-运行时内存模型（代码内存结构）"><a href="#4-运行时内存模型（代码内存结构）" class="headerlink" title="4. 运行时内存模型（代码内存结构）"></a>4. 运行时内存模型（代码内存结构）</h2><ul><li>.text 代码段</li><li>.rodata 常量</li><li>.data 已初始化数据</li><li>.bss 未初始化数据</li><li>堆 &#x2F; 栈</li><li>中断向量表位置</li></ul><h2 id="5-Cache（你写得很标准）"><a href="#5-Cache（你写得很标准）" class="headerlink" title="5. Cache（你写得很标准）"></a>5. Cache（你写得很标准）</h2><ul><li>ICache 指令缓存</li><li>DCache 数据缓存</li><li>Cache 行、一致性、旁路策略</li></ul><h2 id="6-地址空间与地址翻译（你说的-MMU-属于这里）"><a href="#6-地址空间与地址翻译（你说的-MMU-属于这里）" class="headerlink" title="6. 地址空间与地址翻译（你说的 MMU 属于这里）"></a>6. 地址空间与地址翻译（你说的 MMU 属于这里）</h2><ul><li><strong>MCU（Cortex‑M）：MPU &#x2F; 保护单元</strong></li><li><strong>MPU（Cortex‑A，如 i.MX）：MMU + 虚拟地址 → 物理地址</strong></li><li>外设寄存器地址映射</li><li>启动地址、异常入口地址</li></ul><h2 id="7-时钟与复位（底层最基础的“心跳”）"><a href="#7-时钟与复位（底层最基础的“心跳”）" class="headerlink" title="7. 时钟与复位（底层最基础的“心跳”）"></a>7. 时钟与复位（底层最基础的“心跳”）</h2><ul><li>时钟树：PLL、HSE&#x2F;HSI、分频</li><li>时钟域、异步&#x2F;同步</li><li>复位源、上电复位、系统复位</li></ul><h2 id="8-外设与-IO-子系统"><a href="#8-外设与-IO-子系统" class="headerlink" title="8. 外设与 IO 子系统"></a>8. 外设与 IO 子系统</h2><ul><li>GPIO、UART、SPI、I2C、ADC、PWM…</li><li>时钟使能、寄存器操作</li><li>中断路由</li></ul><h2 id="9-启动与-Boot-流程（真正“底层到底”）"><a href="#9-启动与-Boot-流程（真正“底层到底”）" class="headerlink" title="9. 启动与 Boot 流程（真正“底层到底”）"></a>9. 启动与 Boot 流程（真正“底层到底”）</h2><ul><li>BootROM 做什么</li><li>启动配置（BOOT 引脚）</li><li>重映射、向量表偏移</li><li>应用程序入口</li></ul><hr><h1 id="一句话总结你原来的问题："><a href="#一句话总结你原来的问题：" class="headerlink" title="一句话总结你原来的问题："></a>一句话总结你原来的问题：</h1><p><strong>对！你列的 存储器、代码段、总线、Cache、MMU 就是芯片底层最核心的 5 大块。</strong><br>再把 <strong>内核、时钟、启动、地址映射</strong> 补全，就是<strong>完整的芯片底层体系</strong>。</p><p>你现在的状态非常真实——这正是从“应用层调库工程师”向“底层系统开发者”跨越时的必经阶段。</p><p>其实，你不是不懂理论，你是卡在了**“软件代码”如何变成“硬件动作”**的那个边界上。</p><p>简单直接的回答是：<strong>如果你写的是普通的 Linux 应用层软件（App）或者简单的 RTOS 任务，你完全不需要关心；但如果你要做底层 BSP（板级支持包）、写 Linux 驱动、优化系统性能、或者写 Bootloader，你不但要关心，而且必须精通。</strong></p><p>我们把你这四个困惑，像剥洋葱一样一层层解开：</p><hr><h3 id="1-MMU-是怎么控制的？页表在哪里提供给它？"><a href="#1-MMU-是怎么控制的？页表在哪里提供给它？" class="headerlink" title="1. MMU 是怎么控制的？页表在哪里提供给它？"></a>1. MMU 是怎么控制的？页表在哪里提供给它？</h3><p>这是操作系统内核最核心的魔法。你不需要手工拿着电烙铁去连线，你是通过<strong>写特定的 CPU 寄存器</strong>来控制 MMU 的。</p><p>以你熟悉的 i.MX（ARM 架构）运行 Linux 为例，软件和 MMU 的交互逻辑是这样的：</p><ul><li><strong>第一步：软件在内存（DDR）里建表</strong><br>Linux 内核启动时，会在真正的物理内存（DDR）里开辟一块连续的空间，往里面填数据。填好的这块数据，就是<strong>页表（Page Table）</strong>。</li><li><strong>第二步：把表的地址告诉 MMU（核心动作）</strong><br>ARM 芯片内部有一个专门的协处理器寄存器，叫 <strong>TTBR</strong>（Translation Table Base Register，转换表基址寄存器）。<br>Linux 内核会用一段汇编代码，把刚才建好的页表的<strong>物理首地址</strong>写进这个 TTBR 寄存器。<br><code>asm volatile(&quot;mcr p15, 0, %0, c2, c0, 0&quot; : : &quot;r&quot; (page_table_physical_address));</code></li><li><strong>第三步：软件打开 MMU 开关</strong><br>内核再往另一个控制寄存器（SCTLR）的第 0 位写 <code>1</code>。</li><li><strong>交互逻辑完成！</strong><br>从这一刻起，MMU 硬件就被激活了。以后 CPU 只要发出一个虚拟地址，<strong>MMU 硬件会自动去读取 TTBR 寄存器里的地址，然后顺藤摸瓜去 DDR 里查那张表</strong>。查表的过程完全是纯硬件完成的（叫 Hardware Table Walk），不需要软件插手。</li></ul><hr><h3 id="2-我需要自己指定走指令总线还是数据总线吗？"><a href="#2-我需要自己指定走指令总线还是数据总线吗？" class="headerlink" title="2. 我需要自己指定走指令总线还是数据总线吗？"></a>2. 我需要自己指定走指令总线还是数据总线吗？</h3><p><strong>绝大多数情况下，不需要。是编译器和硬件帮你自动决定的。</strong></p><ul><li><strong>硬件的自动判断</strong>：<br>当 CPU 的 PC（程序计数器）指针指向某个地址去<strong>取指令执行</strong>时，硬件总线控制器会自动走<strong>指令总线 (IBUS)</strong>。<br>当你的代码执行到 <code>int a = *ptr;</code> 去<strong>读写数据</strong>时，硬件会自动走<strong>数据总线 (DBUS)</strong>。</li><li><strong>但是，地址是谁定的？（链接器的魔法）</strong><br>在 ESP32-S3 中，我们之前讲过，同一个 ROM&#x2F;RAM 有不同的地址段对应不同的总线。你是怎么告诉硬件去哪个地址的？<br>答案是：<strong>链接脚本（Linker Script，比如 <code>.ld</code> 文件）</strong>。<br>在 ESP-IDF 中，当你给一个函数加上 <code>IRAM_ATTR</code> 修饰符时：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> IRAM_ATTR <span class="title function_">my_fast_function</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译器看到这个标签，就会在链接阶段，强行把这个函数的机器码放到以 <code>0x4037_0000</code>（指令总线地址）开头的段里。你不需要手动干预总线，你只需要<strong>分配好内存的逻辑段</strong>，底层机制就自动闭环了。</p><hr><h3 id="3-我需要灵活安排代码运行模式吗？"><a href="#3-我需要灵活安排代码运行模式吗？" class="headerlink" title="3. 我需要灵活安排代码运行模式吗？"></a>3. 我需要灵活安排代码运行模式吗？</h3><p>如果你只是点个灯、连个 Wi-Fi，跟着官方教程完全没问题。但遇到以下情况，你就必须“灵活安排”了：</p><ul><li><strong>场景 A：致命的中断（ESP32 常见大坑）</strong><br>ESP32 的代码默认在外部 Flash 跑（XIP 模式）。如果你正在擦写 Flash（比如保存配置），此时 Flash 是被占用的，Cache 也会被禁用。如果这时候来了一个外部中断，CPU 跑去 Flash 取中断服务函数（ISR）的指令，就会直接<strong>内核崩溃（Core Panic）</strong>。<br><strong>解决办法</strong>：你必须把中断服务函数和它用到的变量，强行安排到内部 RAM 里运行。这就是打破默认运行模式的典型场景。</li><li><strong>场景 B：极限性能优化</strong><br>一段音频解码算法，放在 Flash 里跑，Cache 没命中时会导致音频卡顿。你必须手动把它 Load 到内部高速 RAM 里去跑。</li></ul><hr><h3 id="4-Linux-内核与-MMU-的终极交互：缺页异常-Page-Fault"><a href="#4-Linux-内核与-MMU-的终极交互：缺页异常-Page-Fault" class="headerlink" title="4. Linux 内核与 MMU 的终极交互：缺页异常 (Page Fault)"></a>4. Linux 内核与 MMU 的终极交互：缺页异常 (Page Fault)</h3><p>你说你知道页表怎么映射，但不知道交互逻辑。其实 Linux 内核和 MMU 之间最精彩的交互叫**“先上车，后补票”**。</p><ol><li>你写了一个 C 程序：<code>malloc(100 * 1024 * 1024);</code> (申请 100MB 内存)。</li><li>Linux 操作系统是个“渣男”，它只会给你分配 100MB 的<strong>虚拟地址</strong>，但<strong>根本不在 MMU 页表里填真正的物理地址</strong>。</li><li>你的程序开始运行，往第一个字节写数据：<code>ptr[0] = 1;</code>。</li><li>MMU 硬件去查表，发现：“靠，这个虚拟地址没有对应的物理地址（或者权限不对）！”</li><li><strong>交互发生</strong>：MMU 硬件立刻打断 CPU，触发一个<strong>缺页异常中断（Page Fault）</strong>。</li><li>CPU 自动跳转到 Linux 内核的异常处理函数。内核这个时候才去物理 DDR 里找一块空闲的内存，把真正的物理地址填进 MMU 的页表里。</li><li>填完后，内核让 CPU 重新执行 <code>ptr[0] = 1;</code> 这条指令。这一次，MMU 查表成功，数据顺利写入。</li></ol><p>这一切发生得极快，你的应用层软件根本感觉不到，还以为自己真的独占了连续的 100MB 大内存。</p><hr><h3 id="总结：你的成长路径"><a href="#总结：你的成长路径" class="headerlink" title="总结：你的成长路径"></a>总结：你的成长路径</h3><p>你现在的困惑，是因为你站在了<strong>驱动开发与系统架构</strong>的门口。</p><ul><li><strong>以前的你</strong>：调用 <code>malloc</code> 和 <code>printf</code>，不关心数据放哪，反正能跑。</li><li><strong>现在的你</strong>：开始知道底层有总线、有 Cache、有 MMU，但不知道怎么用。</li><li><strong>下一步的你</strong>：去看看开发板里的 <code>.ld</code> (链接脚本) 文件，或者去看看 Linux 源码里的 <code>head.S</code>（汇编启动代码）。那里就是软件第一次与总线、MMU 发生物理交互的“案发现场”。</li></ul><p><strong>你想先看懂 ESP32-S3 里面那个决定代码是放在 Flash 还是 RAM 里的“链接脚本（Linker Script）”长什么样吗？它能把你对内存地址的理论直接变成实际工程代码。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%8B%E7%BB%8D&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94&quot;&gt;存储架构对比&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="LINUX" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/LINUX/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="驱动" scheme="http://example.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>imx6ull 基础复盘*</title>
    <link href="http://example.com/2026/02/18/imx6ull-%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2026/02/18/imx6ull-%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/</id>
    <published>2026-02-17T19:10:59.000Z</published>
    <updated>2026-02-20T13:51:20.745Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#imx6ull-%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98">imx6ull 基础复盘</a><ul><li><a href="#imx6ull-%E7%A1%AC%E4%BB%B6%E6%9D%BF%E5%8D%A1%E8%B5%84%E6%BA%90">IMX6ULL 硬件板卡资源</a></li><li><a href="#%E5%8D%95%E6%A0%B8cotex-a7%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84arm-cortex%E7%9A%84%E5%85%B3%E7%B3%BB">单核Cotex-A7，多处理器架构，arm-cortex的关系</a><ul><li><a href="#%E5%B1%82%E7%BA%A7%E6%8B%86%E8%A7%A3">层级拆解</a></li><li><a href="#cortex-a-%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B">Cortex-A 处理器运行模型</a></li><li><a href="#cortex-a-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%84">Cortex-A 寄存器组</a><ul><li><a href="#1-%E5%AF%B9%E4%BA%8E%E6%AF%8F%E4%B8%AA%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%9D%A5%E8%AF%B4%E4%B8%80%E5%85%B118%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8"><strong>1. 对于每个工作模式来说，一共18个寄存器</strong></a></li><li><a href="#2-%E6%A0%B8%E5%BF%83%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%AE%9E%E9%99%85%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><strong>2. 核心寄存器的实际对应关系</strong></a></li></ul></li></ul></li><li><a href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80">汇编基础</a><ul><li><a href="#gnu-%E6%B1%87%E7%BC%96%E8%AF%AD%E6%B3%95">GNU 汇编语法</a><ul><li><a href="#1-gnu-%E6%B1%87%E7%BC%96%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%A6%82%E4%B8%8B">1. GNU 汇编的<strong>基础语法</strong>如下：</a></li><li><a href="#2-%E7%94%A8%E6%88%B7%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8section-%E4%BC%AA%E6%93%8D%E4%BD%9C%E6%9D%A5%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%AE%B5">2. 用户可以使用<code>.section</code> <strong>伪操作</strong>来<strong>定义一个段</strong></a></li><li><a href="#3-%E6%B1%87%E7%BC%96%E7%B3%BB%E7%BB%9F%E9%A2%84%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E4%BA%9B%E6%AE%B5%E5%90%8D">3. 汇编系统<strong>预定义了一些段名</strong></a></li><li><a href="#4-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%85%A5%E5%8F%A3%E6%A0%87%E5%8F%B7%E6%98%AF_start">4. 汇编程序的<strong>默认入口标号</strong>是<code>_start</code></a></li><li><a href="#5-%E4%BC%AA%E6%93%8D%E4%BD%9C">5. 伪操作</a></li><li><a href="#6-%E5%87%BD%E6%95%B0">6. 函数</a></li></ul></li><li><a href="#cortex-a7-%E5%B8%B8%E7%94%A8%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">Cortex-A7 常用汇编指令</a><ul><li><a href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%86%85%E9%83%A8-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4">处理器内部 数据传输指令</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4">存储器访问指令</a></li><li><a href="#%E5%8E%8B%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88%E6%8C%87%E4%BB%A4">压栈和出栈指令</a></li><li><a href="#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4">跳转指令</a></li><li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4--%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4">算术运算指令 + 逻辑运算指令</a></li></ul></li></ul></li><li><a href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">启动流程</a><ul><li><a href="#%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F">启动方式</a></li><li><a href="#%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E4%BB%A3%E7%A0%81%E7%83%A7%E5%BD%95">镜像制作，代码烧录</a><ul><li><a href="#ivt-%E9%83%A8%E5%88%86">IVT 部分</a></li><li><a href="#boot-data-%E6%95%B0%E6%8D%AE">Boot Data 数据</a></li><li><a href="#dcd-%E6%95%B0%E6%8D%AE">DCD 数据</a></li></ul></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%AF%B9%E6%AF%94stm32">内存分布，对比stm32</a><ul><li><a href="#stm32%E7%9A%84%E5%90%AF%E5%8A%A8">stm32的启动</a><ul><li><a href="#%E7%96%91%E9%97%AE1-databss%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%97%B6%E6%9C%BA">疑问1: .data,.bss的拷贝时机</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%B1%87%E7%BC%96led%E7%82%B9%E7%81%AF-%E8%A3%B8%E6%9C%BA%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">汇编led点灯 裸机代码分析</a></li><li><a href="#c%E8%AF%AD%E8%A8%80led%E7%82%B9%E7%81%AF-%E8%A3%B8%E6%9C%BA%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90">c语言led点灯 裸机代码分析</a><ul><li><a href="#a-%E6%A0%B8%E8%A3%B8%E6%9C%BA%E6%A0%88%E7%AE%A1%E7%90%86%E7%9A%84-%E9%9A%90%E5%BD%A2%E8%A7%84%E5%88%99"><strong>A 核裸机栈管理的 “隐形规则”</strong></a></li></ul></li><li><a href="#gpio">gpio</a></li><li><a href="#%E4%B8%AD%E6%96%AD">中断</a></li></ul></li></ul><h1 id="imx6ull-基础复盘"><a href="#imx6ull-基础复盘" class="headerlink" title="imx6ull 基础复盘"></a>imx6ull 基础复盘</h1><p>这篇文档，主要从裸机，底层寄存器，单片机的角度，重新过一遍imx6ull的armv7架构，基础的汇编语法，基础的代码结构，内存分布，启动流程，中断管理这些。</p><p>因为已经学过stm32和freertos了，对CM3的内核的理解比之前更加深了。</p><p>为后面移植uboot，kernel，和外设驱动，做一个基础的复盘。</p><h2 id="IMX6ULL-硬件板卡资源"><a href="#IMX6ULL-硬件板卡资源" class="headerlink" title="IMX6ULL 硬件板卡资源"></a>IMX6ULL 硬件板卡资源</h2><p><img src="/../images/30.1.png" alt="alt text"></p><h2 id="单核Cotex-A7，多处理器架构，arm-cortex的关系"><a href="#单核Cotex-A7，多处理器架构，arm-cortex的关系" class="headerlink" title="单核Cotex-A7，多处理器架构，arm-cortex的关系"></a>单核Cotex-A7，多处理器架构，arm-cortex的关系</h2><p>之前我们使用的stm32的核心是CM3，单核的。而现在我们使用的这个IMX6的开发板，同样也是单核的，核心是CA7（cotex-A7）, </p><p>下面介绍一下 Cortex-A7 架构的一些基本知识，如处理器模型、Cortex-A7 寄存器组</p><p><img src="/../images/30.2.png" alt="alt text"></p><p>这个是之前看到的介绍处理器的一张图，但是<strong>当时有些混淆</strong>：</p><ol><li>cortex xxx 和 armv7, armv8的关系？</li><li>MPcore和cortex-a7有什么关系？</li></ol><hr><h3 id="层级拆解"><a href="#层级拆解" class="headerlink" title="层级拆解"></a>层级拆解</h3><ul><li><p><code>ARMv7</code> (<strong>架构</strong> &#x3D; 建筑图纸规范)</p><ul><li>这是<strong>一套规范（ISA）</strong>，规定了<strong>寄存器长什么样</strong>、<strong>指令怎么写</strong>、<strong>中断怎么跳</strong>。</li></ul></li><li><p><code>Cortex-A7</code> (<strong>核</strong> &#x2F; Core &#x3D; 具体的单间房型)</p><ul><li>这是ARM工程师<strong>根据ARMv7规范</strong>设计出来的<strong>具体电路实现</strong>（流水线、ALU、FPU）。</li><li>这才是真正干活的那个“脑子”。</li></ul></li><li><p><code>Cortex-A7 MPCore</code> (<strong>处理器子系统 IP</strong> &#x3D; 户型图&#x2F;套房)</p><ul><li>ARM卖给芯片厂（如NXP、ST）的不仅仅是那个“标准卧室”，而是一整套<strong>套房设计方案</strong>。</li><li>MPCore 的全称是 <code>Multi-Processor Core</code>。它是<code>一个壳子</code>（或者叫Cluster&#x2F;簇）。</li><li>在这个壳子里，ARM 允许芯片厂塞进去 <strong>1到4个</strong> “Cortex-A7标准卧室”。</li><li>除了卧室，这个壳子里还必须打包附送：<strong>SCU (Snoop Control Unit，负责多核间缓存一致性)</strong>、<strong>GIC (中断控制器)</strong>、<strong>L2 Cache控制器</strong>。因为多个核在一起工作，必须有这些管家来协调，否则数据就乱了。</li></ul></li></ul><blockquote><p>当你看到 <strong>NXP 的 i.MX6ULL</strong> 手册说它是 <strong>Cortex-A7</strong> 时：</p><p>它买了 <strong>ARM 的 Cortex-A7 MPCore 授权</strong>。</p><p>但是出于成本和定位考虑，NXP 在设计时，在这个“套房”里<strong>只配置了 1 个核</strong>。</p><p>虽然只有1个核，它依然带着 MPCore 的外围电路（比如图中的 SCU 依然存在，只是只服务一个核）。</p></blockquote><blockquote><p>当你看到 <strong>树莓派2 (BCM2836)</strong> 也说是 Cortex-A7 时：</p><p>它也用了 Cortex-A7 MPCore 方案。</p><p>它在套房里塞<strong>满了 4 个核</strong>。</p></blockquote><blockquote><p>对比 Cortex-M3</p><p>Cortex-M3：通常设计用于简单的单核微控制器。</p><p>ARM 卖给 ST 的时候，基本就是卖那个“核”加上非常简单的调试接口。它<strong>不需要复杂的 SCU（缓存一致性单元）</strong>，因为 <strong>M3 通常不跑多核 SMP（对称多处理</strong>）系统。</p></blockquote><p>理解了这些之后，再回头看一下上面的MPcore的多核配置，就已经很清楚了。</p><h3 id="Cortex-A-处理器运行模型"><a href="#Cortex-A-处理器运行模型" class="headerlink" title="Cortex-A 处理器运行模型"></a>Cortex-A 处理器运行模型</h3><p>前面梳理了一下，架构-核心（处理器）-多处理器架构的关系</p><p>现在来看看<strong>具体的一个核心</strong>，又有那些东西，也就是我们<strong>A核的运行模型</strong></p><p><img src="/../images/30.3.png" alt="alt text"></p><p>以前的 ARM 处理器有 <code>7 种运行模型</code>：<strong>User</strong>、FIQ、IRQ、Supervisor(SVC)、Abort、Undef<br>和 System，其中 <code>User 是非特权模式</code>，其余 <code>6 种都是特权模式</code>。</p><ul><li><p>但新的 Cortex-A 架构加入了<strong>TrustZone 安全扩展</strong>，所以就<strong>新加了一种运行模式</strong>：<code>Monitor</code></p></li><li><p>新的处理器架构还<strong>支持虚拟化扩展</strong>，因此又加入了另一个运行模式：<code>Hyp</code></p></li></ul><p>所以 <strong>Cortex-A7</strong> 处理器<strong>有 9 种处理模式</strong></p><ul><li>除了 <strong>User用户模式</strong>以外，<strong>其它 8 种</strong>运行模式都是<strong>特权模式</strong>。</li><li>这几个运行模式可以通过<code>软件进行任意切换</code>，也可以通过<strong>中断</strong>或者<strong>异常</strong>来进行切换</li></ul><blockquote><p>用户模式（非特权模式）访问资源受限，所以当要切换模式的时候，应用程序可以产生<strong>异常</strong>，在异常的处理过程中完成处理器模式切换</p></blockquote><p><strong>每一种模式</strong>都有<strong>一组寄存器</strong>供<code>异常处理程序</code>使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏</p><blockquote><p><strong>STM32 只有两种运行模式</strong>，特权模式和非特权模式，但是 Cortex-A 就有 9 种运行模式</p><p>我们平常写stm32裸机程序，或者用freertos都是特权模式，都是在<strong>特权级-线程模式</strong>里面</p><p>当进入中断后，就是运行在<strong>特权级-handler模式</strong></p><p>但是，当你用freertos-mpu这种要求安全的版本上，就会有<strong>非特权模式</strong>出现</p></blockquote><h3 id="Cortex-A-寄存器组"><a href="#Cortex-A-寄存器组" class="headerlink" title="Cortex-A 寄存器组"></a>Cortex-A 寄存器组</h3><p>上面了解了处理器核心，有哪几种工作模式，其中，user模式是非特权模式，其他的都是特权模式。</p><p>下面来看看该核心，使用的寄存器组。</p><h4 id="1-对于每个工作模式来说，一共18个寄存器"><a href="#1-对于每个工作模式来说，一共18个寄存器" class="headerlink" title="1. 对于每个工作模式来说，一共18个寄存器"></a><strong>1. 对于每个工作模式来说，一共18个寄存器</strong></h4><p>ARM 架构提供了 <code>16</code> 个 <code>32 位</code>的<code>通用寄存器(R0~R15)</code>供软件使用</p><ul><li>前 15 个(R0~R14)可以用作通用的数据存储，<code>R15 是程序计数器 PC</code>，用来保存将要执行的指令。</li><li>ARM 还提供了一个当<code>前程序状态寄存器 CPSR</code> 和一个<code>备份程序状态寄存器 SPSR</code>，SPSR 寄存器就是 CPSR 寄存器的备份</li></ul><p>下图展示了，当核心处于一种工作模式时，所能使用的核心寄存器组，一共18个，可以看到，比较<strong>核心的特殊寄存器</strong>就是：</p><ul><li>SP（栈指针）</li><li>LR（函数调用返回地址）</li><li>PC（程序计数指针）</li><li>CPSR（程序状态，可以控制核心工作模式，中断开关等）</li><li>SPSR（备份程序状态，用于切换工作模式）<br><img src="/../images/30.4.png" alt="alt text"></li></ul><h4 id="2-核心寄存器的实际对应关系"><a href="#2-核心寄存器的实际对应关系" class="headerlink" title="2. 核心寄存器的实际对应关系"></a><strong>2. 核心寄存器的实际对应关系</strong></h4><p><img src="/../images/30.5.png" alt="alt text"></p><blockquote><p><strong>蓝绿色</strong>是该工作模式<strong>独占</strong>，<strong>浅色</strong>表示<strong>共用一个物理寄存器</strong>。</p></blockquote><p>为了节省资源，肯定不是每种工作模式，都配一组18个的物理寄存器。<strong>肯定有的是可以复用的</strong>。</p><p>可以看出：</p><ol><li><strong>低寄存器组 R0~R7</strong>是<strong>共享同一组物理</strong>寄存器的</li><li><strong>R8-R12</strong>， 除了FIQ有独立的寄存器外，其余的也都是共享一组物理寄存器</li><li><strong>SP，LR</strong>，除了sys和hyp模式外，都是独立拥有寄存器（<strong>每个模式有自己的栈指针和返回地址寄存器</strong></li><li><strong>PC</strong>，所有模式共用一个物理寄存器</li><li><strong>CPSR</strong>，所有模式共用一个物理寄存器</li><li><strong>SPSR</strong>，每个模式都有自己的寄存器，用来保存本模式的当前cpu状态。</li></ol><hr><p>下面详细说说这些寄存器，<strong>在某些模式下有什么用</strong>，为什么要独占，为什么共享？</p><ol><li><p><strong>R0-R7</strong>，大家都共用。无特殊用途，也叫做<strong>未备份寄存器</strong></p></li><li><p><strong>R8-R12</strong>，可以看到只有<code>FIQ模式</code>有自己的独占</p><blockquote><p><code>FIQ</code> 是<code>快速中断模式</code>，看名字就是知道这个中断模式<code>要求快速执行</code>,让这个模式有独占寄存器，就可以<strong>不用保存恢复现场了</strong>，非常迅速，从而<strong>加速中断的执行过程</strong></p></blockquote></li><li><p><strong>R13，SP</strong>，</p><ul><li>基本上每种模式都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的<strong>初始化 SP 指针</strong></li></ul></li><li><p><strong>R14</strong> 也称为<code>连接寄存器(LR)</code>,<strong>作用有两个</strong></p><ol><li>每种处理器模式使用 <code>R14(LR)</code>来存放当前<code>子程序的返回地址</code>，如果使用 <code>BL</code> 或者 <code>BLX</code>来调用子函数的话，<code>R14(LR)</code>被设置成该子函数的<code>返回地址</code>，在子函数中，将 <code>R14(LR)</code>中的值赋给 <code>R15(PC)</code>即可完成子函数返回</li><li>当<strong>异常发生</strong>以后，该异常模式对应的 <code>R14寄存器</code>被设置成<strong>该异常模式将要返回的地址</strong>，</li><li>R14 也可以当作<strong>普通寄存器</strong>使用</li></ol></li><li><p><strong>R15</strong>, PC, 大家共用</p><ul><li>保存着<strong>当前执行的指令地址</strong>值加 <code>8 个字节</code>(<strong>一句指令占4字节</strong> &#x3D; <strong>地址大小</strong>)，这是因为 ARM的流水线机制导致的<blockquote><p><code>R15 (PC)</code>值 &#x3D; 当前执行的程序位置 + <code>8 个字节</code></p></blockquote></li></ul></li><li><p><strong>CPSR</strong>, 大家共用，<strong>任何模式下被访问</strong></p><ol><li>包含了<code>条件标志位</code>、<code>中断禁止位</code>、当前<code>处理器模式</code>标志等一些<strong>状态位</strong>以及一些<strong>控制位</strong></li></ol></li><li><p><strong>SPSR</strong></p><ul><li>7 个模式每个都配备了一个<strong>专用的物理状态寄存器</strong>，叫做 <code>SPSR</code>(备份程序状态寄存器)，当特定的<strong>异常</strong> <strong>中断</strong>发生时，SPSR 寄存器用来<strong>保存当前程序状态寄存器CPSR</strong>的值，当异常退出以后可以用 SPSR 中保存的值来<strong>恢复 CPSR</strong></li><li><code>User</code> 和 <code>Sys</code> 这两个模式<code>不是异常模式</code>，所以<code>并没有配备 SPSR</code></li></ul></li></ol><p><img src="/../images/30.6.png" alt="alt text"></p><p>上图，是CPSR的寄存器的内部结构。下面列出比较重要的位</p><blockquote><ul><li><strong>N</strong>(bit31) N&#x3D;1 表示运算对的结果为<strong>负数</strong></li><li><strong>Z</strong>(bit30) Z&#x3D;1 表示运算<strong>结果为零</strong>, 对于 <code>CMP</code> 指令，Z&#x3D;1 表示进行比较的两个数大小相等</li><li><strong>J</strong>(bit24) 和 <strong>T</strong>(bit5)位一起 表示<strong>当前所使用的指令集</strong></li><li><strong>E</strong>(bit9)：<strong>大小端控制位</strong>，E&#x3D;1 表示大端模式，E&#x3D;0 表示小端模式</li><li><strong>A</strong>(bit8)：禁止异步中断位，A&#x3D;1 表示禁止异步中断</li><li><strong>I</strong>(bit7)：I&#x3D;1 禁止 IRQ，I&#x3D;0 <strong>使能 IRQ</strong>。</li><li><strong>F</strong>(bit6)：F&#x3D;1 禁止 FIQ，F&#x3D;0 <strong>使能 FIQ</strong></li><li><strong>M</strong>[4:0]：<strong>处理器模式控制位</strong></li></ul></blockquote><p>可以看到，通过修改CPSR，就可以设置当前<strong>核心的工作模式</strong>，<strong>中断使能</strong></p><blockquote><p>以上，就讲解了，<strong>多核架构</strong>，<strong>单核模型</strong>，<strong>寄存器组</strong>。我们<strong>所有的底层</strong>都是围绕这些寄存器来进行的。包括后面的自己手写OS。这里，<strong>就是嵌入式所到达的最底层</strong>，再往下，就是芯片设计了。</p></blockquote><h2 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h2><p>下面，我们需要掌握汇编语言，因为<strong>汇编</strong>，是<strong>最贴近核心+寄存器底层的语言</strong></p><p>我们只了解一些常用的指令即可</p><p><code>I.MX6U-ALPHA</code> 使用的是 NXP 的 <code>I.MX6UL 芯片</code>，这是一款 <code>Cortex-A7</code> 内核的芯片，所以<br>我们主要讲的是 <code>Cortex-A 的汇编指令</code></p><h3 id="GNU-汇编语法"><a href="#GNU-汇编语法" class="headerlink" title="GNU 汇编语法"></a>GNU 汇编语法</h3><p>当你使用stm32的MDK和IAR里面的汇编，发现里面的语法不一样。</p><p>我们要编写的是 <code>ARM汇编</code>，编译使用的 <code>GCC 交叉编译器</code>，所以我们的<strong>汇编代码</strong>要符合 <strong>GNU 语法</strong></p><blockquote><p><strong>GNU 汇编语法</strong>适用于<strong>所有的架构</strong>，并不是 ARM 独享的</p></blockquote><h4 id="1-GNU-汇编的基础语法如下："><a href="#1-GNU-汇编的基础语法如下：" class="headerlink" title="1. GNU 汇编的基础语法如下："></a>1. GNU 汇编的<strong>基础语法</strong>如下：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">label：instruction @ comment</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">label 即标号，表示地址位置</span></span><br><span class="line"><span class="comment">    1. 指令的地址: 有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，</span></span><br><span class="line"><span class="comment">    2. 数据地址: 标号也可以用来表示数据地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instruction 即指令，也就是汇编指令或伪指令。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@符号，表示后面的是注释，就跟 C 语言里面的“/*”和“*/</span>”一样</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">MOVS R0, #<span class="number">0X12</span> @设置 R0=<span class="number">0X12</span></span><br></pre></td></tr></table></figure><hr><h4 id="2-用户可以使用-section-伪操作来定义一个段"><a href="#2-用户可以使用-section-伪操作来定义一个段" class="headerlink" title="2. 用户可以使用.section 伪操作来定义一个段"></a>2. 用户可以使用<code>.section</code> <strong>伪操作</strong>来<strong>定义一个段</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .testsection @定义一个 testsetcion 段</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每个段以段名开始，以下一段名或者文件结尾结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .test</span><br><span class="line"></span><br><span class="line">.test:</span><br><span class="line">    ldr r0, =<span class="number">0x12</span> @r0=<span class="number">0x12</span></span><br><span class="line">    ldr r0, =<span class="number">0x12</span> @r0=<span class="number">0x12</span>  <span class="comment">//这里的两句指令就是一个段</span></span><br><span class="line">.xxx:</span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure><hr><h4 id="3-汇编系统预定义了一些段名"><a href="#3-汇编系统预定义了一些段名" class="headerlink" title="3. 汇编系统预定义了一些段名"></a>3. 汇编系统<strong>预定义了一些段名</strong></h4><ul><li>.text 表示代码段</li><li>.rodata 只读数据段</li><li>.data 初始化的数据段</li><li>.bss 未初始化的数据段</li></ul><hr><h4 id="4-汇编程序的默认入口标号是-start"><a href="#4-汇编程序的默认入口标号是-start" class="headerlink" title="4. 汇编程序的默认入口标号是_start"></a>4. 汇编程序的<strong>默认入口标号</strong>是<code>_start</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start </span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ldr r0, =<span class="number">0x12</span> @r0=<span class="number">0x12</span></span><br></pre></td></tr></table></figure><blockquote><p>我们也可以不用在代码里面用_start来指定程序的入口，也可以在<strong>链接脚本</strong><code>lds</code>中使用 <code>ENTRY</code> 来指明其它的入口点</p></blockquote><hr><h4 id="5-伪操作"><a href="#5-伪操作" class="headerlink" title="5. 伪操作"></a>5. 伪操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.byte   <span class="comment">//定义单字节数据，比如.byte 0x12。</span></span><br><span class="line">.<span class="type">short</span>  <span class="comment">//定义双字节数据，比如.short 0x1234。</span></span><br><span class="line">.<span class="type">long</span>   <span class="comment">//定义一个 4 字节数据，比如.long 0x12345678。</span></span><br><span class="line">.equ    <span class="comment">//赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示 num=0x12。</span></span><br><span class="line">.align  <span class="comment">//数据字节对齐，比如：.align 4 表示 4 字节对齐。</span></span><br><span class="line">.end    <span class="comment">//表示源文件结束。</span></span><br><span class="line">.global <span class="comment">//定义一个全局符号，格式为：.global symbol，比如：.global _start。</span></span><br></pre></td></tr></table></figure><hr><h4 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">    函数体</span><br><span class="line">    返回语句</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">    ldr r0, =Undefined_Handler</span><br><span class="line">    bx r0                               <span class="comment">//“bx”指令是返回指令，函数返回语句不是必须的</span></span><br></pre></td></tr></table></figure><h3 id="Cortex-A7-常用汇编指令"><a href="#Cortex-A7-常用汇编指令" class="headerlink" title="Cortex-A7 常用汇编指令"></a>Cortex-A7 常用汇编指令</h3><p>这里的指令，就是上面GNU汇编语法里面的<code>instruction</code>部分了</p><h4 id="处理器内部-数据传输指令"><a href="#处理器内部-数据传输指令" class="headerlink" title="处理器内部 数据传输指令"></a>处理器内部 数据传输指令</h4><p>主要是：</p><ul><li>MOV（<code>&lt;-</code>）<ul><li>将数据从一个寄存器拷贝到另外一个寄存器 </li><li>将一个立即数传递到寄存器里面</li></ul></li><li>MRS（<code>&lt;-</code>）<ul><li>读<strong>特殊寄存器</strong>(如 CPSR 和 SPSR)</li></ul></li><li>MSR（<code>&lt;-</code>）<ul><li>写<strong>特殊寄存器</strong>(如 CPSR 和 SPSR)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV R0，R1              <span class="comment">//将寄存器 R1 中的数据传递给 R0，即 R0=R1</span></span><br><span class="line">MOV R0, #<span class="number">0X12</span>           <span class="comment">//将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</span></span><br><span class="line"></span><br><span class="line">MRS R0, CPSR            <span class="comment">//将特殊寄存器 CPSR 里面的数据传递给 R0，即 R0=CPSR</span></span><br><span class="line"></span><br><span class="line">MSR CPSR, R0            <span class="comment">//将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</span></span><br></pre></td></tr></table></figure><h4 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h4><p>ARM <strong>不能直接访问存储器，比如 RAM 中的数据</strong></p><blockquote><p>记住，核心能够直接访问的，只有自己的内核寄存器，访问RAM，要用存储器访问指令。常用的存储器访问指令有两种：</p></blockquote><ul><li>LDR（<code>&lt;-</code>）</li><li>STR（<code>-&gt;</code>）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDR Rd, [Rn , <span class="meta">#offset]              <span class="comment">//从存储器 Rn+offset 的位置读取数据存放到 Rd 中。</span></span></span><br><span class="line"></span><br><span class="line">    LDR R0, =<span class="number">0X0209C004</span>             <span class="comment">//将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span></span><br><span class="line">    LDR R1, [R0]                    <span class="comment">//读取地址 0X0209C004 中的数据到 R1 寄存器中</span></span><br><span class="line"></span><br><span class="line">STR Rd, [Rn, <span class="meta">#offset]               <span class="comment">//将 Rd 中的数据写入到存储器中的 Rn+offset 位置。</span></span></span><br><span class="line"></span><br><span class="line">    STR R1, [R0]                    <span class="comment">//将 R1 中的值写入到 R0 中所保存的地址中</span></span><br></pre></td></tr></table></figure><p>LDR 和 STR 都是按照<code>字</code>(<strong>4byte</strong>)进行读取和写入的，也就是操作的 <code>32 位数据</code></p><p>如果要按照<code>字节</code>(<strong>1byte</strong>)、<code>半字</code>(<strong>2byte</strong>)进行操作的话可以在指令“LDR”后面加上 <code>B</code> 或 <code>H</code></p><ul><li>按<strong>字节</strong>操作的指令就是 <code>LDRB</code> 和<code>STRB</code>，</li><li>按<strong>半字</strong>操作的指令就是 <code>LDRH</code> 和 <code>STRH</code></li></ul><h4 id="压栈和出栈指令"><a href="#压栈和出栈指令" class="headerlink" title="压栈和出栈指令"></a>压栈和出栈指令</h4><p>A函数跳转到B函数，需要保存当前处理器状态(就是保存 <code>R0~R15</code> 这些寄存器值)</p><blockquote><p>只涉及函数跳转，所以是16个寄存器，包括SP，LR，PC.</p><p>CPSR的保存发生在模式切换，且保存到SPSR内</p></blockquote><p>当 <code>B 函数执行完成</code>以后再用前面保存的寄存器值恢复<code>R0~R15</code> 即可。<strong>保存 R0~R15</strong> 寄存器的操作就叫做<strong>现场保护</strong>，<strong>恢复 R0~R15</strong> 寄存器的操作就叫做<br><strong>恢复现场</strong></p><p>在进行<strong>现场保护</strong>的时候需要进行<code>压栈</code>(入栈)操作，<strong>恢复现场</strong>就要进行<code>出栈</code>操作</p><blockquote><p>也就是说，这个现场，具体要<strong>保存在内存里面</strong>，这里的内存就是<strong>SP指针指向的栈空间</strong></p></blockquote><ul><li><strong>压栈</strong>的指令为 <code>PUSH</code>(<code>&lt;-</code>) (从右往左，依次入栈)</li><li><strong>出栈</strong>的指令为 <code>POP</code>(<code>-&gt;</code>) (从左往右，依次出栈)</li></ul><blockquote><p>他们利用<strong>当前的栈指针 SP</strong>来<strong>生成地址</strong></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PUSH &lt;reg <span class="built_in">list</span>&gt;         <span class="comment">//将寄存器列表存入栈中</span></span><br><span class="line"></span><br><span class="line">    PUSH &#123;R0~R3, R12&#125;   <span class="comment">//将 R0~R3 和 R12 压栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POP &lt;reg <span class="built_in">list</span>&gt;          <span class="comment">//从栈中恢复寄存器列表。</span></span><br><span class="line"></span><br><span class="line">    POP &#123;R0~R3,R12&#125;     <span class="comment">//在恢复 R0~R3,R12</span></span><br></pre></td></tr></table></figure><blockquote><p>栈空间的内存模型，一次压入一个寄存器，32位，4字节。</p><p><img src="/../images/30.7.png" alt="alt text"></p></blockquote><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>指令跳转：</p><ul><li>B（直接跳转，不返回）</li><li>BL（直接跳转，返回）</li><li>BX（间接跳转，不返回）</li><li>BLX（间接跳转，返回）<blockquote><p>L表示LR，表示记录下返回的地址</p><p>X表示寄存器，表示跳转地址记录在寄存器里面</p><p>这些跳转指令，<strong>后面接label</strong>，也就是地址&#x2F;指令的别名，比如<code>main</code>, <code>reset_handler</code></p></blockquote></li></ul><p>当然还有<strong>直接跳转</strong>：<strong>直接向 PC 寄存器里面写入数据</strong></p><h4 id="算术运算指令-逻辑运算指令"><a href="#算术运算指令-逻辑运算指令" class="headerlink" title="算术运算指令 + 逻辑运算指令"></a>算术运算指令 + 逻辑运算指令</h4><p>这些都是加减法的运算指令，比如</p><ul><li><p>ADD</p></li><li><p>SUB<br>等等，都是（<code>&lt;-</code>）</p></li><li><p>AND</p></li><li><p>ORR</p></li><li><p>BIC</p></li><li><p>ORN</p></li><li><p>EOR<br>都是（<code>&lt;-</code>）</p></li></ul><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>上面，分析了处理器单核的运行模型，了解了配套的18个寄存器，然后补了一下GNU汇编基础。</p><p>下面，来分析一下，imx6ull的启动方式，看看裸机代码是如何跑起来的。</p><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p>首先，了解一下，imx6ull这块开发板支持的启动方式：</p><ol><li>FUSE启动</li><li><strong>串行下载</strong><ol><li>通过otg1&#x2F;uart 烧录到外部ROM里面，一般最终量产用</li></ol></li><li><strong>内部boot模式</strong><ol><li>芯片上电执行内部bootROM代码，进行硬件初始化<ol><li><code>初始化时钟</code><ol><li>内核时钟ARM PLL 396Mhz</li><li>System PLL 528Mhz</li><li>USB PLL 480Mhz</li><li>AHB 132Mhz</li><li>IPG 66Mh</li></ol></li><li><code>打开MMU和cache</code>，加快执行速度（下载镜像，验证镜像，完成后关闭）</li><li><code>中断向量偏移</code>设置到bootROM的起始位置，启动用户代码后，重新设置中断向量偏移(用户代码开始的地方)</li></ol></li><li>bootROM从boot设备(emmc,sd卡)拷贝到RAM中(ddr)</li></ol><ul><li>通过拨码(<strong>硬件gpio选择</strong>)，可以<strong>选择具体的启动设备</strong>（emmc,sd,eeprom,nandflash）</li></ul></li></ol><h3 id="镜像制作，代码烧录"><a href="#镜像制作，代码烧录" class="headerlink" title="镜像制作，代码烧录"></a>镜像制作，代码烧录</h3><p>我们自己编写了一个裸机的代码(<code>start.S + main.c</code>)</p><p>然后我们肯定会通过交叉编译工具，来编译出我们自己的<code>bin</code>文件。</p><ol><li>xxx-gcc  .s&#x2F;.c -&gt; .o</li><li>xxx-ld  .o -&gt; .elf (包含了运行地址:0x8780 0000)</li><li>xxx-copy  .elf -&gt; bin (转换二进制格式)</li></ol><p>之后，会用imxdownload来为我们的逻辑，添加一些头</p><ol start="4"><li>imxdownload      .bin -&gt; .imx &#x3D; (IVT+BD+DCD+.bin)</li></ol><blockquote><p>学习 <code>STM32</code> 的时候我们可以直接将编译生成的<code>.bin</code> 文件烧写到 STM32 <code>内部 flash</code> 里面,</p><p> I.MX6U 不能直接烧写编译生成的.bin 文件</p></blockquote><p>新增的头包括：</p><ol><li><code>IVT</code>： Image vector table，IVT 里面包含了一系列的<strong>地址信息</strong>，这些地址信息在ROM 中按照固定的地址存放着</li><li><code>Boot data</code>，启动数据，包含了<code>镜像要拷贝到哪个地址</code>(运行地址)，拷贝的大小是多少等等</li><li><code>Device configuration data</code>，简称 DCD，设备配置信息，重点是 <code>DDR3 的初始化配置</code></li></ol><p>内部 <code>BootROM</code> 会将 <code>load.imx</code> <strong>拷贝到 DDR 中</strong>，<code>用户代码(.bin)</code>是要一定要从 <code>0X8780 0000</code> 这个地方开始的</p><blockquote><p>DDR的地址范围为 0x80000000-xxxxxxxx</p></blockquote><p>因为<strong>链接地址</strong>为 <code>0X87800000</code>，<code>load.imx</code> 在用户代码前面又有 <code>3KByte</code> 的 <code>IVT+Boot Data+DCD</code> 数据，下面会讲为什么是 3KByte，因此 load.imx 在 DDR 中的起始地址就是 <code>0X8780 0000-3072</code>&#x3D;<code>0X877F F400</code></p><blockquote><p>前面这<code>3K</code>字节的头（IVT这些），是给bootROM看的。(<strong>有3千个字节，还是很多的</strong>。)</p></blockquote><p>以上，我们已经知道了，镜像的内部结构，以及镜像在运行地址的分布情况。下面，具体分析一下这些头的作用</p><h4 id="IVT-部分"><a href="#IVT-部分" class="headerlink" title="IVT 部分"></a>IVT 部分</h4><p>IVT 包含了：</p><ul><li>镜像程序的入口点</li><li>指向 DCD 的指针</li><li>一些用作其它用途的指针。</li></ul><blockquote><p><code>bootROM</code> 要求 <code>IVT</code> 应该放到<strong>指定的位置</strong>，<strong>不同的启动设备位置不同</strong>，而 IVT 在整个 load.imx 的最前面，其实就<strong>相当于要求 load.imx 在烧写的时候应该烧写到存储设备的指定位置去</strong>。整个位置都是<strong>相对于存储设备的起始地址的偏移</strong></p><p><img src="/../images/30.8.png" alt="alt text"></p><p>(<strong>加载地址计算</strong>) 以 <code>SD/EMMC</code> 为例，IVT 偏移为 <code>1Kbyte</code>，IVT+Boot data+DCD 的总大小为 4KByte-<br>1KByte&#x3D;3KByte。假如 SD&#x2F;EMMC <code>每个扇区为 512 字节</code>，那么 load.imx 应该从第三个扇区开始<br>烧写，<strong>前两个扇区要留出来</strong>，这样，这个才算一个合格的imx镜像，<strong>bootrom才愿意去读取</strong></p></blockquote><p>下面来看一下，<strong>IVT内部的具体内容</strong>，因为这三个头，一共占3k字节。具体内容如下：</p><blockquote><p>这里要<strong>事先说明</strong>，我们在编译链接阶段里面，让bin有地址信息，但是<code>bootROM</code>,是无法解析bin文件的，所以对bootROM来说，bin就是一串要拷贝的数据。</p><p>你用 <code>arm-linux-gnueabihf-objcopy</code> 将 .elf 转换成 .bin 烧录到 SD 卡时，<code>ELF</code> 里的<code>符号表</code>、<code>链接地址（0x87800000）</code>等所有<code>元数据</code>都被彻底丢弃了。SD 卡里躺着的只是纯粹的<code>机器指令</code></p><p>既然 .bin 自己不带说明书，<strong>NXP 就设计了 IVT 这个强制规范</strong>。你必须在二进制最开头显式告诉<strong>硬件瞎子</strong>：“搬完代码后，PC 指针去 0x87800000 执行”。<br><strong>IVT</strong></p></blockquote><ol><li><p><strong>header</strong> (<code>BootROM 靠它来识别这块数据是不是合法的 IVT</code>)</p><ol><li>0xD1</li><li>IVT的长度</li><li>version</li></ol></li><li><p><strong>入口地址</strong>：</p><ol><li>程序入口<strong>绝对地址</strong>（<code>DDR地址</code>）。BootROM 把你的代码搬运完毕后，PC 指针跳转去执行的第一个指令地址（通常就是你 start.S 中 _start 的<strong>链接物理地址</strong>,<code>0x87800000</code>）<blockquote><p>entry (入口地址)：<code>0X8780 0000</code>，也就是代码镜像第一行指令链接的位置。</p></blockquote></li></ol></li><li><p><strong>dcd</strong>：</p><ol><li>设备配置数据（DCD）<strong>绝对地址</strong>（<code>DDR地址</code>），让 BootROM 在跳转执行你的代码前帮你初始化 DDR 等核心外设，这样你的程序一启动就能直接跑在 DDR 里<blockquote><p>dcd (DCD 地址)：<code>0X877F F42C</code></p></blockquote></li></ol></li><li><p><strong>boot data</strong>：Boot Data <strong>绝对地址</strong>（<code>DDR地址</code>）。包含镜像的整体搬运信息（要把整个固件搬运到内存的哪个源地址、目标地址，以及固件总长度）</p><blockquote><p>boot data (Bd 地址)：<code>0X877F F420</code></p></blockquote></li><li><p><strong>self：IVT 本身的绝对地址</strong>（<code>DDR地址</code>）。供 BootROM 内部做基址偏移计算用。</p></li></ol><blockquote><p>self (IVT 地址)：<code>0X877F F400</code>，表中明确标注这是“IVT 复制到 DDR 中以后的首地址”。</p></blockquote><hr><blockquote><p><strong>这些地址是怎么被 imxdownload 算出来的</strong>？</p><p>它是以你给定的<code>链接地址</code>（0x87800000）为基准，逆向推导出来的：</p><p><strong>确定 IVT 首地址(self)</strong>：已知镜像代码起始地址是 0X87800000，而前面预留给 IVT + Boot Data + DCD 的空间刚好是 <code>3KByte (0xC00)</code>，所以 IVT 的首地址 self 就是 0X87800000 - 0xC00 &#x3D; <code>0X877FF400</code>。</p><p><strong>确定 DCD 地址</strong>：已知 <code>IVT 的首地址</code>是 0X877FF400，而通过查表得知 DCD 数据相对首地址的偏移量是 0X2C，所以 dcd 的绝对地址就是 0X877FF400 + 0X2C &#x3D; 0X877FF42C。</p><p><strong>确定 Boot Data 搬运地址</strong>：因为 i.MX6ULL 从 SD 卡启动时，硬件要求镜像前面必须空出 1KByte (0x400) 的偏移量。所以整个 load.imx 最终在 DDR 里的总起始地址 start 是 0X877FF400 - 0x400 &#x3D; 0X877FF000。</p></blockquote><hr><blockquote><p>解开最大的悖论：<strong>DDR 还没初始化，BootROM 怎么去 DDR 读 DCD</strong>？</p><p>这正是 NXP 硬件设计的精妙之处，也是我之前表述偏颇的地方。实际的启动搬运过程分为两步：</p><p><strong>第一步（临时解析配置）</strong>：上电时，BootROM 确实无法访问 DDR。它会先把 SD 卡最前面这几 KB（包含 <code>IVT</code> 和<code> DCD</code>）读取到芯片<code>内部的 SRAM (OCRAM)</code> 中。BootROM 在内部 SRAM 里解析并执行这部分 DCD 数据，从而把外部 DDR 的时序、引脚等全部初始化完毕。</p><p><strong>第二步（整体搬运到目的地）</strong>：DDR 初始化成功可用后，BootROM 才会去读取 <code>Boot Data</code> 里的指令。此时，它按照 start &#x3D; 0X877FF000 和设定的长度 length &#x3D; 0X00200000 (2MByte)，将 SD 卡上的整个镜像（包括那个 1KB 空白、IVT、DCD 以及你的 LED 代码），完整地搬运到 DDR 的目标地址中。</p></blockquote><h4 id="Boot-Data-数据"><a href="#Boot-Data-数据" class="headerlink" title="Boot Data 数据"></a>Boot Data 数据</h4><p>这个里面就是所谓的，整个imx镜像文件，的源地址（外部ROM），目的地址（DDR），拷贝大小。</p><p>这个不用多说了。给bootROM看的，用来拷贝用。</p><h4 id="DCD-数据"><a href="#DCD-数据" class="headerlink" title="DCD 数据"></a>DCD 数据</h4><p>这个里面，也是给bootROM看的，用来初始化ddr。</p><p>复位以后，I.MX6U 片内的<strong>所有寄存器都会复位为默认值</strong>，但是这些默认值往往不是我们<br>想要的值，而且有些外设我们必须在使用之前初始化它。</p><p>为此 I.MX6U 提出了一个 <code>DCD(Device Config Data)</code>的概念</p><p><code>DCD</code> 其实就是 I.MX6U <code>寄存器地址</code>和<code>对应的配置</code>信息集合，Boot ROM 会使用这些寄存器地址和配置集合来<strong>初始化相应的寄存器</strong>，比如<code>开启某些外设的时钟</code>、<code>初始化 DDR </code>等等</p><blockquote><p>DCD 区域不能超过 1768Byte</p></blockquote><p>我们的imxdownload里面，对dcd的内容有：</p><ol><li>设置 CCGR0~CCGR6 这 7 个外设时钟使能寄存器，默认打开所有的外设时钟。</li><li>配置 DDR3 所用的所有 IO。</li><li>配置 MMDC 控制器，初始化 DDR3。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是我对豆包的描述</span></span><br><span class="line">我理解的imx6ull的启动：初始上电后，pc指针先指向内部rom，里面是bootrom程序，他会先把外部rom的ivt，bootdata，dcd，这三块拷贝到内部ram中，然后开始读取这个镜像头，从bd里面得知了，整个景象的源地址（外部rom），目的地址（ddr），拷贝大小，从ivt里面得知了ivt，dcd，bd，和用户程序最终在外部ram，ddr中的位置。从dcd里面得知初始化ddr的配置信息，</span><br><span class="line"></span><br><span class="line">接下来bootRom要开始做的事情是，按照dcd的内容，初始化ddr，然后按照bd的内容把我们整个imx的景象拷贝到ddr的位置（保证用户代码bin的开头处于<span class="number">0x87800000</span>），接下来就是pc指针跳转到<span class="number">87800000</span>开始执行我们的用户代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们的用户代码，里面会做设置核心的状态啊，初始化sp指针准备c环境，然后跳转c的世界，然后在c的世界里面，做一些时钟的初始化啊，外设的初始化之类的。是这样吗</span><br></pre></td></tr></table></figure><p><strong>你的理解总结</strong>（我先复述一遍，确保我没听错）</p><ul><li>i.MX6ULL 上电 → PC 指向芯片<code>内部 BootROM</code>（出厂固化，不可改）</li><li>BootROM 先从外部 Flash（SPI&#x2F;NAND&#x2F;SD 等） 读取：<ul><li>IVT</li><li>Boot Data</li><li>DCD<blockquote><p>把这头信息读到<code>内部 RAM</code></p></blockquote></li></ul></li><li>解析：<ul><li>IVT：告诉 BootROM 各种表、程序的地址</li><li>DCD：DDR 初始化参数</li><li>Boot Data：告诉从哪拷贝、拷到 DDR 哪里、拷多大</li></ul></li><li><code>BootROM</code> 做：<ul><li>用 <code>DCD</code> 初始化 DDR</li><li>按 <code>BootData</code> 把整个镜像搬到 DDR（你说的 0x87800000）</li></ul></li><li>然后 PC 跳 <code>0x87800000</code> 执行用户代码</li><li>用户代码里：<ul><li>设 CPU 状态</li><li>初始化 SP，准备 C 环境</li><li>跳 C 入口</li><li>C 里初始化时钟、外设…</li></ul></li></ul><p><strong>流程图</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">上电复位</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[PC = 芯片内部 BootROM 地址]  &lt;-- 出厂固化，不可改</span><br><span class="line">   |</span><br><span class="line">   |--- <span class="number">1.</span> 读取启动引脚 BOOT_CFG</span><br><span class="line">   |        决定从哪里读镜像：SD / NAND / SPI Nor / 等</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[从外部ROM(Flash/SD) 读取头部]</span><br><span class="line">   |</span><br><span class="line">   |--- 只读一小段：IVT + DCD + Boot Data</span><br><span class="line">   |--- 拷贝到 【芯片内部 RAM (OCRAM)】</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[解析头部]</span><br><span class="line">   |</span><br><span class="line">   |--- IVT:      入口地址、各类表的指针</span><br><span class="line">   |--- DCD:      DDR 初始化参数</span><br><span class="line">   |--- BootData: 源地址、目的地址、拷贝长度</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[执行 DCD，初始化 DDR]</span><br><span class="line">   |</span><br><span class="line">   |--- DDR 此时才被点亮！</span><br><span class="line">   |--- 之前只能用内部 RAM</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[根据 BootData 搬运整个镜像]</span><br><span class="line">   |</span><br><span class="line">   |--- 从外部ROM → 搬到 DDR 中</span><br><span class="line">   |--- 通常目的地址：<span class="number">0x87800000</span></span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[跳转到 IVT 中指定的入口地址]</span><br><span class="line">   |</span><br><span class="line">   |--- 通常就是 <span class="number">0x87800000</span></span><br><span class="line">   |--- 进入用户写的程序</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[用户启动代码（你的 start.S）]</span><br><span class="line">   |</span><br><span class="line">   |--- 关看门狗</span><br><span class="line">   |--- 设置 CPU 模式、栈指针 SP</span><br><span class="line">   |--- 初始化 .data / .bss</span><br><span class="line">   |--- 准备好 C 语言运行环境</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">[跳转到 C 入口：main / board_init]</span><br><span class="line">   |</span><br><span class="line">   |--- 时钟初始化</span><br><span class="line">   |--- 外设初始化</span><br><span class="line">   |--- 业务逻辑</span><br><span class="line">   |</span><br><span class="line">   v</span><br><span class="line">正常运行</span><br></pre></td></tr></table></figure><blockquote><p>注意，我们的链接地址<code>0x87800000</code>这个<strong>不是固定的</strong>，是我们的<strong>lds链接脚本</strong>决定的。然后imxdownload会根据这个来生成我们的IVT，指向lds里面设置的链接地址。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 你写 .lds 链接脚本</span><br><span class="line">   ↓（指定运行地址 = DDR 里的地址，比如 <span class="number">0x87800000</span>）</span><br><span class="line"></span><br><span class="line">   <span class="comment">//. = 0x87800000;   // 这样即可。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 编译出来的 elf → bin</span><br><span class="line">   ↓（bin 里第一条指令的地址就是 <span class="number">0x87800000</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 运行 imxdownload 烧录</span><br><span class="line">   ↓（工具会读取你的 bin 文件第一条指令地址）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> imxdownload **自动生成 IVT**</span><br><span class="line">   ↓（把 IVT 里的 entry 字段填成 <span class="number">0x87800000</span>）</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 烧录到 SD 卡</span><br><span class="line">   ↓</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 上电</span><br><span class="line">   BootROM 读 IVT → 知道要跳去 <span class="number">0x87800000</span></span><br></pre></td></tr></table></figure><h3 id="内存分布，对比stm32"><a href="#内存分布，对比stm32" class="headerlink" title="内存分布，对比stm32"></a>内存分布，对比stm32</h3><p>我们先复习一下stm32的启动前后，内存的分布情况。由于stm32f103只有内部ram, 内部rom</p><h4 id="stm32的启动"><a href="#stm32的启动" class="headerlink" title="stm32的启动"></a>stm32的启动</h4><p><strong>1. 基础地址（STM32F103ZE）</strong></p><ul><li><strong>内部 Flash (ROM)</strong>：<code>0x0800 0000</code> ~ <code>0x0807 FFFF</code>（512KB）</li><li><strong>内部 SRAM (RAM)</strong>：<code>0x2000 0000</code> ~ <code>0x2000 FFFF</code>（64KB）</li><li><strong>向量表</strong>：固定放在 <code>Flash</code> 起始</li><li><strong>start.s</strong>：做的核心事：初始化栈、拷贝.data、清零.bss</li></ul><p><strong>2. 上电瞬间，（刚复位，还没有执行start.s）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部rom flash</span></span><br><span class="line"><span class="number">0x08000000</span>  +-----------------------+</span><br><span class="line">            |   栈顶地址(MSP)       |  &lt;-- 复位硬件自动加载到SP</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   复位向量(Reset_Handler) |  &lt;-- 硬件自动PC跳这里</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   其他中断向量表       |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   startup_stm32f10x.s |  &lt;-- start.s 代码</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   .text 程序代码       |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   .rodata 常量        |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   .data 初始化数据(初值) |  &lt;-- 存在Flash里</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   (Flash剩余空间)      |</span><br><span class="line"><span class="number">0x0807FFFF</span>  +-----------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部ram</span></span><br><span class="line"><span class="number">0x2000FFFF</span>  +-----------------------+</span><br><span class="line">            |      (未定义垃圾值)    |</span><br><span class="line">            |                       |</span><br><span class="line">            |      全是随机数        |</span><br><span class="line">            |                       |</span><br><span class="line"><span class="number">0x20000000</span>  +-----------------------+</span><br></pre></td></tr></table></figure><p><strong>3. 执行 start.s 过程中（关键三步）</strong></p><ul><li>设置<strong>栈指针 SP</strong> &#x3D; 0x2000FFFF（或稍小）</li><li>从 Flash 拷贝 <code>.data</code> 到 <code>RAM</code></li><li><code>RAM</code> 中 <code>.bss</code> 段清零</li></ul><p><strong>4. start.s 执行完成后（进入 main 前）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内部rom flash</span></span><br><span class="line"><span class="number">0x08000000</span>  +-----------------------+</span><br><span class="line">            |   栈顶地址             |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   复位向量             |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   中断向量表           |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   start.s 代码         |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   .text / .rodata     |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |   .data 源数据(Flash)  |</span><br><span class="line">            +-----------------------+</span><br><span class="line"><span class="number">0x0807FFFF</span>  +-----------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部ram</span></span><br><span class="line"><span class="number">0x2000FFFF</span>  +-----------------------+</span><br><span class="line">            |       栈 (Stack)       | &lt;-- SP指向这里</span><br><span class="line">            |       (向下生长)       |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |                       |</span><br><span class="line">            |   动态内存/堆(可选)    |</span><br><span class="line">            |                       |</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |       .data 段        | &lt;-- 从Flash拷贝过来：有初值的全局/静态变量</span><br><span class="line">            +-----------------------+</span><br><span class="line">            |       .bss 段         | &lt;-- 已被start.s清零：全局/静态未初始化变量</span><br><span class="line">            +-----------------------+</span><br><span class="line"><span class="number">0x20000000</span>  +-----------------------+</span><br></pre></td></tr></table></figure><h5 id="疑问1-data-bss的拷贝时机"><a href="#疑问1-data-bss的拷贝时机" class="headerlink" title="疑问1: .data,.bss的拷贝时机"></a>疑问1: .data,.bss的拷贝时机</h5><p>我已经知道了，上电开始执行，CM3读取<code>0x0800 0000</code>的4字节地址，作为<code>SP</code>指针，然后，读取<code>0x0800 0004</code>的4字节地址，作为<code>PC</code>指针。</p><p>我知道这个是硬件自动执行的。我很好奇，这个RAM里面的<code>.data</code>, <code>.bss</code>这个是什么时候干的？是硬件自动执行的吗？我知道在写程序的时候，MDK里面会有ld链接脚本，规划好了栈空间在RAM的末尾，然后.data， .bss在RAM的低地址。但是，我很好奇，这个是什么时机开始弄得？</p><blockquote><p>就是说，栈空间，我们在链接脚本lds里面，已经规划好了，放到RAM的最后，SP指针，硬件自动设置了。但是<strong>开头的.data, .bss是在什么时候拷贝过来的</strong>？</p></blockquote><p>首先说明，.data, .bss不是硬件自动执行的。因为<strong>这也是c语言的执行环境的一部分</strong>，所以需要软件设置，</p><p>所以在<strong>start.s中设置</strong>。</p><p>他的具体操作为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset_Handler:</span><br><span class="line">    <span class="comment">/* 1. 从Flash拷贝 .data 到 RAM */</span></span><br><span class="line">    ldr r0, =_sidata   @ Flash中.data的源地址（链接脚本定义）</span><br><span class="line">    ldr r1, =_sdata    @ RAM中.data的目标起始</span><br><span class="line">    ldr r2, =_edata    @ RAM中.data的目标结束</span><br><span class="line">copy_data:</span><br><span class="line">    ldr r3, [r0], #<span class="number">4</span></span><br><span class="line">    str r3, [r1], #<span class="number">4</span></span><br><span class="line">    cmp r1, r2</span><br><span class="line">    bne copy_data</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 清零 .bss 段 */</span></span><br><span class="line">    ldr r0, =_sbss     @ RAM中.bss的起始</span><br><span class="line">    ldr r1, =_ebss     @ RAM中.bss的结束</span><br><span class="line">    mov r2, #<span class="number">0</span>         @ 要写入的<span class="number">0</span></span><br><span class="line">clear_bss:</span><br><span class="line">    str r2, [r0], #<span class="number">4</span></span><br><span class="line">    cmp r0, r1</span><br><span class="line">    bne clear_bss</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 跳转到C语言入口main */</span></span><br><span class="line">    b main</span><br></pre></td></tr></table></figure><p>你看，这就是你 “没看见” 的那部分代码：</p><ul><li>.data：是从 Flash 里的 “备份” 拷贝到 RAM 里的</li><li>.bss：是在 RAM 里把一段空间全部写 0</li></ul><p><strong>链接脚本（.ld&#x2F;MDK 里的设置）又起什么作用?</strong></p><p>链接脚本的作用是 <strong>“规划”</strong>，而不是 “执行”：</p><ul><li>它告诉编译器：<ul><li><code>.text</code>（代码）放在 Flash 哪里</li><li><code>.data</code>（有初值的全局变量）在 Flash 里的备份位置，以及在 RAM 里的运行位置</li><li><code>.bss</code>（无初值的全局变量）在 RAM 里的位置</li><li><code>栈顶</code>（_estack）放在 RAM 的末尾</li></ul></li><li>它会生成一些符号，比如 <code>_sidata</code>, <code>_sdata</code>,<code> _edata</code>, <code>_sbss</code>, <code>_ebss</code>, <code>_estack</code>，这些符号就是上面 start.S 里用到的地址。</li></ul><p><strong>所以整个流程是</strong>：</p><ol><li><code>链接脚本</code>：画好地图（内存布局）</li><li><code>硬件</code>：只负责把 PC 和 SP 指向地图的入口</li><li><code>start.S</code>：拿着地图，一步一步把东西搬到正确的地方</li></ol><p><strong>那为什么stm32的start.s中没有看到实际拷贝.data, .bss的部分</strong>？</p><p>下面是stm32的demo的start.s中的PC执行的部分，没有拷贝的指令，但是实际上是拷贝了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset_Handler   PROC</span><br><span class="line">    EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">    IMPORT  __main          ; 重点：导入了__main（不是你写的main！）</span><br><span class="line">    IMPORT  SystemInit</span><br><span class="line">    LDR     R0, =SystemInit</span><br><span class="line">    BLX     R0               ; 第一步：初始化系统时钟</span><br><span class="line">    LDR     R0, =__main      ; 第二步：跳转到__main</span><br><span class="line">    BX      R0</span><br><span class="line">    ENDP</span><br></pre></td></tr></table></figure><p><strong>原因</strong>：</p><p><code>__main</code> 是 ARM 编译器（ARMCC）提供的<code>C 库启动函数</code>，它藏在编译器的<code>运行时库（RTL）</code>里，你看不到源码</p><p><strong>实际流程</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset_Handler → SystemInit → __main → 你的main()</span><br><span class="line">                 ↑            ↑</span><br><span class="line">                 时钟初始化    核心操作：</span><br><span class="line">                             <span class="number">1.</span> 拷贝.data段（Flash→RAM）</span><br><span class="line">                             <span class="number">2.</span> 清零.bss段（RAM写<span class="number">0</span>）</span><br><span class="line">                             <span class="number">3.</span> 初始化堆（Heap）</span><br><span class="line">                             <span class="number">4.</span> 最终跳转到你的main()</span><br></pre></td></tr></table></figure><blockquote><p>简单说：MDK 把 “拷贝.data&#x2F; 清零.bss” 这些脏活，都<strong>封装到了 __main 里</strong>，所以你在 start.s 里看不到，但它确实执行了。</p></blockquote><h2 id="汇编led点灯-裸机代码分析"><a href="#汇编led点灯-裸机代码分析" class="headerlink" title="汇编led点灯 裸机代码分析"></a>汇编led点灯 裸机代码分析</h2><p>下面分析一下，汇编版本的led点灯代码</p><p>Makefile</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">led.bin:led.s</span><br><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext <span class="number">0X87800000</span> led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o led.bin led.elf led.dis</span><br></pre></td></tr></table></figure><p>led.s</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">Copyright © zuozhongkai Co., Ltd. 1998-2019. All rights reserved.</span></span><br><span class="line"><span class="comment">文件名:  mian.c</span></span><br><span class="line"><span class="comment">作者   : 左忠凯</span></span><br><span class="line"><span class="comment">版本   : V1.0</span></span><br><span class="line"><span class="comment">描述   : 裸机实验1 汇编点灯</span></span><br><span class="line"><span class="comment"> 使用汇编来点亮开发板上的LED灯，学习和掌握如何用汇编语言来</span></span><br><span class="line"><span class="comment"> 完成对I.MX6U处理器的GPIO初始化和控制。</span></span><br><span class="line"><span class="comment">其他   : 无</span></span><br><span class="line"><span class="comment">论坛    : www.wtmembed.com</span></span><br><span class="line"><span class="comment">日志   : 初版V1.0 2019/1/3 左忠凯创建</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line">.global _start  <span class="comment">/* 全局标号 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 描述：_start函数，程序从此函数开始执行此函数完成时钟使能、</span></span><br><span class="line"><span class="comment"> *  GPIO初始化、最终控制GPIO输出低电平来点亮LED灯。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_start:</span><br><span class="line"><span class="comment">/* 例程代码 */</span></span><br><span class="line"><span class="comment">/* 1、使能所有时钟 */</span></span><br><span class="line">ldr r0, =<span class="number">0X020C4068</span> <span class="comment">/* CCGR0 */</span></span><br><span class="line">ldr r1, =<span class="number">0XFFFFFFFF</span>  </span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C406C</span>  <span class="comment">/* CCGR1 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C4070</span>  <span class="comment">/* CCGR2 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C4074</span>  <span class="comment">/* CCGR3 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C4078</span>  <span class="comment">/* CCGR4 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C407C</span>  <span class="comment">/* CCGR5 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =<span class="number">0X020C4080</span>  <span class="comment">/* CCGR6 */</span></span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、设置GPIO1_IO03复用为GPIO1_IO03 */</span></span><br><span class="line">ldr r0, =<span class="number">0X020E0068</span><span class="comment">/* 将寄存器SW_MUX_GPIO1_IO03_BASE加载到r0中 */</span></span><br><span class="line">ldr r1, =<span class="number">0X5</span><span class="comment">/* 设置寄存器SW_MUX_GPIO1_IO03_BASE的MUX_MODE为5 */</span></span><br><span class="line">str r1,[r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、配置GPIO1_IO03的IO属性</span></span><br><span class="line"><span class="comment"> *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment"> *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ldr r0, =<span class="number">0X020E02F4</span><span class="comment">/*寄存器SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">    ldr r1, =<span class="number">0X10B0</span></span><br><span class="line">    str r1,[r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、设置GPIO1_IO03为输出 */</span></span><br><span class="line">    ldr r0, =<span class="number">0X0209C004</span><span class="comment">/*寄存器GPIO1_GDIR */</span></span><br><span class="line">    ldr r1, =<span class="number">0X0000008</span></span><br><span class="line">    str r1,[r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、打开LED0</span></span><br><span class="line"><span class="comment"> * 设置GPIO1_IO03输出低电平</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ldr r0, =<span class="number">0X0209C000</span><span class="comment">/*寄存器GPIO1_DR */</span></span><br><span class="line">   ldr r1, =<span class="number">0</span></span><br><span class="line">   str r1,[r0]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 描述：loop死循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">loop:</span><br><span class="line">b loop </span><br></pre></td></tr></table></figure><p>这个就是非常简单的一个汇编代码，所以也不需要c语言的环境</p><p>实际内存分变化：</p><p><strong>1. 上电前（仅外部 ROM 有数据，DDR 空）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────┐  外部ROM (SD卡)</span><br><span class="line">│ <span class="number">0x00000000</span> ~ <span class="number">0x0000</span>xxxx         │  ← imxdownload烧录的内容：</span><br><span class="line">│  ┌─────────────┐                │     IVT + DCD + BootData + 你的汇编指令</span><br><span class="line">│  │ IVT         │                │     （IVT里entry=<span class="number">0X87800000</span>）</span><br><span class="line">│  │ DCD         │                │</span><br><span class="line">│  │ BootData    │                │</span><br><span class="line">│  │ 汇编指令    │                │</span><br><span class="line">│  └─────────────┘                │</span><br><span class="line">│  剩余空间：空                   │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────┐  DDR (<span class="number">0X80000000</span> ~ <span class="number">0X9FFFFFFF</span>)</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx         │  ← 全是随机垃圾值（未初始化）</span><br><span class="line">│  全未使用，无有效数据           │</span><br><span class="line">│  剩余空间：空                   │</span><br><span class="line">└─────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>2. 上电后（BootROM 完成搬运，DDR 有指令）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────┐  外部ROM (SD卡)</span><br><span class="line">│ <span class="number">0x00000000</span> ~ <span class="number">0x0000</span>xxxx         │  ← 内容不变（只读）</span><br><span class="line">│  ┌─────────────┐                │</span><br><span class="line">│  │ IVT         │                │</span><br><span class="line">│  │ DCD         │                │</span><br><span class="line">│  │ BootData    │                │</span><br><span class="line">│  │ 汇编指令    │                │</span><br><span class="line">│  └─────────────┘                │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────┐  DDR (核心变化！)</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx         │  ← BootROM搬运过来的汇编指令</span><br><span class="line">│  ┌─────────────────────────┐    │</span><br><span class="line">│  │ _start:                 │    │  ← 第一条指令地址（<span class="number">0X87800000</span>）</span><br><span class="line">│  │   ldr r0, =<span class="number">0X020C4068</span>   │    │</span><br><span class="line">│  │   ldr r1, =<span class="number">0XFFFFFFFF</span>   │    │</span><br><span class="line">│  │   ...（时钟/IO配置指令）│    │</span><br><span class="line">│  │ loop:                   │    │</span><br><span class="line">│  │   b loop                │    │</span><br><span class="line">│  └─────────────────────────┘    │</span><br><span class="line">│  剩余空间：空                   │</span><br><span class="line">└─────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>3. 最终执行阶段（PC 跳转到 DDR 执行）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────┐  DDR</span><br><span class="line">│ <span class="number">0X87800000</span>                      │  ← PC指针指向这里，开始执行指令</span><br><span class="line">│  ┌─────────────────────────┐    │</span><br><span class="line">│  │ 执行：使能所有时钟       │    │</span><br><span class="line">│  │ 执行：配置GPIO1_IO03复用 │    │</span><br><span class="line">│  │ 执行：配置IO属性         │    │</span><br><span class="line">│  │ 执行：设置GPIO为输出     │    │</span><br><span class="line">│  │ 执行：GPIO输出低电平（点灯）│</span><br><span class="line">│  │ 执行：b loop（死循环）   │    │</span><br><span class="line">│  └─────────────────────────┘    │</span><br><span class="line">└─────────────────────────────────┘</span><br></pre></td></tr></table></figure><blockquote><p><strong>代码特性</strong>：<strong>这段汇编只有指令（.text 段）</strong>，没有定义任何全局变量、静态变量，自然不需要.data（存初始化值）和.bss（存未初始化值）；</p><p><strong>启动简化</strong>：因为没有.data&#x2F;.bss，你的汇编代码里也不需要像 STM32 那样做 “拷贝 &#x2F; 清零” 操作，_start 直接开始配置硬件 —— 这是裸机汇编最简洁的优势</p></blockquote><h2 id="c语言led点灯-裸机代码分析"><a href="#c语言led点灯-裸机代码分析" class="headerlink" title="c语言led点灯 裸机代码分析"></a>c语言led点灯 裸机代码分析</h2><p>下面看看c语言版本的逻辑代码</p><p><strong>Makefile</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">objs := start.o main.o</span><br><span class="line"></span><br><span class="line">ledc.bin:$(objs)</span><br><span class="line">arm-linux-gnueabihf-ld -Timx6ul.lds -o ledc.elf $^</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S ledc.elf $@</span><br><span class="line">arm-linux-gnueabihf-objdump -D -m arm ledc.elf &gt; ledc.dis</span><br><span class="line"></span><br><span class="line">%.o:%.s</span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">%.o:%.S</span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">arm-linux-gnueabihf-gcc -Wall -nostdlib -c -O2 -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -rf *.o ledc.bin ledc.elf ledc.dis</span><br></pre></td></tr></table></figure><p><strong>lds链接脚本</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">. = <span class="number">0X87800000</span>;</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">start.o </span><br><span class="line">main.o </span><br><span class="line">*(.text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : &#123;*(.rodata*)&#125;     </span><br><span class="line">.data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123; *(.data) &#125;    </span><br><span class="line">__bss_start = .;    </span><br><span class="line">.bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : &#123; *(.bss)  *(COMMON) &#125;    </span><br><span class="line">__bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，lds指定了ddr里面的内存分布情况</p></blockquote><p><strong>start.s</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start  <span class="comment">/* 全局标号 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 描述：_start函数，程序从此函数开始执行，此函数主要功能是设置C</span></span><br><span class="line"><span class="comment"> * 运行环境。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">bic r0, r0, #<span class="number">0x1f</span> <span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 */</span></span><br><span class="line">orr r0, r0, #<span class="number">0x13</span> <span class="comment">/* r0或上0x13,表示使用SVC模式*/</span></span><br><span class="line">msr cpsr, r0<span class="comment">/* 将r0 的数据写入到cpsr_c中 */</span></span><br><span class="line"></span><br><span class="line">ldr sp, =<span class="number">0X80200000</span><span class="comment">/* 设置栈指针 */</span></span><br><span class="line">b main<span class="comment">/* 跳转到main函数  */</span></span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">clk_enable();<span class="comment">/* 使能所有的时钟 */</span></span><br><span class="line">led_init();<span class="comment">/* 初始化led */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/* 死循环 */</span></span><br><span class="line">&#123;</span><br><span class="line">led_off();<span class="comment">/* 关闭LED   */</span></span><br><span class="line">delay(<span class="number">500</span>);<span class="comment">/* 延时大约500ms */</span></span><br><span class="line"></span><br><span class="line">led_on();<span class="comment">/* 打开LED */</span></span><br><span class="line">delay(<span class="number">500</span>);<span class="comment">/* 延时大约500ms */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，我们的imx6ull，是会把镜像文件全部加载到DDR里面来运行的，所以没有拷贝.data这些。但是<strong>真实原因</strong>是：</p></blockquote><p><strong>先回顾 STM32 要拷贝的根本原因</strong></p><p>STM32 的.data段有两个地址：</p><ul><li>加载地址（LMA）：Flash 里（0x0800xxxx）—— 存初始值</li><li>运行地址（VMA）：RAM 里（0x2000xxxx）—— 程序运行时要访问的地址<blockquote><p>所以<strong>必须把 Flash 里的初始值拷贝到 RAM</strong>，程序才能读到正确的全局变量值。</p></blockquote></li></ul><p><strong>再看 i.MX6ULL 的关键差异</strong></p><p>你这份代码里，.data&#x2F;.bss的<code>加载地址</code> &#x3D; <code>运行地址</code>（都是 DDR 的 0x8780xxxx）：</p><ul><li><strong>BootROM 做的事</strong>：把外部 ROM 里的 “整个镜像（包括.text&#x2F;.rodata&#x2F;.data）”原样搬到 DDR 的 0x87800000 开始的地址；</li><li>搬运完成后，.data 段已经在 “运行地址” 上了，且初始值也一起搬过来了 ——不需要二次拷贝；</li><li>而<code>.bss</code> 段因为<strong>没有初始值</strong>，BootROM 搬运时不会处理（<strong>DDR 里还是随机值</strong>），你这份代码<strong>刚好没用到全局变量</strong>，所以没出问题。<blockquote><p>所以这个c语言的裸机点灯代码，有隐患</p></blockquote></li></ul><blockquote><p>所以，<strong>需不需要拷贝的原因</strong>，是看<code>加载地址≠运行地址？</code></p><ul><li>是 → 必须拷贝</li><li>否 → 无需拷贝</li></ul></blockquote><hr><p><strong>你这份代码没出问题，是因为main.c 里没有定义全局变量 &#x2F; 静态变量</strong>：</p><ul><li>如果定义<code>int g_led_flag = 1</code>;（<code>.data 段</code>）：BootROM 会把初始值 1 一起搬到 DDR，main 里能读到正确值；</li><li>如果定义<code>int g_delay_cnt</code>;（<code>.bss 段</code>）：DDR 里这个地址是随机值，main 里用<strong>这个变量会导致延时 &#x2F; 点灯异常</strong>；</li></ul><p><strong>正确的做法是</strong>：</p><ul><li>在start.s的b main前，<strong>加一段清零.bss 的代码</strong>（因为.bss 段没有初始值，BootROM 不会处理）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">  <span class="comment">/* 1. 切换SVC模式 */</span></span><br><span class="line">  mrs r0, cpsr</span><br><span class="line">  bic r0, r0, #<span class="number">0x1f</span></span><br><span class="line">  orr r0, r0, #<span class="number">0x13</span></span><br><span class="line">  msr cpsr, r0</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 2. 设置栈指针 */</span></span><br><span class="line">  ldr sp, =<span class="number">0X80200000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 3. 清零.bss段（新增！） */</span></span><br><span class="line">  ldr r0, =__bss_start    <span class="comment">/* 链接脚本定义的bss起始 */</span></span><br><span class="line">  ldr r1, =__bss_end      <span class="comment">/* 链接脚本定义的bss结束 */</span></span><br><span class="line">  mov r2, #<span class="number">0</span></span><br><span class="line">bss_clear:</span><br><span class="line">  str r2, [r0], #<span class="number">4</span></span><br><span class="line">  cmp r0, r1</span><br><span class="line">  bne bss_clear</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 4. 跳main */</span></span><br><span class="line">  b main</span><br></pre></td></tr></table></figure><blockquote><p><strong>和 STM32 的本质区别</strong>：</p><ul><li>STM32 是 “Flash 存初始值，RAM 跑程序”（需要软件拷贝），</li><li>i.MX6ULL 是 “外部 ROM 存初始值，DDR 跑程序”（BootROM 一次性搬过去，无需二次拷贝）</li><li>但是记住，bss段都需要清零，否则容易有异常风险</li></ul></blockquote><hr><p>下面展示内存的分布变化</p><p><strong>1. 上电前（仅外部 ROM 有数据，DDR 全空）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────┐ 外部ROM (SD卡)</span><br><span class="line">│ <span class="number">0x00000000</span> ~ <span class="number">0x0000</span>xxxx                │ ← imxdownload烧录的完整镜像</span><br><span class="line">│  ┌─────────────┬─────────────────────┐  │</span><br><span class="line">│  │ IVT+DCD+BD  │  用户镜像           │  │</span><br><span class="line">│  │ (头信息)    │  ┌─────────────┐    │  │</span><br><span class="line">│  │             │  │ .text       │    │  │ ← start.s+main.c的指令</span><br><span class="line">│  │             │  │ .rodata     │    │  │ ← 常量（如字符串，本例无）</span><br><span class="line">│  │             │  │ .data       │    │  │ ← 有初值全局变量（本例无）</span><br><span class="line">│  │             │  └─────────────┘    │  │</span><br><span class="line">│  └─────────────┴─────────────────────┘  │</span><br><span class="line">│  剩余空间：空                           │</span><br><span class="line">└─────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────┐ DDR (<span class="number">0X80000000</span> ~ <span class="number">0X9FFFFFFF</span>)</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx                │ ← 全是随机垃圾值（未初始化）</span><br><span class="line">│  <span class="number">0X80200000</span> (栈地址)：随机值            │</span><br><span class="line">│  剩余空间：空                           │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>2. 上电后 → BootROM 完成搬运（未执行 start.s）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────┐ 外部ROM (SD卡)</span><br><span class="line">│ 内容不变（只读）                        │ ← 头信息+用户镜像仍在</span><br><span class="line">└─────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────┐ DDR (核心变化：搬运完成)</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx                │ ← BootROM原样搬运外部ROM的用户镜像</span><br><span class="line">│  ┌─────────────┬─────────────────────┐  │</span><br><span class="line">│  │ .text       │ 指令（start.s+main.c）│  │ ← 可直接执行</span><br><span class="line">│  │ .rodata     │ 常量（本例无）       │  │</span><br><span class="line">│  │ .data       │ 有初值全局变量（本例无）│</span><br><span class="line">│  │ .bss        │ 随机垃圾值           │  │ ← BootROM不处理，仍为DDR原始值</span><br><span class="line">│  └─────────────┴─────────────────────┘  │</span><br><span class="line">│  <span class="number">0X80200000</span> (栈地址)：随机值            │</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>3. 执行 start.s（清零.bss + 设置栈）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────┐ DDR</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx                │</span><br><span class="line">│  ┌─────────────┬─────────────────────┐  │</span><br><span class="line">│  │ .text       │ 指令（无变化）       │  │</span><br><span class="line">│  │ .rodata     │ 常量（无变化）       │  │</span><br><span class="line">│  │ .data       │ 有初值全局变量（无变化）│</span><br><span class="line">│  │ .bss        │ 全<span class="number">0</span>（已清零）        │  │ ← start.s的bss_clear循环执行完成</span><br><span class="line">│  └─────────────┴─────────────────────┘  │</span><br><span class="line">│  <span class="number">0X80200000</span> (栈地址)：SP指向这里       │ ← 栈指针已设置，C环境就绪</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>4. 跳转到 main 执行（点灯循环）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────────┐ DDR</span><br><span class="line">│ <span class="number">0X87800000</span> ~ <span class="number">0X8780</span>xxxx                │</span><br><span class="line">│  ┌─────────────┬─────────────────────┐  │</span><br><span class="line">│  │ .text       │ 执行中：            │  │</span><br><span class="line">│  │             │  - clk_enable()      │  │</span><br><span class="line">│  │             │  - led_init()        │  │</span><br><span class="line">│  │             │  - <span class="keyword">while</span>(<span class="number">1</span>)点灯循环  │  │</span><br><span class="line">│  │ .rodata     │ 无                   │  │</span><br><span class="line">│  │ .data       │ 无                   │  │</span><br><span class="line">│  │ .bss        │ 全<span class="number">0</span>（无使用）        │  │</span><br><span class="line">│  └─────────────┴─────────────────────┘  │</span><br><span class="line">│  <span class="number">0X80200000</span> (栈地址)：栈空间使用中      │ ← main里的局部变量（如delay计数）存在这里</span><br><span class="line">└─────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><hr><p><strong>这里有一个疑问</strong>，</p><ul><li><p>为什么stm32中，start.s中，有分配<strong>栈</strong>的大小，且栈被lds分配到<strong>ram的最后部分</strong>，然后<code>.data</code>, <code>.bss</code>在<strong>ram的前部</strong>。</p></li><li><p>而在imx6ull这里，因为DDR的地址范围<code>0x80000000 - xxxxxxxx</code>. 但是<strong>栈</strong>在0x80000000 - 0x80200000,<strong>在前面部分</strong>。， 而<code>.text, .data</code>这些在0x87800000这里的<strong>后面部分</strong>。</p></li></ul><h3 id="A-核裸机栈管理的-“隐形规则”"><a href="#A-核裸机栈管理的-“隐形规则”" class="headerlink" title="A 核裸机栈管理的 “隐形规则”"></a><strong>A 核裸机栈管理的 “隐形规则”</strong></h3><p>栈的 “实际可用大小” 不是由链接脚本 &#x2F; 代码定义的，而是由栈顶地址和下一个可用内存地址的间距决定的</p><h2 id="gpio"><a href="#gpio" class="headerlink" title="gpio"></a>gpio</h2><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#imx6ull-%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98&quot;&gt;imx6ull 基础复盘&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#imx6ull-%E7%A1%AC%E4%BB%B6%E6%9D%BF%E5%8</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="LINUX" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/LINUX/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="驱动" scheme="http://example.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="http://example.com/2026/02/16/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2026/02/16/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2026-02-16T07:57:47.000Z</published>
    <updated>2026-02-20T13:51:20.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寒假两个月学习规划（Linux驱动方向）"><a href="#寒假两个月学习规划（Linux驱动方向）" class="headerlink" title="寒假两个月学习规划（Linux驱动方向）"></a>寒假两个月学习规划（Linux驱动方向）</h1><blockquote><p>目标：研二秋季投递大厂实习前，达到面经中Linux驱动&#x2F;BSP方向除手撕代码外的面试水平</p><p>周期：8周（约2个月）</p></blockquote><hr><h2 id="一、现状与差距分析"><a href="#一、现状与差距分析" class="headerlink" title="一、现状与差距分析"></a>一、现状与差距分析</h2><h3 id="已有基础"><a href="#已有基础" class="headerlink" title="已有基础"></a>已有基础</h3><table><thead><tr><th>模块</th><th>掌握程度</th><th>说明</th></tr></thead><tbody><tr><td>STM32</td><td>扎实</td><td>GPIO&#x2F;UART&#x2F;I2C&#x2F;DMA&#x2F;定时器&#x2F;中断&#x2F;时钟，寄存器级理解</td></tr><tr><td>FreeRTOS</td><td>扎实</td><td>任务切换&#x2F;PendSV&#x2F;双栈&#x2F;内存管理&#x2F;调度机制</td></tr><tr><td>xv6</td><td>扎实</td><td>5个lab完成，页表&#x2F;trap&#x2F;COW fork，OS内功好</td></tr><tr><td>IMX6ULL</td><td>中等</td><td>U-Boot&#x2F;LCD&#x2F;I2C&#x2F;SPI&#x2F;RTC驱动，还没进入Linux驱动框架</td></tr><tr><td>RK3399项目</td><td>实战级</td><td>TypeC OTG切换&#x2F;MIPI转LVDS屏幕适配，两年工业经验</td></tr></tbody></table><h3 id="面经考点差距表"><a href="#面经考点差距表" class="headerlink" title="面经考点差距表"></a>面经考点差距表</h3><table><thead><tr><th>模块</th><th>面经出现频率</th><th>当前状态</th><th>需要补的内容</th></tr></thead><tbody><tr><td>C语言基础</td><td>几乎每场</td><td>有实战基础</td><td>static&#x2F;volatile&#x2F;const细节、内存对齐、指针高级用法</td></tr><tr><td>C++11</td><td>~60%</td><td>薄弱</td><td>move&#x2F;lambda&#x2F;智能指针&#x2F;STL容器</td></tr><tr><td>Linux驱动框架</td><td>核心必考</td><td>刚到U-Boot</td><td>字符设备→platform→设备树→子系统驱动</td></tr><tr><td>内核内存管理</td><td>~70%</td><td>xv6有底子</td><td>kmalloc&#x2F;vmalloc&#x2F;slab&#x2F;buddy&#x2F;mmap</td></tr><tr><td>进程与调度</td><td>~60%</td><td>xv6有底子</td><td>CFS、task_struct、IPC</td></tr><tr><td>同步机制</td><td>~50%</td><td>FreeRTOS有概念</td><td>mutex&#x2F;spinlock&#x2F;信号量&#x2F;RCU</td></tr><tr><td>U-Boot</td><td>~40%</td><td>已学过</td><td>补bootcmd&#x2F;bootargs&#x2F;启动流程细节</td></tr><tr><td>ARM体系结构</td><td>~40%</td><td>有基础</td><td>异常等级、MMU、Cache一致性</td></tr><tr><td>网络TCP&#x2F;IP</td><td>~35%</td><td>薄弱</td><td>三次握手&#x2F;四次挥手、socket、select&#x2F;poll&#x2F;epoll</td></tr><tr><td>调试工具</td><td>~30%</td><td>一般</td><td>GDB、ftrace、coredump分析</td></tr><tr><td>Makefile&#x2F;Shell</td><td>~25%</td><td>一般</td><td>Makefile语法、Shell脚本基础</td></tr></tbody></table><hr><h2 id="二、8周详细规划"><a href="#二、8周详细规划" class="headerlink" title="二、8周详细规划"></a>二、8周详细规划</h2><h3 id="第1-2周：Linux驱动入门-C语言查漏"><a href="#第1-2周：Linux驱动入门-C语言查漏" class="headerlink" title="第1-2周：Linux驱动入门 + C语言查漏"></a>第1-2周：Linux驱动入门 + C语言查漏</h3><h4 id="Linux驱动（每天主力时间）"><a href="#Linux驱动（每天主力时间）" class="headerlink" title="Linux驱动（每天主力时间）"></a>Linux驱动（每天主力时间）</h4><ul><li><input disabled="" type="checkbox"> 字符设备驱动开发<ul><li><code>file_operations</code> 结构体</li><li><code>cdev</code>、<code>register_chrdev</code>、<code>alloc_chrdev_region</code></li><li>设备号（主设备号&#x2F;次设备号）</li><li><code>class_create</code> &#x2F; <code>device_create</code> 自动创建设备节点</li></ul></li><li><input disabled="" type="checkbox"> 动手写一个LED字符设备驱动，从用户空间 <code>open/write/ioctl</code> 控制</li><li><input disabled="" type="checkbox"> 设备树基础<ul><li>设备树语法（DTS&#x2F;DTB&#x2F;DTC）</li><li>节点、属性、<code>compatible</code> 字段</li><li>设备树和驱动的匹配机制（<code>of_match_table</code>）</li><li><code>of_</code> 系列API：<code>of_find_node_by_path</code>、<code>of_property_read_u32</code> 等</li></ul></li></ul><h4 id="C语言查漏（每天1小时）"><a href="#C语言查漏（每天1小时）" class="headerlink" title="C语言查漏（每天1小时）"></a>C语言查漏（每天1小时）</h4><ul><li><input disabled="" type="checkbox"> <code>static</code> 的三种用法<ul><li>修饰局部变量：生命周期延长到程序结束</li><li>修饰全局变量：限制作用域到本文件</li><li>修饰函数：限制函数可见性到本文件</li></ul></li><li><input disabled="" type="checkbox"> <code>volatile</code> 的作用和使用场景<ul><li>防止编译器优化，每次从内存读取</li><li>场景：硬件寄存器、中断服务程序中的共享变量、多线程共享变量</li></ul></li><li><input disabled="" type="checkbox"> <code>const</code> 与 <code>#define</code> 的区别<ul><li>类型检查、作用域、调试可见性</li></ul></li><li><input disabled="" type="checkbox"> 指针专题<ul><li>指针与数组的区别</li><li>函数指针、回调函数</li><li>指针的指针（二级指针）</li><li><code>void*</code> 的使用</li></ul></li><li><input disabled="" type="checkbox"> 结构体内存对齐<ul><li>对齐规则、<code>#pragma pack</code></li><li><code>sizeof</code> 计算</li></ul></li><li><input disabled="" type="checkbox"> 大小端（Big-endian &#x2F; Little-endian）<ul><li>判断方法、转换函数</li></ul></li><li><input disabled="" type="checkbox"> <code>malloc</code> 的实现原理<ul><li><code>brk</code> &#x2F; <code>mmap</code> 系统调用</li><li>内存碎片问题</li></ul></li></ul><hr><h3 id="第3-4周：platform驱动-设备树深入-内核内存管理"><a href="#第3-4周：platform驱动-设备树深入-内核内存管理" class="headerlink" title="第3-4周：platform驱动 + 设备树深入 + 内核内存管理"></a>第3-4周：platform驱动 + 设备树深入 + 内核内存管理</h3><h4 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h4><ul><li><input disabled="" type="checkbox"> platform总线驱动模型（面经必考）<ul><li><code>platform_device</code> 和 <code>platform_driver</code></li><li><code>probe</code> 和 <code>remove</code> 函数</li><li>资源获取：<code>platform_get_resource</code></li></ul></li><li><input disabled="" type="checkbox"> 设备树与驱动的完整流程<ul><li>pinctrl子系统：引脚复用配置</li><li>gpio子系统：<code>of_get_named_gpio</code>、<code>gpio_request</code>、<code>gpio_direction_output</code></li></ul></li><li><input disabled="" type="checkbox"> I2C子系统驱动（重点学框架，裸机协议你已经会了）<ul><li>I2C核心层 &#x2F; 适配器层 &#x2F; 设备驱动层</li><li><code>i2c_driver</code>、<code>i2c_client</code></li><li><code>i2c_transfer</code> &#x2F; <code>i2c_smbus_read_byte_data</code></li></ul></li><li><input disabled="" type="checkbox"> SPI子系统驱动<ul><li><code>spi_driver</code>、<code>spi_device</code></li><li><code>spi_sync</code> &#x2F; <code>spi_async</code></li></ul></li></ul><h4 id="内核内存管理"><a href="#内核内存管理" class="headerlink" title="内核内存管理"></a>内核内存管理</h4><ul><li><input disabled="" type="checkbox"> 物理内存管理<ul><li>buddy system（伙伴系统）：页的分配与合并</li><li><code>alloc_pages</code> &#x2F; <code>free_pages</code></li></ul></li><li><input disabled="" type="checkbox"> slab分配器<ul><li>解决buddy system小内存分配效率问题</li><li><code>kmem_cache_create</code> &#x2F; <code>kmem_cache_alloc</code></li></ul></li><li><input disabled="" type="checkbox"> <code>kmalloc</code> vs <code>vmalloc</code> vs <code>kmap</code><ul><li><code>kmalloc</code>：物理连续，基于slab，用于小内存</li><li><code>vmalloc</code>：虚拟连续物理不一定连续，用于大内存</li><li><code>kmap</code>：映射高端内存</li></ul></li><li><input disabled="" type="checkbox"> <code>mmap</code> 原理<ul><li>用户空间与内核空间的内存映射</li><li><code>remap_pfn_range</code></li></ul></li><li><input disabled="" type="checkbox"> <code>copy_from_user</code> &#x2F; <code>copy_to_user</code><ul><li>为什么不能直接用 <code>memcpy</code></li><li>页错误处理</li></ul></li><li><input disabled="" type="checkbox"> 用户空间虚拟内存布局<ul><li>代码段 &#x2F; 数据段 &#x2F; BSS &#x2F; 堆 &#x2F; 栈 &#x2F; mmap区域</li><li>4GB虚拟地址空间划分（3G用户 + 1G内核）</li></ul></li></ul><hr><h3 id="第5-6周：进程调度-同步机制-C-11"><a href="#第5-6周：进程调度-同步机制-C-11" class="headerlink" title="第5-6周：进程调度 + 同步机制 + C++11"></a>第5-6周：进程调度 + 同步机制 + C++11</h3><h4 id="内核进程与调度"><a href="#内核进程与调度" class="headerlink" title="内核进程与调度"></a>内核进程与调度</h4><ul><li><input disabled="" type="checkbox"> <code>task_struct</code> 结构体关键字段<ul><li>进程状态（TASK_RUNNING &#x2F; TASK_INTERRUPTIBLE &#x2F; TASK_UNINTERRUPTIBLE）</li><li>PID、优先级、调度策略</li><li>mm_struct（内存描述符）</li></ul></li><li><input disabled="" type="checkbox"> 进程状态转换<ul><li>创建→就绪→运行→阻塞→终止</li><li>僵尸进程、孤儿进程</li></ul></li><li><input disabled="" type="checkbox"> CFS调度器原理<ul><li>虚拟运行时间 <code>vruntime</code></li><li>红黑树组织就绪队列</li><li>权重与nice值的关系</li><li>SCHED_NORMAL &#x2F; SCHED_FIFO &#x2F; SCHED_RR 的区别</li></ul></li><li><input disabled="" type="checkbox"> 进程间通信（IPC）<ul><li>管道（pipe）和命名管道（FIFO）</li><li>共享内存（效率最高）</li><li>信号量（semaphore）</li><li>消息队列</li><li>信号（signal）</li><li>socket（可跨主机）</li></ul></li><li><input disabled="" type="checkbox"> 中断上下半部<ul><li>上半部：硬中断，快速执行</li><li>下半部：softirq &#x2F; tasklet &#x2F; workqueue</li><li>threaded irq</li><li>各自适用场景</li></ul></li></ul><h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><ul><li><input disabled="" type="checkbox"> 自旋锁（spinlock）<ul><li>忙等待，适用于中断上下文和短临界区</li><li><code>spin_lock</code> &#x2F; <code>spin_lock_irqsave</code></li></ul></li><li><input disabled="" type="checkbox"> 互斥锁（mutex）<ul><li>可睡眠，只能用于进程上下文</li><li>适用于长临界区</li></ul></li><li><input disabled="" type="checkbox"> 自旋锁 vs 互斥锁的选择（面经高频题）<ul><li>中断上下文 → 必须用自旋锁</li><li>临界区很短 → 自旋锁</li><li>临界区可能睡眠 → 互斥锁</li></ul></li><li><input disabled="" type="checkbox"> 信号量 vs completion</li><li><input disabled="" type="checkbox"> 原子操作：<code>atomic_t</code>、<code>atomic_read</code>、<code>atomic_set</code>、<code>atomic_inc</code></li><li><input disabled="" type="checkbox"> RCU基本概念<ul><li>读不加锁，写端等待所有读完成后再释放旧数据</li><li>适用于读多写少场景</li></ul></li><li><input disabled="" type="checkbox"> 死锁<ul><li>四个必要条件</li><li>避免方法：固定加锁顺序、超时机制</li></ul></li></ul><h4 id="C-11（每天1-1-5小时）"><a href="#C-11（每天1-1-5小时）" class="headerlink" title="C++11（每天1-1.5小时）"></a>C++11（每天1-1.5小时）</h4><blockquote><p>不需要精通，但面经中出现率约60%，需要能答上来</p></blockquote><ul><li><input disabled="" type="checkbox"> 基础特性<ul><li><code>auto</code> 类型推导</li><li><code>nullptr</code> 替代 <code>NULL</code></li><li>范围for循环</li><li><code>enum class</code></li></ul></li><li><input disabled="" type="checkbox"> 右值引用和移动语义<ul><li>左值 vs 右值</li><li><code>std::move</code> 的作用：将左值转为右值引用，触发移动构造</li><li>移动构造函数 vs 拷贝构造函数</li><li><code>std::forward</code> 完美转发</li></ul></li><li><input disabled="" type="checkbox"> 智能指针<ul><li><code>std::shared_ptr</code>：引用计数，共享所有权</li><li><code>std::unique_ptr</code>：独占所有权，不可拷贝</li><li><code>std::weak_ptr</code>：解决 <code>shared_ptr</code> 循环引用</li></ul></li><li><input disabled="" type="checkbox"> <code>lambda</code> 表达式<ul><li>语法：<code>[capture](params) -&gt; return_type { body }</code></li><li>捕获方式：<code>[=]</code> 值捕获、<code>[&amp;]</code> 引用捕获</li></ul></li><li><input disabled="" type="checkbox"> STL容器<ul><li><code>vector</code>：<code>reserve</code> vs <code>resize</code>、<code>push_back</code> vs <code>emplace_back</code></li><li><code>map</code> vs <code>unordered_map</code>（红黑树 vs 哈希表）</li><li><code>vector</code> vs <code>array</code></li></ul></li></ul><hr><h3 id="第7周：网络-ARM体系结构-调试工具"><a href="#第7周：网络-ARM体系结构-调试工具" class="headerlink" title="第7周：网络 + ARM体系结构 + 调试工具"></a>第7周：网络 + ARM体系结构 + 调试工具</h3><h4 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h4><ul><li><input disabled="" type="checkbox"> TCP三次握手（面经高频）<ul><li>SYN → SYN+ACK → ACK</li><li>为什么是三次不是两次</li></ul></li><li><input disabled="" type="checkbox"> TCP四次挥手<ul><li>FIN → ACK → FIN → ACK</li><li>TIME_WAIT状态的意义</li></ul></li><li><input disabled="" type="checkbox"> TCP vs UDP<ul><li>可靠性、连接、顺序、效率</li></ul></li><li><input disabled="" type="checkbox"> socket编程基本流程<ul><li>服务端：socket → bind → listen → accept → read&#x2F;write → close</li><li>客户端：socket → connect → read&#x2F;write → close</li></ul></li><li><input disabled="" type="checkbox"> I&#x2F;O多路复用（面经高频）<ul><li><code>select</code>：fd数量有限（1024），每次需要拷贝fd集合</li><li><code>poll</code>：无fd数量限制，但仍需遍历</li><li><code>epoll</code>：事件驱动，效率最高，<code>epoll_create</code>&#x2F;<code>epoll_ctl</code>&#x2F;<code>epoll_wait</code></li></ul></li><li><input disabled="" type="checkbox"> 其他协议<ul><li>ARP协议：IP地址→MAC地址</li><li>DNS解析过程</li><li>ICMP：ping的原理</li></ul></li></ul><h4 id="ARM体系结构补充"><a href="#ARM体系结构补充" class="headerlink" title="ARM体系结构补充"></a>ARM体系结构补充</h4><ul><li><input disabled="" type="checkbox"> ARM异常等级<ul><li>EL0（用户态）→ EL1（内核态）→ EL2（Hypervisor）→ EL3（Secure Monitor）</li></ul></li><li><input disabled="" type="checkbox"> MMU工作原理<ul><li>页表（多级页表）、TLB（Translation Lookaside Buffer）</li><li>TLB miss的处理流程</li><li>与xv6的页表机制对照理解</li></ul></li><li><input disabled="" type="checkbox"> Cache<ul><li>L1&#x2F;L2&#x2F;L3层级</li><li>Cache一致性问题（多核场景）</li><li>DMA操作时的Cache刷新</li></ul></li><li><input disabled="" type="checkbox"> ARM启动流程<ul><li>BootROM → BL1 → BL2 → BL31(TF-A) → U-Boot → Kernel</li><li>对照你学过的U-Boot部分衔接理解</li></ul></li></ul><h4 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h4><ul><li><input disabled="" type="checkbox"> GDB<ul><li>常用命令：<code>break</code>&#x2F;<code>next</code>&#x2F;<code>step</code>&#x2F;<code>print</code>&#x2F;<code>backtrace</code>&#x2F;<code>watch</code></li><li>远程调试：<code>gdbserver</code></li></ul></li><li><input disabled="" type="checkbox"> 内核调试<ul><li><code>printk</code> 日志等级</li><li>动态调试（dynamic debug）</li><li><code>ftrace</code>：函数跟踪、事件跟踪</li></ul></li><li><input disabled="" type="checkbox"> coredump分析<ul><li>生成coredump文件</li><li>用GDB加载分析</li></ul></li><li><input disabled="" type="checkbox"> <code>dmesg</code> 查看内核日志</li></ul><hr><h3 id="第8周：Makefile-Shell-面经实战-项目整理"><a href="#第8周：Makefile-Shell-面经实战-项目整理" class="headerlink" title="第8周：Makefile&#x2F;Shell + 面经实战 + 项目整理"></a>第8周：Makefile&#x2F;Shell + 面经实战 + 项目整理</h3><h4 id="Makefile-Shell-工具"><a href="#Makefile-Shell-工具" class="headerlink" title="Makefile&#x2F;Shell&#x2F;工具"></a>Makefile&#x2F;Shell&#x2F;工具</h4><ul><li><input disabled="" type="checkbox"> Makefile<ul><li>基本语法：目标、依赖、命令</li><li>自动变量：<code>$@</code>、<code>$&lt;</code>、<code>$^</code></li><li>模式规则、伪目标</li><li>内核模块的Makefile写法</li></ul></li><li><input disabled="" type="checkbox"> Shell脚本基础<ul><li>变量、条件判断、循环</li><li>常用命令：<code>grep</code>&#x2F;<code>sed</code>&#x2F;<code>awk</code>&#x2F;<code>find</code>&#x2F;<code>xargs</code></li></ul></li><li><input disabled="" type="checkbox"> Git<ul><li>分支管理、merge vs rebase</li><li>解决冲突</li></ul></li></ul><h4 id="面经实战"><a href="#面经实战" class="headerlink" title="面经实战"></a>面经实战</h4><ul><li><input disabled="" type="checkbox"> 逐条过面经PDF，针对Linux驱动&#x2F;BSP相关的面试记录：<ul><li><strong>重点场次</strong>：03、04、07、13、14、15、31、32、33、34、38号</li><li>能答的打勾，不能答的记录下来回头补</li></ul></li><li><input disabled="" type="checkbox"> 模拟面试练习<ul><li>找同学互相模拟，或者对着镜子讲</li><li>每个知识点要能用自己的话讲2-3分钟</li></ul></li></ul><h4 id="项目整理（面试竞争力核心）"><a href="#项目整理（面试竞争力核心）" class="headerlink" title="项目整理（面试竞争力核心）"></a>项目整理（面试竞争力核心）</h4><ul><li><input disabled="" type="checkbox"> RK3399 TypeC OTG项目 — STAR描述<ul><li><strong>S</strong>：什么产品、什么需求</li><li><strong>T</strong>：你负责什么</li><li><strong>A</strong>：具体怎么做的（改了哪些代码、遇到什么坑）</li><li><strong>R</strong>：结果如何</li></ul></li><li><input disabled="" type="checkbox"> RK3399 MIPI转LVDS屏幕适配项目 — STAR描述<ul><li>同上，重点准备：时序参数调试、DTS配置、调试过程</li></ul></li><li><input disabled="" type="checkbox"> 准备好能讲15分钟的项目深度版本</li><li><input disabled="" type="checkbox"> 准备好3分钟的项目精简版本</li></ul><hr><h2 id="三、每日时间分配"><a href="#三、每日时间分配" class="headerlink" title="三、每日时间分配"></a>三、每日时间分配</h2><table><thead><tr><th>时间段</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>上午（3-4h）</td><td>Linux驱动学习 + 实操</td><td>IMX6ULL跟着做，代码必须跑起来</td></tr><tr><td>下午前半（2h）</td><td>当周理论模块</td><td>内核原理 &#x2F; C++ &#x2F; 网络，按周计划推进</td></tr><tr><td>下午后半（1.5h）</td><td>写笔记 + 对照面经验证</td><td>学完一个点就去面经里找相关题</td></tr><tr><td>晚上（1-1.5h）</td><td>C语言 &#x2F; 回顾当天内容</td><td>查漏补缺</td></tr></tbody></table><hr><h2 id="四、优先级说明"><a href="#四、优先级说明" class="headerlink" title="四、优先级说明"></a>四、优先级说明</h2><p>如果时间不够用，按以下顺序砍：</p><ol><li><strong>绝不能砍</strong>：Linux驱动框架（字符设备&#x2F;platform&#x2F;设备树&#x2F;I2C子系统）、内核内存管理、同步机制</li><li><strong>尽量保住</strong>：C语言细节、进程调度CFS、中断上下半部、C++11基础</li><li><strong>可以精简</strong>：网络只需掌握TCP三握四挥 + epoll、ARM只需MMU + 启动流程</li><li><strong>实在没时间可以考前突击</strong>：Makefile&#x2F;Shell、调试工具细节</li></ol><hr><h2 id="五、关于心态"><a href="#五、关于心态" class="headerlink" title="五、关于心态"></a>五、关于心态</h2><ul><li>面经PDF里47场面试覆盖了BSP&#x2F;RTOS&#x2F;AI芯片&#x2F;蓝牙&#x2F;汽车电子等完全不同的方向，你只需要关注Linux驱动&#x2F;BSP相关的15-20场</li><li>深度比广度重要：能把Linux I2C子系统从用户空间到硬件寄存器完整讲清楚，比什么都知道一点但讲不深强得多</li><li>你的RK3399项目经验是真正的差异化竞争力，很多应届生没有这个</li><li>每周末回顾一次本周学了什么，对照面经检验，保持节奏感</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寒假两个月学习规划（Linux驱动方向）&quot;&gt;&lt;a href=&quot;#寒假两个月学习规划（Linux驱动方向）&quot; class=&quot;headerlink&quot; title=&quot;寒假两个月学习规划（Linux驱动方向）&quot;&gt;&lt;/a&gt;寒假两个月学习规划（Linux驱动方向）&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="学习计划" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>stm32 i2c</title>
    <link href="http://example.com/2026/02/15/stm32-i2c/"/>
    <id>http://example.com/2026/02/15/stm32-i2c/</id>
    <published>2026-02-15T08:58:16.000Z</published>
    <updated>2026-02-20T13:51:20.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32-i2c"><a href="#stm32-i2c" class="headerlink" title="stm32 i2c"></a>stm32 i2c</h1><h2 id="I2C-介绍"><a href="#I2C-介绍" class="headerlink" title="I2C 介绍"></a>I2C 介绍</h2><p>I2C 是 <code>两线</code>式<code>串行</code> <code>总线</code>, 用于连接微控制器以及其<strong>外围设备</strong>, 有两根线：<code>SDA(数据线)</code>，<code>SCL(时钟线)</code></p><p>IIC 总线有如下特点：</p><ul><li>总线由<code>数据线 SDA</code> 和<code>时钟线 SCL</code> 构成的串行总线<ul><li>数据线用来传输数据，时钟线用来同步数据收发。</li></ul></li><li>总线上每一个器件都有一个<strong>唯一的地址识别</strong>，<ul><li>所以我们只需要知道器件的<code>地址</code>，根据<code>时序</code>就可以实现微控制器与器件之间的通信。</li></ul></li><li>数据线 SDA 和时钟线 SCL 都是<strong>双向线路</strong>，都通过一个<strong>电流源</strong>或<strong>上拉电阻连接到正的电压</strong><ul><li>所以当总线空闲的时候，这两条线路都是<strong>高电平</strong>。</li></ul></li><li>总线上数据的<strong>传输速率</strong><ul><li>在标准模式下可达 <code>100kbit/s</code> (12k字节&#x2F;s)。</li><li>在快速模式下可达 <code>400kbit/s</code> (48k字节每秒)</li><li>在高速模式下可达 <code>3.4Mbit/s</code>(500k字节每秒)</li></ul></li><li>总线支持设备连接。在使用 IIC 通信总线时，可以有多个具备 IIC 通信能力的设备挂载在上面<ul><li>同时支持<strong>多个主机</strong>和<strong>多个从机</strong></li><li>连接到总线的接口数量只由<strong>总线电容 400pF 的限制决定</strong></li></ul></li></ul><p><img src="/../images/29.1.png" alt="alt text"></p><h2 id="I2C-总线协议"><a href="#I2C-总线协议" class="headerlink" title="I2C 总线协议"></a>I2C 总线协议</h2><p><img src="/../images/29.2.png" alt="alt text"></p><blockquote><p>记住，I2C，你就默认看SCL是高电平的时候，看就行了</p></blockquote><h3 id="1-起始信号"><a href="#1-起始信号" class="headerlink" title="1. 起始信号"></a>1. 起始信号</h3><p>当 <code>SCL 为高电平期间</code>，<code>SDA 由高到低的跳变</code>，</p><p>起始信号是一种<code>电平跳变时序</code>信号，而不是一个电平信号。</p><p>该信号<strong>由主机发出</strong>，在起始信号产生后，总线就处于被<strong>占用状态</strong>，准备数据传输。</p><blockquote><p>I2C起始信号 &#x3D; 下降沿</p></blockquote><h3 id="2-停止信号"><a href="#2-停止信号" class="headerlink" title="2. 停止信号"></a>2. 停止信号</h3><p>当 <code>SCL 为高电平期间</code>，<code>SDA 由低到高的跳变</code>；</p><p>停止信号也是一种电平跳变时序信号，而不是一个电平信号。</p><p>该信号由<strong>主机发出</strong>，在停止信号发出后，总线就处于<strong>空闲状态</strong>。</p><blockquote><p>I2C停止信号 &#x3D; 上升沿</p></blockquote><h3 id="3-应答信号"><a href="#3-应答信号" class="headerlink" title="3. 应答信号"></a>3. 应答信号</h3><p>发送器<strong>每发送一个字节</strong>(8bit)，就在时钟脉冲 9 期间<strong>释放数据线(第9bit)</strong>，由接收器<strong>反馈一个应答信号</strong>。</p><p>应答信号<code>为低电平</code>时，规定为<code>有效应答位</code>(<code>ACK</code> 简称应答位)，表示接收器已经成功地接收了</p><p>该字节；应答信号为<code>高电平</code>时，规定为非应答位(<code>NACK</code>)，一般表示接收器接收该字节<code>没有成功</code>。</p><p>观察上图标号③就可以发现，有效应答的要求是从机在第 9 个时钟脉冲之前的低电平期间<strong>将 SDA 线拉低</strong>，并且确保在该时钟的高电平期间<strong>为稳定的低电平</strong>。</p><blockquote><p>如果接收器是<strong>主机</strong>，则在它收到最后一个字节后，发送一个<strong>NACK信号</strong>，以通知被控发送器<code>结束数据发送</code>，并释放 SDA线，以便主机接收器发送一个停止信号。</p></blockquote><h3 id="4-数据有效性"><a href="#4-数据有效性" class="headerlink" title="4. 数据有效性"></a>4. 数据有效性</h3><p>IIC 总线进行<strong>数据传送</strong>时，<strong>时钟信号为高电平</strong>期间，数据线上的数据必须<strong>保持稳定</strong>，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。</p><p>数据在 <strong>SCL 的上升沿到来之前就需准备好</strong>。并在<strong>下降沿到来之前必须稳定</strong>。</p><h3 id="5-数据传输"><a href="#5-数据传输" class="headerlink" title="5. 数据传输"></a>5. 数据传输</h3><p>在 IIC 总线上传送的<code>每一位数据</code>都有<code>一个时钟脉冲相对应</code>(或同步控制)，即在 SCL 串行时钟的配合下，在 SDA 上逐位地<code>串行传送每一位数据</code>。数据位的传输是边沿触发。</p><h3 id="6-空闲状态"><a href="#6-空闲状态" class="headerlink" title="6. 空闲状态"></a>6. 空闲状态</h3><p>IIC 总线的 <code>SDA</code> 和 <code>SCL</code> 两条信号线<strong>同时处于高电平时</strong>，规定为总线的空闲状态。此时各个器件的<strong>输出级场效应管</strong>均处在<strong>截止状态</strong>，即<strong>释放总线</strong>，由两条信号线<strong>各自的上拉电阻把电平拉高</strong>。</p><h3 id="读写通信过程"><a href="#读写通信过程" class="headerlink" title="读写通信过程"></a>读写通信过程</h3><p>IIC 的基本的读写通讯过程，包括</p><ul><li><strong>主机写数据</strong>到从机，即写操作，</li><li><strong>主机</strong>到从机<strong>读取数据</strong>，即读操作</li></ul><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p><img src="/../images/29.3.png" alt="alt text"></p><p><strong>时序流程</strong>：</p><ul><li>(<code>主</code>)<strong>起始信号</strong> (Start)：主机将 SDA 线从高电平拉低，同时 SCL 为高电平。</li><li>(<code>主</code>)发送<strong>从机地址</strong>(7bit) + <strong>写操作</strong> (0)(1bit)：主机发送 7 位从机地址，第 8 位为 0(表示写入)。</li><li>(<code>从</code>)<strong>应答 (ACK)</strong>：所有<strong>从机接收到该 8bit 数据</strong>后，自行检验是否是自己的设备的地址, 从机识别到地址匹配，<strong>拉低</strong> SDA 线反馈一个应答位。</li><li>(<code>主</code>)发送<strong>寄存器地址</strong> (Reg Address)：主机发送想要操作的第一个寄存器地址。</li><li>(<code>从</code>)<strong>应答 (ACK)</strong>：从机接收后反馈 ACK。<blockquote><p>开始发送字节数据, Loop(N)</p></blockquote></li><li>(<code>主</code>)发送<strong>数据 1</strong> (Data 1)：主机发送<strong>第一个字节数据</strong>。</li><li>(<code>从</code>)<strong>应答 (ACK)</strong>：从机接收后反馈 ACK。<blockquote><p>发送数据 N (Data N)：主机会继续发送后续数据，每发完一个字节，从机都要反馈一个 ACK。<br>对于支持“<strong>地址自增</strong>”的从机，数据会<strong>自动存入连续的寄存器</strong>。</p></blockquote></li><li>(<code>主</code>)停止信号 (Stop)：全部发送完成后，主机在 SCL 为高电平时将 SDA 从低电平释放为高电平。</li></ul><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p><img src="/../images/29.4.png" alt="alt text"></p><p><strong>读操作</strong>通常分为<strong>两个阶段</strong>：</p><ol><li>先通过“<strong>伪写</strong>”告知<strong>寄存器地址</strong>，</li><li>再进行<strong>实际读取</strong>。</li></ol><p><strong>时序流程</strong>：</p><ul><li>(<code>主</code>)<strong>起始信号</strong>(Start)。</li><li>(<code>主</code>)发送<strong>从机地址</strong>(<code>7bit</code>) + <strong>写操作(0)</strong>(<code>1bit</code>) </li><li>(<code>从</code>)<strong>应答 (ACK)</strong>。</li><li>(<code>主</code>)发送<strong>寄存器地址</strong> (Reg Address)：告诉从机你要<strong>从哪个位置开始</strong>。</li><li>(<code>从</code>)<strong>应答</strong> (ACK)。<blockquote><p>从这里开始，读操作和写操作开始区分了，意图显露</p></blockquote></li><li>(<code>主</code>)<strong>重复起始信号</strong> (Restart)：<code>不发送停止信号</code>，<strong>直接再次发出起始信号</strong>，准备<strong>切换到读模式</strong>。</li><li>(<code>主</code>)发送<strong>从机地址</strong>(<code>7bit</code>) + <strong>读操作(1)</strong>(<code>1bit</code>) 。 主机发送 7 位地址，第 8 位为 1(<strong>表示读取</strong>)。</li><li>(<code>从</code>)<strong>应答 (ACK)</strong>：从机反馈 ACK，<strong>从机开始接管 SDA 控制权</strong>。<blockquote><p>接下来从机开始接管SDA，发送数据，Loop(N)</p></blockquote></li><li>(<code>从</code>)<strong>从机发送数据 1</strong> (Data 1)：从机发送数据，主机接收。</li><li>(<code>主</code>)<strong>主机应答</strong> (ACK)：关键点，主机收到数据后，<strong>如果还想继续读</strong>，必须<strong>拉低 SDA 反馈 ACK</strong>。</li><li>(<code>从</code>)<strong>从机发送数据 N</strong> (Data N)：重复上述过程。</li><li>(<code>主</code>)<strong>非应答 (NACK)</strong>：当主机接收完<code>最后一个字节</code>后，必须发送 <strong>NACK</strong>(<strong>高电平</strong>)，告诉从机“<code>我不要了</code>”。</li><li>(<code>主</code>)<strong>停止信号</strong> (Stop)。(起始停止信号，永远主机发出)</li></ul><h2 id="外设数据传输协议"><a href="#外设数据传输协议" class="headerlink" title="外设数据传输协议"></a>外设数据传输协议</h2><p>由于i2c是用来读写外设内部数据的，本质上还是在传输<strong>字节流</strong>。</p><p>这就意味着，必须要规范这个<strong>外设数据传输协议</strong>，就是说，<strong>如何理解这个字节流</strong>。</p><p>下面以<strong>24C02</strong>这个外设的字节流(数据传输协议)为例</p><h3 id="24C02"><a href="#24C02" class="headerlink" title="24C02"></a>24C02</h3><p>24C02 是一个:</p><ul><li><code>2K bit</code> (2^11bit)的<code>串行</code> <code>EEPROM 存储器</code>，内部含有 <code>256 个字节</code>(2^8byte)。</li><li>在 24C02 里面还有一个 <code>8 字节</code>的<code>页写缓冲器</code></li><li>该设备的通信方式 <code>IIC</code>，通过其 SCL 和 SDA 与其他设备通信</li><li>24C02 设备的<strong>读操作地址</strong>为：<strong>0xA1</strong>，<strong>写操作地址</strong>为：<strong>0xA0</strong></li></ul><p><img src="/../images/29.5.png" alt="alt text"></p><blockquote><p>WP 引脚是写保护引脚，接高电平只读，<strong>接地允许读和写</strong>(我们接地)</p></blockquote><h4 id="24C02-单字节流写时序"><a href="#24C02-单字节流写时序" class="headerlink" title="24C02 单字节流写时序"></a>24C02 单字节流写时序</h4><p><img src="/../images/29.6.png" alt="alt text"><br>这个就是正常的i2C的一次写一个字节的时序图</p><p>单字节写入到 24C02，<strong>效率比较低</strong>，所以 24C02 有<strong>页写入时序</strong>，大大<br>提高了写入效率，下面看一下 24C02 页写时序图</p><h4 id="24C02-页-写时序"><a href="#24C02-页-写时序" class="headerlink" title="24C02 页 写时序"></a>24C02 页 写时序</h4><p><img src="/../images/29.7.png" alt="alt text"></p><p>在单字节写时序时，每次写入数据时都需要先写入设备的内存地址才能实现，在页写时序中，只需要告诉 24C02 第一个内存地址 1，后面数据会按照顺序写入到内存地址 2，内存地址 3等，大大节省了通信时间</p><blockquote><p>这个本质上就是<strong>写寄存器地址自动后移</strong></p></blockquote><p>因为 24C02 <strong>每次只能 8bit 数据</strong>，所以它的<strong>页大小</strong>也就是 <strong>1 字节</strong>， 所以还是字节流</p><h4 id="24C02-读时序"><a href="#24C02-读时序" class="headerlink" title="24C02 读时序"></a>24C02 读时序</h4><p><img src="/../images/29.8.png" alt="alt text"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>ST 为了规避飞利浦 IIC 专利问题，将 STM32 的硬件 IIC 设计的比较复杂，而且稳定性不怎么好，所以这里我们不推荐使用。</p><p>用<strong>软件模拟 IIC</strong>，最大的好处就是<strong>方便移植</strong>，同一个代码兼容所有 MCU，任何一个单片机<strong>只要有 IO 口</strong>，就可以<strong>很快的移植过去</strong>，而且不需要特定的 IO 口。</p><p>而<strong>硬件 IIC</strong>，则<strong>换一款 MCU，基本上就得重新移植</strong>，这也是我们推荐使用软件模拟 IIC 的另外一个原因</p><p>本实验中，我们<strong>通过 GPIO 来模拟 IIC</strong>，所以不需要使用 FWLIB 分组下添加 HAL 库文件支持。实验工程中，我们新增了 myiic.c 存放 iic 底层驱动代码，24cxx.c 文件存放 24C02 驱动。</p><p>功能和代码很简单，就是靠gpio电平翻转来模拟i2c协议。不过多赘述了</p><p>有一点要注意：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line"></span><br><span class="line">    IIC_SCL_GPIO_CLK_ENABLE();  <span class="comment">/* SCL引脚时钟使能 */</span></span><br><span class="line">    IIC_SDA_GPIO_CLK_ENABLE();  <span class="comment">/* SDA引脚时钟使能 */</span></span><br><span class="line"></span><br><span class="line">    gpio_init_struct.Pin = IIC_SCL_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP;        <span class="comment">/* 推挽输出 */</span></span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLUP;                <span class="comment">/* 上拉 */</span></span><br><span class="line">    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;      <span class="comment">/* 高速 */</span></span><br><span class="line">    HAL_GPIO_Init(IIC_SCL_GPIO_PORT, &amp;gpio_init_struct);<span class="comment">/* SCL */</span></span><br><span class="line"></span><br><span class="line">    gpio_init_struct.Pin = IIC_SDA_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_OD;        <span class="comment">/* 开漏输出 */</span></span><br><span class="line">    HAL_GPIO_Init(IIC_SDA_GPIO_PORT, &amp;gpio_init_struct);<span class="comment">/* SDA */</span></span><br><span class="line">    <span class="comment">/* SDA引脚模式设置,开漏输出,上拉, 这样就不用再设置IO方向了, 开漏输出的时候(=1), 也可以读取外部信号的高低电平 */</span></span><br><span class="line"></span><br><span class="line">    iic_stop();     <span class="comment">/* 停止总线上所有设备 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>推挽输出</strong>的<strong>特点</strong>是：</p><ul><li><p>输出 1 时，上方的 P-MOS 管导通，将引脚强行拉到 VCC；</p></li><li><p>输出 0 时，下方的 N-MOS 管导通，将引脚强行拉到 GND。</p></li><li><p><strong>短路风险</strong>：</p><ul><li>如果主机配置为推挽输出 1(正在往 VCC 拉)，而此时从机正好产生应答 ACK 输出 0(正在往 GND 拉)，这就相当于 VCC 与 GND 直接打架(短路)。轻则通信失败，重则烧毁 GPIO。</li></ul></li><li><p><strong>无法监听</strong>：推挽输出是一种“<strong>强驱动</strong>”，<strong>外部设备很难改变它的电平</strong>。</p></li></ul><hr><p><strong>开漏(Open-Drain)如何实现“读写合一”</strong>？</p><p>这是 STM32 硬件设计的一个妙处。在<strong>开漏输出模式</strong>下，P-MOS 管是永远关闭的，只有 N-MOS 管受控制：</p><p><strong>写 0(拉低电平)</strong>：N-MOS 导通，引脚接到 GND，由于此时电流流入 GND，电平变低。</p><p><strong>写 1(释放总线)</strong>：<strong>N-MOS 截止</strong>。此时引脚处于“高阻态”，全靠外部或内部的上拉电阻将电平拉高。</p><blockquote><p>开漏本质上只能控半边，另一边由上下拉的电阻来实现。</p></blockquote><hr><p><strong>为什么写 1 之后能直接读</strong>？</p><p>正如你所猜测的，STM32 的<strong>输入电路</strong>(Input Data Register, IDR)在<strong>开漏输出模式下</strong>依然是工作的。</p><p>当你设置<code> ODR = 1</code>(写 1)时，主机<strong>实际上</strong>是“<strong>松手</strong>”了。这时候 SDA 线的电平高低完全由总线上其他设备说了算：</p><p>如果没有人拉低它，由于上拉电阻的存在，电平是高，你读 IDR 得到 1。</p><p>如果<strong>有从机(Slave)为了发 ACK 把它拉低了</strong>，电平就是低，你读<strong>IDR得到到 0</strong>。</p><p><strong>底层逻辑</strong>：<br>在 STM32 的 GPIO 结构图中，输出控制回路和输入读取回路是并行的。只要你没有关闭输入施密特触发器，IDR 寄存器就会实时反映引脚上的电压情况。</p><blockquote><p>在很多<strong>老的代码</strong>里，你会看到读 ACK 之前要调用一次 IIC_SDA_IN()(改变寄存器把模式<strong>从 Output 换成 Input</strong>)，读完后再调用 IIC_SDA_OUT()。</p></blockquote><hr><p><strong>你的这份代码使用的 “开漏+上拉”方案 有以下好处</strong>：</p><p><strong>省事</strong>：不需要频繁切换 GPIO 的 Mode 寄存器，减少了 CPU 开销。</p><p><strong>安全</strong>：利用了 I2C 标准的“线与(Wired-AND)”特性。只要有一个设备输出 0，总线就是 0。</p><p><strong>双向无缝</strong>：只需要记住一个原则——在读取从机数据(或 ACK)之前，主机必须先写 1 释放总线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stm32-i2c&quot;&gt;&lt;a href=&quot;#stm32-i2c&quot; class=&quot;headerlink&quot; title=&quot;stm32 i2c&quot;&gt;&lt;/a&gt;stm32 i2c&lt;/h1&gt;&lt;h2 id=&quot;I2C-介绍&quot;&gt;&lt;a href=&quot;#I2C-介绍&quot; class=&quot;head</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 dma</title>
    <link href="http://example.com/2026/02/13/stm32-dma/"/>
    <id>http://example.com/2026/02/13/stm32-dma/</id>
    <published>2026-02-13T11:43:09.000Z</published>
    <updated>2026-02-20T13:51:20.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#stm32-dma">stm32 dma</a><ul><li><a href="#dma%E4%BB%8B%E7%BB%8D">dma介绍</a></li><li><a href="#dma%E8%B5%84%E6%BA%90">dma资源</a></li><li><a href="#dma%E7%89%B9%E6%80%A7">dma特性</a></li><li><a href="#%E6%A1%86%E5%9B%BE">框图</a><ul><li><a href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-dma-%E8%AF%B7%E6%B1%82">第一部分 DMA 请求</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%80%9A%E9%81%93">第二部分 通道</a></li><li><a href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E4%BB%B2%E8%A3%81%E5%99%A8">第三部分 仲裁器</a></li></ul></li><li><a href="#%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a><ul><li><a href="#cr">CR</a></li><li><a href="#dr">DR</a></li><li><a href="#sr">SR</a></li></ul></li><li><a href="#%E5%AE%9E%E9%AA%8C">实验</a><ul><li><a href="#%E5%88%86%E6%9E%90">分析</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3hal%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E5%86%99%E6%80%9D%E6%83%B3">如何理解hal库驱动的编写思想</a></li><li><a href="#hal%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">hal库驱动的实现</a></li><li><a href="#%E5%A4%9A%E4%B8%AA%E6%89%93%E5%8D%B0%E6%BA%90%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA">多个打印源（环形缓冲区）</a></li></ul></li><li><a href="#dma--uart-%E6%9C%80%E9%AB%98%E6%95%88%E6%8E%A5%E6%94%B6%E6%96%B9%E6%A1%88">dma + uart （最高效接收方案）</a><ul><li><a href="#3%E7%A7%8D%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5">3种接收不定长数据的情况</a></li></ul></li><li><a href="#dma--uart-%E6%9C%80%E9%AB%98%E6%95%88%E5%8F%91%E9%80%81%E6%96%B9%E6%A1%88">dma + uart （最高效发送方案）</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul></li></ul><h1 id="stm32-dma"><a href="#stm32-dma" class="headerlink" title="stm32 dma"></a>stm32 dma</h1><h2 id="dma介绍"><a href="#dma介绍" class="headerlink" title="dma介绍"></a>dma介绍</h2><p>DMA，全称为：Direct Memory Access，即<strong>直接存储器访问</strong></p><p>DMA 传输方式无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场的过程</p><p>通过硬件为 <code>RAM</code> 与 <code>I/O 设备</code>开辟一条直接传送数据的通路，能使 CPU 的效率大为提高</p><h2 id="dma资源"><a href="#dma资源" class="headerlink" title="dma资源"></a>dma资源</h2><p>STM32F103 内部有 <strong>2 个 DMA</strong> 控制器(DMA2 仅存大容量产品中)。</p><ol><li><code>DMA1</code> 有 <code>7</code> 个通道</li><li><code>DMA2</code> 有 <code>5</code> 个通道</li></ol><p><strong>每个通道</strong>专门用来管理来自于<strong>一个或多个外设</strong>对<strong>存储器</strong>访问的请求。</p><p>还有一个<strong>仲裁器</strong>来协调各个 DMA 请求的优先权</p><h2 id="dma特性"><a href="#dma特性" class="headerlink" title="dma特性"></a>dma特性</h2><p>DMA 有以下一些特性：</p><ul><li><strong>每个通道</strong>都直接连接<code>专用的硬件 DMA 请求</code>，每个通道都同样<code>支持软件触发</code>。这些功能通过软件来配置。</li><li>在<strong>七个请求间的优先权</strong>可以通过软件编程设置(共有四级：很高、高、中等和低)，假如在相等优先权时由硬件决定(请求 0 优先于请求 1，依此类推)。</li><li>独立的源和目标数据区的传输宽度(字节、半字、全字)，模拟打包和拆包的过程。源和目标地址必须<strong>按数据传输宽度对齐</strong>。</li><li>支持循环的缓冲器管理。</li><li><strong>每个通道都有 3 个事件标志</strong>(DMA 半传输，DMA 传输完成和 DMA 传输出错), 这 3 个事件标志<strong>逻辑或</strong>成为一个单独的中断请求。</li><li>存储器和存储器间的传输。</li><li><strong>外设和存储器</strong>，<strong>存储器和外设</strong>的传输。</li><li>闪存、SRAM、外设的 SRAM、APB1、APB2 和 AHB 外设均可作为访问的源和目标。</li><li>可编程的数据传输数目：最大为 65536。</li></ul><h2 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h2><p><img src="/../images/28.1.png" alt="alt text"></p><h3 id="第一部分-DMA-请求"><a href="#第一部分-DMA-请求" class="headerlink" title="第一部分 DMA 请求"></a>第一部分 DMA 请求</h3><p>如果<strong>外设</strong>想要<code>通过 DMA</code> 来<strong>传输数据</strong>，必须</p><ol><li>先给 DMA 控制器发送 <code>DMA 请求</code>，</li><li>DMA 收到请求信号之后，控制器会<code>给外设一个应答信号</code></li><li>当外设应答后且 DMA 控制器收到应答信号之后，</li><li>会启动 DMA 的传输，直到传输完毕</li></ol><p>STM32F103 共有 <code>DMA1</code> 和 <code>DMA2</code> 两个控制器，<code>DMA1 有 7 个通道</code>，<code>DMA2 有 5 个通道</code></p><p><strong>不同的 DMA 控制器的通道</strong>对应着<strong>不同的外设请求</strong>，这决定了我们在软件编程上该怎么设置</p><p><img src="/../images/28.2.png" alt="alt text"></p><p><img src="/../images/28.3.png" alt="alt text"></p><h3 id="第二部分-通道"><a href="#第二部分-通道" class="headerlink" title="第二部分 通道"></a>第二部分 通道</h3><p>DMA 具有 12 个独立可编程的通道，其中 DMA1 有 7 个通道，DMA2 有 5 个通道，<strong>每个通道对应不同的外设的 DMA 请求</strong>。虽然每个通道可以接收多个外设的请求，但是<strong>同一时间只能接收一个</strong>，不能同时接收多个。</p><h3 id="第三部分-仲裁器"><a href="#第三部分-仲裁器" class="headerlink" title="第三部分 仲裁器"></a>第三部分 仲裁器</h3><p>当<strong>发生多个 DMA 通道请求时</strong>，就意味着有先后响应处理的顺序问题，这个就由<strong>仲裁器</strong>管理。</p><p><code>仲裁器</code>管理 DMA 通道请求分为<code>两个阶段</code>。</p><ol><li>第一阶段属于<strong>软件阶段</strong>，可以在 DMA_CCRx寄存器中设置，有 4 个等级：非常高，高，中和低四个<strong>优先级</strong>。</li><li>第二阶段属于<strong>硬件阶段</strong>，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高，比如通道 0 高于通道 1。</li></ol><p>在大容量产品和互联型产品中，<strong>DMA1 控制器拥有高于 DMA2 控制器的优先级</strong>。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="CR"><a href="#CR" class="headerlink" title="CR"></a>CR</h3><p><img src="/../images/28.4.png" alt="alt text"></p><p>该寄存器是用来<strong>清除 DMA_ISR 的对应位</strong>的，通过写 0 清除。</p><blockquote><p>在 DMA_ISR 被置位后，我们必须通过向该寄存器对应的位写 0 来清除</p></blockquote><p><img src="/../images/28.5.png" alt="alt text"><br>该寄存器控制着 DMA <code>通道 x</code> 的<code>每次传输所要传输的数据量</code>。其设置范围为 0~65535。并且<strong>该寄存器的值随着传输的进行而减少</strong>，当该寄存器的<strong>值为 0</strong> 的时候就代表此次数据传输已经<strong>全部发送完成</strong>。</p><blockquote><p>所以可以通过<code>这个寄存器的值</code>来<code>获取当前 DMA 传输的进度</code></p></blockquote><p><img src="/../images/28.6.png" alt="alt text"><br>这个就是正经的配置寄存器了</p><p>该寄存器控制着 DMA 很多相关信息，包括</p><ul><li>数据宽度</li><li>外设及存储器宽度</li><li>通道优先级、</li><li>增量模式、</li><li>传输方向、</li><li>中断允许、</li><li>使能等，</li></ul><blockquote><p>DMA_CCRx 是 DMA 传输的核心控制寄存器</p></blockquote><p><img src="/../images/28.7.png" alt="alt text"><br><img src="/../images/28.8.png" alt="alt text"></p><p>该<strong>寄存器</strong>是用来存储 STM32 <strong>外设的地址</strong>，比如我们平常使用串口 1，那么该寄存器必须写入 0x40013804（其实就是<code>&amp;USART1_DR</code>）。其他外设就可以修改成其他对应外设地址就好了</p><blockquote><p>所以，<code>DMA</code>就是个<strong>数据拷贝工</strong>，原来我们拷贝数据，需要占用cpu来拷贝（比如从uart-&gt;DB中，拷贝一个字节到内存中）</p></blockquote><p><img src="/../images/28.9.png" alt="alt text"></p><p>DMA 通道 x <strong>存储器地址寄存器</strong>用来存放<strong>存储器的地址</strong>，该寄存器和DMA_CPARx 差不多，所以就不列出来了。</p><p>举个应用的例子，在程序中，我们使用到一个 g_sendbuf [5200]数组来做存<br>储器，那么我们在 DMA_CMARx 中写入<code>&amp;g_sendbuf</code>(即内存地址) 即可。</p><h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><p>无</p><h3 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h3><p><img src="/../images/28.10.png" alt="alt text"><br>这个就是个中断状态寄存器，可以看出某个通道是否出现了中断，以及处于什么状态</p><p>该寄存器是<strong>查询当前 DMA 传输的状态</strong>，我们常用的是 <code>TCIFx</code> 位，即通道 DMA <code>传输完成与否</code>的标志。</p><blockquote><p>注意此寄存器为只读寄存器，所以在这些位被置位之后，只能通过其他的操作来清除</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验是用dma来代替cpu拷贝数据到uart1去发送。</p><p>这个自己手写了一下bsp的驱动。</p><p>需要注意的点：</p><ol><li>注意观察dma结构体（类对象）的成员变量的类型</li><li>dma对象要和uart使用的外设对象绑定，不绑定，uart那边无法使用dma的方法</li></ol><p>因为我们已经初始化好了uart1，所以只要补上dma1的通道4即可。</p><p>dma.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/DMA/dma.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DMA_HandleTypeDef hdma;</span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef g_uart1_handle;  <span class="comment">/* UART句柄 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma1_init</span><span class="params">(DMA_Channel_TypeDef* DMAx_CHx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//enable dma</span></span><br><span class="line">    __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init dma</span></span><br><span class="line">    <span class="comment">//hdma.Instance = (DMA_Channel_TypeDef   *)DMA1_BASE;</span></span><br><span class="line">hdma.Instance = DMAx_CHx;</span><br><span class="line">    hdma.Init.Direction = DMA_MEMORY_TO_PERIPH;</span><br><span class="line">  hdma.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">  hdma.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">  hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">  hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">  hdma.Init.Mode = DMA_NORMAL;</span><br><span class="line">  hdma.Init.Priority = DMA_PRIORITY_HIGH;</span><br><span class="line"></span><br><span class="line">    hdma.DmaBaseAddress = (DMA_TypeDef            *)DMA1_BASE;</span><br><span class="line">    <span class="comment">//hdma.ChannelIndex = channel;</span></span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(&amp;g_uart1_handle,hdmatx, hdma);</span><br><span class="line">    HAL_DMA_Init(&amp;hdma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> lcd_id[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HAL_Init();                                         <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">    sys_stm32_clock_init(RCC_PLL_MUL9);                 <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                                     <span class="comment">/* 延时初始化 */</span></span><br><span class="line">    usart_init(<span class="number">115200</span>);                                 <span class="comment">/* 串口初始化为115200 */</span></span><br><span class="line">    led_init();                                         <span class="comment">/* 初始化LED */</span></span><br><span class="line">    lcd_init();                                         <span class="comment">/* 初始化LCD */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1\n&quot;</span>);</span><br><span class="line">    dma1_init((DMA_Channel_TypeDef* )DMA1_Channel4_BASE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test3\n&quot;</span>);</span><br><span class="line">    g_point_color = RED;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)lcd_id, <span class="string">&quot;LCD ID:%04X&quot;</span>, lcddev.id);  <span class="comment">/* 将LCD ID打印到lcd_id数组 */</span></span><br><span class="line">HAL_UART_Transmit_DMA(&amp;g_uart1_handle, (<span class="type">uint8_t</span>*)send_buffer, <span class="keyword">sizeof</span>(send_buffer));</span><br><span class="line"><span class="comment">//HAL_UART_Transmit_IT(&amp;g_uart1_handle, (uint8_t*)send_buffer, sizeof(send_buffer));</span></span><br><span class="line"><span class="comment">//HAL_UART_Transmit(&amp;g_uart1_handle, (uint8_t*)send_buffer, sizeof(send_buffer), 1000);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  LED0_TOGGLE(); <span class="comment">/*红灯闪烁*/</span></span><br><span class="line">LED1_TOGGLE();</span><br><span class="line">        delay_ms(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来剖析一下dma驱动，以及串口dma发送驱动具体工作内容</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看一下hal里面，对dma对象的类定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * @brief  DMA handle Structure definition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">DMA_HandleTypeDef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  DMA_Channel_TypeDef   *Instance;                      <span class="comment">/* 寄存器基地址 (通道) */</span></span><br><span class="line">  </span><br><span class="line">  DMA_InitTypeDef       Init;                          <span class="comment">/* DMA 通信参数 */</span></span><br><span class="line">  </span><br><span class="line">  HAL_LockTypeDef       Lock;                          <span class="comment">/* DMA 锁对象 */</span></span><br><span class="line">  </span><br><span class="line">  HAL_DMA_StateTypeDef  State;                         <span class="comment">/* DMA 传输状态 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span>                  *Parent;            <span class="comment">/* 父对象状态，HAL 库处理的中间变量 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span>                  (* XferCpltCallback)( <span class="keyword">struct</span> __DMA_HandleTypeDef * hdma);    <span class="comment">/* DMA 传输完成回调 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span>                  (* XferHalfCpltCallback)( <span class="keyword">struct</span> __DMA_HandleTypeDef * hdma); <span class="comment">/* DMA 一半传输完成回调 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span>                  (* XferErrorCallback)( <span class="keyword">struct</span> __DMA_HandleTypeDef * hdma);   <span class="comment">/*DMA 传输错误回调*/</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>                  (* XferAbortCallback)( <span class="keyword">struct</span> __DMA_HandleTypeDef * hdma);   <span class="comment">/* DMA 传输中止回调 */</span>  </span><br><span class="line">  </span><br><span class="line">  __IO <span class="type">uint32_t</span>         ErrorCode;                       <span class="comment">/* DMA 存取错误代码 */</span></span><br><span class="line"></span><br><span class="line">  DMA_TypeDef            *DmaBaseAddress;                <span class="comment">/* DMA 通道基地址 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">uint32_t</span>               ChannelIndex;                   <span class="comment">/* DMA 通道索引 */</span></span><br><span class="line"></span><br><span class="line">&#125; DMA_HandleTypeDef; </span><br></pre></td></tr></table></figure><p>可以看到，一个dma的类对象，里面包含的成员变量有很多，但是我也不知道实际要初始化哪些</p><h4 id="如何理解hal库驱动的编写思想"><a href="#如何理解hal库驱动的编写思想" class="headerlink" title="如何理解hal库驱动的编写思想"></a>如何理解hal库驱动的编写思想</h4><p><strong>1. 统一的标准：HAL 驱动的“三部曲”</strong></p><p>无论是一个简单的 GPIO，还是复杂的网络控制器（ETH），HAL 库的逻辑永远遵循这个流程：</p><ul><li><p>第一步：<strong>配置句柄</strong>（The Handle）这是你已经掌握的：填充 <code>Instance</code> 和 <code>Init</code>。这是告诉硬件：“你是谁”以及“你怎么工作”。</p></li><li><p>第二步：<strong>硬件底层初始化</strong>（The <code>MSP</code> - MCU Support Package）<br>这是最容易被忽略但最标准的地方。HAL 库规定：所有的 HAL_XXX_Init 内部都会调用一个空弱函数（__weak）叫 <code>HAL_XXX_MspInit</code>。</p></li></ul><blockquote><p>标准在这里： 凡是涉及<strong>跨模块的关联</strong>（比如 UART 要用 DMA，或者 GPIO 要用中断），标准做法都是在 <code>MspInit</code> 中完成。</p></blockquote><blockquote><p>你的发现： __HAL_LINKDMA 就应该写在 HAL_UART_MspInit 里面。</p></blockquote><ul><li>第三步：<strong>启动与关联</strong>（The Process&#x2F;Link）<br>这就是你提到的“绑定”。在 HAL 的逻辑里，如果 外设 A 需要调用外设 B 来协同工作，那么 A 的句柄里一定有<code>一个指针指向 B</code>。</li></ul><hr><p><strong>2. 怎么“预判”哪些变量需要赋值？</strong></p><p>当你拿到一个全新的外设结构体时，可以用以下逻辑进行“排查”：</p><ul><li>看成员名：</li></ul><blockquote><p>凡是带 *hdma… 或者 *h…（<strong>指针开头</strong>）的，通常是关联对象。它们不会在 Init 函数里自动生成，必须通过 __HAL_LINKDMA 或手动赋值。</p></blockquote><blockquote><p>凡是带 State、Lock、ErrorCode 的，全是<strong>只读</strong>。</p></blockquote><ul><li>看“协作关系”：</li></ul><blockquote><p>问自己：这个外设是独立工作的吗？</p></blockquote><blockquote><p>如果是 UART、SPI、I2C 这种<strong>需要 DMA 搬运数据</strong>的，你立刻就要想到：<strong>必然存在一个 Link 动作</strong>。</p></blockquote><ul><li>看 .c 文件的头部注释（最硬核的标准）：</li></ul><blockquote><p>打开 <code>stm32f1xx_hal_uart.c</code>，看顶部的 How to use this driver。</p><p>你会发现官方明确写了：<code>For DMA mode</code>: (##) Configure the UART TX&#x2F;RX DMA channel 和 (##) Associate the initialized DMA handle to the UART handle。</p></blockquote><p><strong>3. 如果你自己写驱动，该如何设计？</strong></p><p>为了让你的驱动看起来像“正规军”，建议模仿 HAL 的这种**“解耦”**设计：</p><ul><li><p><strong>不要在 Init 内部写死关联</strong>： 不要让 DMA_Init 去管 UART。</p><ul><li><p>使用“父子”指针： * 如果 A 驱动调用 B 驱动，在 A 的结构体里留一个 void *Parent 或 B_HandleTypedef *pChild。</p></li><li><p>提供一个宏（类似 LINK）来连接它们。</p></li></ul></li><li><p>状态与配置分离： * 用户填写的放在 Init。</p></li><li><p>驱动运行时的临时变量（如 Counter、Index）放在结构体的根目录下。</p></li></ul><p>以上，应该能对hal编写的驱动，有一个初步的认识了。</p><p>下面看看实际hal的工作</p><h4 id="hal库驱动的实现"><a href="#hal库驱动的实现" class="headerlink" title="hal库驱动的实现"></a>hal库驱动的实现</h4><p><code>HAL_DMA_Init()</code>,</p><p>可以看到，它使用assert_parame进行断言判断，这里也可以看出要初始化实例的那些变量</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Initialize the DMA according to the specified</span></span><br><span class="line"><span class="comment">  *         parameters in the DMA_InitTypeDef and initialize the associated handle.</span></span><br><span class="line"><span class="comment">  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains</span></span><br><span class="line"><span class="comment">  *               the configuration information for the specified DMA Channel.</span></span><br><span class="line"><span class="comment">  * @retval HAL status</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_DMA_Init</span><span class="params">(DMA_HandleTypeDef *hdma)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> tmp = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the DMA handle allocation */</span></span><br><span class="line">  <span class="keyword">if</span>(hdma == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_DMA_ALL_INSTANCE(hdma-&gt;Instance));</span><br><span class="line">  assert_param(IS_DMA_DIRECTION(hdma-&gt;Init.Direction));</span><br><span class="line">  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma-&gt;Init.PeriphInc));</span><br><span class="line">  assert_param(IS_DMA_MEMORY_INC_STATE(hdma-&gt;Init.MemInc));</span><br><span class="line">  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma-&gt;Init.PeriphDataAlignment));</span><br><span class="line">  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma-&gt;Init.MemDataAlignment));</span><br><span class="line">  assert_param(IS_DMA_MODE(hdma-&gt;Init.Mode));</span><br><span class="line">  assert_param(IS_DMA_PRIORITY(hdma-&gt;Init.Priority));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (DMA2)</span></span><br><span class="line">  <span class="comment">/* calculation of the channel index */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">uint32_t</span>)(hdma-&gt;Instance) &lt; (<span class="type">uint32_t</span>)(DMA2_Channel1))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* DMA1 */</span></span><br><span class="line">    hdma-&gt;ChannelIndex = (((<span class="type">uint32_t</span>)hdma-&gt;Instance - (<span class="type">uint32_t</span>)DMA1_Channel1) / ((<span class="type">uint32_t</span>)DMA1_Channel2 - (<span class="type">uint32_t</span>)DMA1_Channel1)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    hdma-&gt;DmaBaseAddress = DMA1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* DMA2 */</span></span><br><span class="line">    hdma-&gt;ChannelIndex = (((<span class="type">uint32_t</span>)hdma-&gt;Instance - (<span class="type">uint32_t</span>)DMA2_Channel1) / ((<span class="type">uint32_t</span>)DMA2_Channel2 - (<span class="type">uint32_t</span>)DMA2_Channel1)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    hdma-&gt;DmaBaseAddress = DMA2;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* DMA1 */</span></span><br><span class="line">  <span class="comment">//可以看到，Index是通过channel4的基地址计算出来的，baseAddress就直接赋值为了DMA1</span></span><br><span class="line">  hdma-&gt;ChannelIndex = (((<span class="type">uint32_t</span>)hdma-&gt;Instance - (<span class="type">uint32_t</span>)DMA1_Channel1) / ((<span class="type">uint32_t</span>)DMA1_Channel2 - (<span class="type">uint32_t</span>)DMA1_Channel1)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  hdma-&gt;DmaBaseAddress = DMA1;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* DMA2 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Change DMA peripheral state */</span></span><br><span class="line">  hdma-&gt;State = HAL_DMA_STATE_BUSY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get the CR register value */</span></span><br><span class="line">  <span class="comment">//获取当前的dma1通道4的控制寄存器CR</span></span><br><span class="line">  tmp = hdma-&gt;Instance-&gt;CCR;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */</span></span><br><span class="line">  tmp &amp;= ((<span class="type">uint32_t</span>)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \</span><br><span class="line">                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \</span><br><span class="line">                      DMA_CCR_DIR));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Prepare the DMA Channel configuration */</span></span><br><span class="line">  tmp |=  hdma-&gt;Init.Direction        |</span><br><span class="line">          hdma-&gt;Init.PeriphInc           | hdma-&gt;Init.MemInc           |</span><br><span class="line">          hdma-&gt;Init.PeriphDataAlignment | hdma-&gt;Init.MemDataAlignment |</span><br><span class="line">          hdma-&gt;Init.Mode                | hdma-&gt;Init.Priority;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write to DMA Channel CR register */</span></span><br><span class="line">  hdma-&gt;Instance-&gt;CCR = tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//以上，只是配置了一些基础的，比如通道优先级，数据宽度，增量模式使能，方向等等。没有中断的使能，也没有开启dma通道</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialise the error code */</span></span><br><span class="line">  hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the DMA state*/</span></span><br><span class="line">  hdma-&gt;State = HAL_DMA_STATE_READY;</span><br><span class="line">  <span class="comment">/* Allocate lock resource and initialize it */</span></span><br><span class="line">  hdma-&gt;Lock = HAL_UNLOCKED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，HAL_DMA_Init(),也仅仅只是<strong>配置了基础的功能参数</strong>，比如通道优先级，数据宽度，增量模式使能，方向等等。没有中断的使能，也没有开启dma通道</p><p>下面看看绑定DMA1_CH4 和uart1_tx</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__HAL_LINKDMA(&amp;g_uart1_handle,hdmatx, hdma);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \</span></span><br><span class="line"><span class="meta">                    do&#123;                                                      \</span></span><br><span class="line"><span class="meta">                          (__HANDLE__)-&gt;__PPP_DMA_FIELD__ = &amp;(__DMA_HANDLE__); \</span></span><br><span class="line"><span class="meta">                          (__DMA_HANDLE__).Parent = (__HANDLE__);             \</span></span><br><span class="line"><span class="meta">                      &#125; while(0U)</span></span><br></pre></td></tr></table></figure><p>第一个参数是uart1的句柄地址，参数2是参数名字，参数3是dma的句柄对象。</p><blockquote><p>注意，这个是宏函数，不是函数，所以不用担心临时变量地址问题</p></blockquote><p>里面的内容就是：</p><ol><li>uart1对象的参数2 赋值为 dma的句柄地址</li><li>dma对象的parent指针，指向</li></ol><p>至此，dma1 ch4的初始化，就结束了，之后，调用 <code>HAL_UART_Transmit_DMA</code> 来让dma代替cpu读取内存，拷贝到uart_tx 的 db，然后发送出去。</p><p>在hal库的uart驱动里面，可以看到这里的注释，有教你如何使用uart串口驱动，以及如何使用dma进行发送接收</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The UART HAL driver can be used as follows:</span><br><span class="line"></span><br><span class="line">(#) Declare a UART_HandleTypeDef handle <span class="title function_">structure</span> <span class="params">(eg. UART_HandleTypeDef huart)</span>.</span><br><span class="line"><span class="params">(#)</span> Initialize the UART low level resources by implementing the <span class="title function_">HAL_UART_MspInit</span><span class="params">()</span> API:</span><br><span class="line">    <span class="params">(##)</span> Enable the USARTx interface clock.</span><br><span class="line">    <span class="params">(##)</span> UART pins configuration:</span><br><span class="line">        <span class="params">(+++)</span> Enable the clock <span class="keyword">for</span> the UART GPIOs.</span><br><span class="line">        <span class="params">(+++)</span> Configure these UART <span class="title function_">pins</span> <span class="params">(TX as alternate function pull-up, RX as alternate function Input)</span>.</span><br><span class="line">    <span class="params">(##)</span> NVIC configuration <span class="keyword">if</span> you need to use interrupt <span class="title function_">process</span> <span class="params">(HAL_UART_Transmit_IT()</span></span><br><span class="line"><span class="params">         and HAL_UART_Receive_IT() APIs)</span>:</span><br><span class="line">        <span class="params">(+++)</span> Configure the USARTx interrupt priority.</span><br><span class="line">        <span class="params">(+++)</span> Enable the NVIC USART IRQ handle.</span><br><span class="line">    <span class="params">(##)</span> DMA Configuration <span class="keyword">if</span> you need to use DMA <span class="title function_">process</span> <span class="params">(HAL_UART_Transmit_DMA()</span></span><br><span class="line"><span class="params">         and HAL_UART_Receive_DMA() APIs)</span>:</span><br><span class="line">        <span class="params">(+++)</span> Declare a DMA handle structure <span class="keyword">for</span> the Tx/Rx channel.</span><br><span class="line">        <span class="params">(+++)</span> Enable the DMAx interface clock.</span><br><span class="line">        <span class="params">(+++)</span> Configure the declared DMA handle structure with the required</span><br><span class="line">              Tx/Rx parameters.</span><br><span class="line">        <span class="params">(+++)</span> Configure the DMA Tx/Rx channel.</span><br><span class="line">        <span class="params">(+++)</span> Associate the initialized DMA handle to the UART DMA Tx/Rx handle.</span><br><span class="line">        <span class="params">(+++)</span> Configure the priority and enable the NVIC <span class="keyword">for</span> the transfer complete</span><br><span class="line">              interrupt on the DMA Tx/Rx channel.</span><br><span class="line">        <span class="params">(+++)</span> Configure the USARTx interrupt priority and enable the NVIC USART IRQ <span class="title function_">handle</span></span><br><span class="line">              <span class="params">(used <span class="keyword">for</span> last byte sending completion detection in DMA non circular mode)</span></span><br><span class="line"></span><br><span class="line"><span class="params">(#)</span> Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware</span><br><span class="line">    flow control and <span class="title function_">Mode</span><span class="params">(Receiver/Transmitter)</span> in the huart Init structure.</span><br><span class="line"></span><br><span class="line"><span class="params">(#)</span> For the UART asynchronous mode, initialize the UART registers by calling</span><br><span class="line">    the <span class="title function_">HAL_UART_Init</span><span class="params">()</span> API.</span><br><span class="line"></span><br><span class="line"><span class="params">(#)</span> For the UART Half duplex mode, initialize the UART registers by calling</span><br><span class="line">    the <span class="title function_">HAL_HalfDuplex_Init</span><span class="params">()</span> API.</span><br><span class="line"></span><br><span class="line"><span class="params">(#)</span> For the LIN mode, initialize the UART registers by calling the <span class="title function_">HAL_LIN_Init</span><span class="params">()</span> API.</span><br><span class="line"></span><br><span class="line"><span class="params">(#)</span> For the Multi-Processor mode, initialize the UART registers by calling</span><br><span class="line">    the <span class="title function_">HAL_MultiProcessor_Init</span><span class="params">()</span> API.</span><br></pre></td></tr></table></figure><p>这里有对dma相关的串口api进行汇总</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(#) Non-Blocking mode API<span class="string">&#x27;s with DMA are :</span></span><br><span class="line"><span class="string">    (+) HAL_UART_Transmit_DMA()</span></span><br><span class="line"><span class="string">    (+) HAL_UART_Receive_DMA()</span></span><br><span class="line"><span class="string">    (+) HAL_UART_DMAPause()</span></span><br><span class="line"><span class="string">    (+) HAL_UART_DMAResume()</span></span><br><span class="line"><span class="string">    (+) HAL_UART_DMAStop()</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>下面我们来逐一分析一下</p><p><code>HAL_UART_Transmit_DMA</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check that a Tx process is not already ongoing */</span></span><br><span class="line">  <span class="keyword">if</span> (huart-&gt;gState == HAL_UART_STATE_READY)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pData == <span class="literal">NULL</span>) || (Size == <span class="number">0U</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process Locked */</span></span><br><span class="line">    __HAL_LOCK(huart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好要发送的字符串的内存起始地址，以及要发送的字节数</span></span><br><span class="line">    huart-&gt;pTxBuffPtr = pData;</span><br><span class="line">    huart-&gt;TxXferSize = Size;</span><br><span class="line">    huart-&gt;TxXferCount = Size;</span><br><span class="line"></span><br><span class="line">    huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;</span><br><span class="line">    huart-&gt;gState = HAL_UART_STATE_BUSY_TX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好uart dma发送完成回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferCpltCallback = UART_DMATransmitCplt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好uart dma发送一半完成回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferHalfCpltCallback = UART_DMATxHalfCplt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好 dma错误 回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferErrorCallback = UART_DMAError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好 dma终止 回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferAbortCallback = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable the UART transmit DMA channel */</span></span><br><span class="line">    <span class="comment">//用dma的驱动，开始发送这个内存区域</span></span><br><span class="line">    tmp = (<span class="type">uint32_t</span> *)&amp;pData;</span><br><span class="line">    HAL_DMA_Start_IT(huart-&gt;hdmatx, *(<span class="type">uint32_t</span> *)tmp, (<span class="type">uint32_t</span>)&amp;huart-&gt;Instance-&gt;DR, Size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear the TC flag in the SR register by writing 0 to it */</span></span><br><span class="line">    <span class="comment">//清除串口的TC标志位（传输完成标志位）</span></span><br><span class="line">    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process Unlocked */</span></span><br><span class="line">    __HAL_UNLOCK(huart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable the DMA transfer for transmit request by setting the DMAT bit</span></span><br><span class="line"><span class="comment">       in the UART CR3 register */</span></span><br><span class="line">    <span class="comment">//置1，使用uart1的CR3的DMAT位。</span></span><br><span class="line">    SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HAL_OK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_BUSY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先关注绑定的几个回调函数：</p><ol><li>hdmatx-&gt;XferCpltCallback &#x3D; UART_DMATransmitCplt;<ol><li>指定好uart dma发送完成回调函数</li></ol></li><li>hdmatx-&gt;XferHalfCpltCallback &#x3D; UART_DMATxHalfCplt;<ol><li>指定好uart dma发送一半完成回调函数</li></ol></li><li>hdmatx-&gt;XferErrorCallback &#x3D; UART_DMAError;<ol><li>指定好 dma错误 回调函数</li></ol></li><li>hdmatx-&gt;XferAbortCallback &#x3D; NULL;<ol><li>指定好 dma终止 回调函数</li></ol></li></ol><p>我们先来看看这几个回调函数的内容，因为你后面使能了这几个中断后，就会触发他们的回调</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel <span class="number">4</span></span><br></pre></td></tr></table></figure><p>可以看到，是有DMA1—CH4的中断向量的</p><p>下面分别看一下，这些中断的回调函数：</p><p><code>UART_DMATransmitCplt</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UART_DMATransmitCplt</span><span class="params">(DMA_HandleTypeDef *hdma)</span></span><br><span class="line">&#123;</span><br><span class="line">  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)-&gt;Parent;</span><br><span class="line">  <span class="comment">/* DMA Normal mode*/</span></span><br><span class="line">  <span class="keyword">if</span> ((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == <span class="number">0U</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    huart-&gt;TxXferCount = <span class="number">0x00U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable the DMA transfer for transmit request by setting the DMAT bit</span></span><br><span class="line"><span class="comment">       in the UART CR3 register */</span></span><br><span class="line">    CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable the UART Transmit Complete Interrupt */</span></span><br><span class="line">    SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* DMA Circular mode */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">    <span class="comment">/*Call registered Tx complete callback*/</span></span><br><span class="line">    huart-&gt;TxCpltCallback(huart);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/*Call legacy weak Tx complete callback*/</span></span><br><span class="line">    HAL_UART_TxCpltCallback(huart);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_HAL_UART_REGISTER_CALLBACKS */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，已经有定义了，然后留了一个 HAL_UART_TxCpltCallback(huart)来让你自己定义</p><p>剩下的也都一样。</p><p>接下来里面有两个比较重要的，<code>HAL_DMA_Start_IT</code> 和 <code>SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT)</code></p><p><code>HAL_DMA_Start_IT</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Start the DMA Transfer with interrupt enabled.</span></span><br><span class="line"><span class="comment">  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains</span></span><br><span class="line"><span class="comment">  *               the configuration information for the specified DMA Channel.</span></span><br><span class="line"><span class="comment">  * @param  SrcAddress: The source memory Buffer address</span></span><br><span class="line"><span class="comment">  * @param  DstAddress: The destination memory Buffer address</span></span><br><span class="line"><span class="comment">  * @param  DataLength: The length of data to be transferred from source to destination</span></span><br><span class="line"><span class="comment">  * @retval HAL status</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_DMA_Start_IT</span><span class="params">(DMA_HandleTypeDef *hdma, <span class="type">uint32_t</span> SrcAddress, <span class="type">uint32_t</span> DstAddress, <span class="type">uint32_t</span> DataLength)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_StatusTypeDef status = HAL_OK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_DMA_BUFFER_SIZE(DataLength));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Process locked */</span></span><br><span class="line">  __HAL_LOCK(hdma);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(HAL_DMA_STATE_READY == hdma-&gt;State)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Change DMA peripheral state */</span></span><br><span class="line">    hdma-&gt;State = HAL_DMA_STATE_BUSY;</span><br><span class="line">    hdma-&gt;ErrorCode = HAL_DMA_ERROR_NONE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Disable the peripheral */</span></span><br><span class="line">    __HAL_DMA_DISABLE(hdma);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Configure the source, destination address and the data length &amp; clear flags*/</span></span><br><span class="line">    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Enable the transfer complete interrupt */</span></span><br><span class="line">    <span class="comment">/* Enable the transfer Error interrupt */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != hdma-&gt;XferHalfCpltCallback)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Enable the Half transfer complete interrupt as well */</span></span><br><span class="line">      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);</span><br><span class="line">      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Enable the Peripheral */</span></span><br><span class="line">    __HAL_DMA_ENABLE(hdma);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;      </span><br><span class="line">    <span class="comment">/* Process Unlocked */</span></span><br><span class="line">    __HAL_UNLOCK(hdma); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remain BUSY */</span></span><br><span class="line">    status = HAL_BUSY;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下这个函数的内容：</p><ol><li>__HAL_DMA_DISABLE(hdma)<ol><li>设置DMA-&gt;CCR的EN位为0</li></ol></li><li>DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength)<ol><li>主要就是设置DMA_CH4-&gt;CPAR里面，记录下源地址，目的地址（之前只是指定了dma的工作方式，没有具体的任务内容）</li></ol></li><li>判断如果指定了传输一半完成的回调函数（确实是已经指定了的）<ol><li>__HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE))，就把支持的3个中断全部使能</li></ol></li><li>__HAL_DMA_ENABLE(hdma)<ol><li>设置DMA-&gt;CCR的EN位为1</li></ol></li></ol><p>简单说就是：</p><ol><li>告诉dma实际要进行拷贝的内存地址</li><li>开中断</li><li>使能dmaEN，开始工作</li></ol><p>确实如<code>HAL_DMA_Start_IT</code>命名那样，<code>开中断模式</code><strong>开始工作</strong>。</p><p>接下来分析串口dma发送的最后一句：</p><p><code>SET_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT)</code></p><p>设置的值如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CR3_DMAT_Pos                  (7U)                               </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CR3_DMAT_Msk                  (0x1UL &lt;&lt; USART_CR3_DMAT_Pos)       <span class="comment">/*!&lt; 0x00000080 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART_CR3_DMAT                      USART_CR3_DMAT_Msk                 <span class="comment">/*!&lt; DMA Enable Transmitter */</span></span></span><br></pre></td></tr></table></figure><p>再看看uart的CR3寄存器<br><img src="/../images/28.11.png" alt="alt text"></p><p>可以看到，他就是使能了UART1的CR3的这个DMAT位，串口硬件就可以开始使用DMA进行发送了。</p><blockquote><p>并不是我想的那样，得用软件来告诉串口怎么用dma，人家<strong>串口硬件已经支持dma了</strong>，你直接使能，他就知道用这个来发送了。</p></blockquote><p>对比一下原来，串口单独发送的场景，还记得吗：</p><ol><li>阻塞发送：<ol><li>真的让cpu在while里面，不停的拷贝字节到uart1-&gt;DB</li></ol></li><li>非阻塞发送<ol><li>HAL_UART_Transmit_IT里面，只是使能了发送空中断。</li></ol></li></ol><blockquote><p>所以，所谓的驱动，只是用来<strong>开启硬件原本就有的功能</strong>，不是让你用软件来实现原本硬件没有的功能</p></blockquote><p>至此，串口的DMA发送，就已经分析完毕了。</p><p>那为什么我在main.c里面，指定串口传输完成回调函数，但是没有进入这个回调函数呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//HAL_UART_Transmit_DMA(huart, (uint8_t*)send_buffer, sizeof(send_buffer));</span></span><br><span class="line">   LED1_TOGGLE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因在于，之前，<code>HAL_UART_Transmit_DMA</code>里面，指定了dma的回调函数，然后确实是<strong>打开了dma的3个中断</strong>。但是<strong>没有使能串口的中断</strong>。</p><p>所以当dma完成传输后，会先进入dma的<code>XferCpltCallback</code>回调函数，也就是<code>UART_DMATransmitCplt</code>.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_UART_Transmit_DMA</span><span class="params">(UART_HandleTypeDef *huart, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好uart dma发送完成回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferCpltCallback = UART_DMATransmitCplt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好uart dma发送一半完成回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferHalfCpltCallback = UART_DMATxHalfCplt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好 dma错误 回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferErrorCallback = UART_DMAError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定好 dma终止 回调函数</span></span><br><span class="line">    huart-&gt;hdmatx-&gt;XferAbortCallback = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>UART_DMATransmitCplt</code>里面，你看注释，发现，如果我们的dma使用的是normal模式，则会使能串口传输完成中断，而不是进入你实现的<code>HAL_UART_TxCpltCallback(huart)</code>;</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UART_DMATransmitCplt</span><span class="params">(DMA_HandleTypeDef *hdma)</span></span><br><span class="line">&#123;</span><br><span class="line">  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)-&gt;Parent;</span><br><span class="line">  <span class="comment">/* DMA Normal mode*/</span></span><br><span class="line">  <span class="keyword">if</span> ((hdma-&gt;Instance-&gt;CCR &amp; DMA_CCR_CIRC) == <span class="number">0U</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    huart-&gt;TxXferCount = <span class="number">0x00U</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disable the DMA transfer for transmit request by setting the DMAT bit</span></span><br><span class="line"><span class="comment">       in the UART CR3 register */</span></span><br><span class="line">    CLEAR_BIT(huart-&gt;Instance-&gt;CR3, USART_CR3_DMAT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Enable the UART Transmit Complete Interrupt */</span></span><br><span class="line">    SET_BIT(huart-&gt;Instance-&gt;CR1, USART_CR1_TCIE);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* DMA Circular mode */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_UART_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">    <span class="comment">/*Call registered Tx complete callback*/</span></span><br><span class="line">    huart-&gt;TxCpltCallback(huart);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/*Call legacy weak Tx complete callback*/</span></span><br><span class="line">    HAL_UART_TxCpltCallback(huart);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_HAL_UART_REGISTER_CALLBACKS */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，最终触发的逻辑是：dma完成中断-&gt;dma完成回调-&gt;使能串口传输完成中断-&gt;串口传输完成回调</p><p>但是我如果实现了串口的接收中断回调函数，发现还是没有进入，所以得需要进入看看串口的中断回调函数具体干了些什么：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_IRQHandler</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>终于发现问题了，因为串口中断的触发，需要dma的中断的触发，这就需要NVIC都要打开各自的中断使能，这样才能响应。</p></blockquote><p>所以最终需要在DMA1_Init()里面，在初始化完成dma1ch4, 绑定完uart1后，需要使能NVIC中断。</p><p>所以涉及的外设（你忘记总结了）：</p><ol><li>DMA1_CH4</li><li>UART1</li><li>NVIC(dma + uart)</li></ol><p>所以，最后，总结一下修改的代码：<br><code>dma.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./BSP/DMA/dma.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DMA_HandleTypeDef hdma;</span><br><span class="line"><span class="keyword">extern</span> UART_HandleTypeDef g_uart1_handle;  <span class="comment">/* UART句柄 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dma1_init</span><span class="params">(DMA_Channel_TypeDef* DMAx_CHx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//enable dma</span></span><br><span class="line">    __HAL_RCC_DMA1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//init dma</span></span><br><span class="line">    <span class="comment">//hdma.Instance = (DMA_Channel_TypeDef   *)DMA1_BASE;</span></span><br><span class="line">hdma.Instance = DMAx_CHx;</span><br><span class="line">    hdma.Init.Direction = DMA_MEMORY_TO_PERIPH;</span><br><span class="line">  hdma.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">  hdma.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">  hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">  hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">  <span class="comment">//hdma.Init.Mode = DMA_NORMAL;</span></span><br><span class="line">hdma.Init.Mode = DMA_CIRCULAR;</span><br><span class="line">  hdma.Init.Priority = DMA_PRIORITY_HIGH;</span><br><span class="line"></span><br><span class="line">    hdma.DmaBaseAddress = (DMA_TypeDef            *)DMA1_BASE;</span><br><span class="line">    <span class="comment">//hdma.ChannelIndex = channel;</span></span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(&amp;g_uart1_handle,hdmatx, hdma);</span><br><span class="line">    HAL_DMA_Init(&amp;hdma);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 HAL_UART_MspInit 或类似位置 */</span></span><br><span class="line">HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, <span class="number">3</span>, <span class="number">0</span>); <span class="comment">// DMA中断</span></span><br><span class="line">HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA1_Channel4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_DMA_IRQHandler(&amp;hdma); <span class="comment">// 必须调用，这才会触发 UART_DMATransmitCplt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> lcd_id[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">    HAL_Init();                                         <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">    sys_stm32_clock_init(RCC_PLL_MUL9);                 <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                                     <span class="comment">/* 延时初始化 */</span></span><br><span class="line">    usart_init(<span class="number">115200</span>);                                 <span class="comment">/* 串口初始化为115200 */</span></span><br><span class="line">    led_init();                                         <span class="comment">/* 初始化LED */</span></span><br><span class="line">    lcd_init();                                         <span class="comment">/* 初始化LCD */</span></span><br><span class="line"></span><br><span class="line">    dma1_init((DMA_Channel_TypeDef* )DMA1_Channel4_BASE);</span><br><span class="line"></span><br><span class="line">    g_point_color = RED;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)lcd_id, <span class="string">&quot;LCD ID:%04X&quot;</span>, lcddev.id);  <span class="comment">/* 将LCD ID打印到lcd_id数组 */</span></span><br><span class="line">HAL_UART_Transmit_DMA(&amp;g_uart1_handle, (<span class="type">uint8_t</span>*)send_buffer, <span class="keyword">sizeof</span>(send_buffer));</span><br><span class="line"><span class="comment">//HAL_UART_Transmit_IT(&amp;g_uart1_handle, (uint8_t*)send_buffer, sizeof(send_buffer));</span></span><br><span class="line"><span class="comment">//HAL_UART_Transmit(&amp;g_uart1_handle, (uint8_t*)send_buffer, sizeof(send_buffer), 1000);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        delay_ms(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == USART_UX)                    <span class="comment">/* 如果是串口1 */</span></span><br><span class="line">    &#123;</span><br><span class="line">LED1_TOGGLE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_TxHalfCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (huart-&gt;Instance == USART_UX)                    <span class="comment">/* 如果是串口1 */</span></span><br><span class="line">    &#123;</span><br><span class="line">LED0_TOGGLE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果开启了dma按照<strong>循环模式</strong>进行发送，那么之后，如果在<strong>主程序中printf</strong>，就会让cpu一直while<strong>循环等待uart tx 的 SR</strong>寄存器发送完成。结果就一直卡在这里。</p><p>所以我想问问，如果开启dma循环模式后，就没有办法释放dma对uart tx的控制权吗，cpu永远也无法等到可以发送吗?</p><p>答案是是的</p><blockquote><p>在循环模式下，DMA 处于“永远在线”状态。只要串口的发送缓冲区空了（TXE 置位），DMA 硬件就会立刻检测到并把内存里的下一个字节塞进串口。</p></blockquote><h4 id="多个打印源（环形缓冲区）"><a href="#多个打印源（环形缓冲区）" class="headerlink" title="多个打印源（环形缓冲区）"></a>多个打印源（环形缓冲区）</h4><p>所以当有多个打印输出源的时候，<strong>最佳的做法</strong>是：</p><p><strong>软件环形缓冲区</strong>（最高级）</p><p>不直接使用 HAL 的 Transmit。</p><p><strong>建立一个足够大的全局数组作为环形缓冲区</strong>。</p><p>printf 只管把数据往缓冲区里写（通过 sprintf）。</p><p>DMA 在 <strong>Normal 模式</strong>下，每次只负责把缓冲区里的现有数据发出去。</p><p>发送完成后，在<strong>回调函数里检查缓冲区是否还有新数据</strong>，如果有，继续发。</p><h3 id="dma-uart-（最高效接收方案）"><a href="#dma-uart-（最高效接收方案）" class="headerlink" title="dma + uart （最高效接收方案）"></a>dma + uart （最高效接收方案）</h3><p>简单的“字节中断接收”在处理高频、大量数据时会让 CPU 疲于奔命</p><p>而 <code>DMA</code> + <code>uart空闲中断（IDLE）</code> 的组合则是嵌入式开发中处理不定长数据的“黄金标准”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">* @param  __INTERRUPT__ specifies the UART interrupt source to enable.</span><br><span class="line">*          This parameter can be one of the following values:</span><br><span class="line">*            @arg UART_IT_CTS:  CTS change interrupt</span><br><span class="line">*            @arg UART_IT_LBD:  LIN Break detection interrupt</span><br><span class="line">*            @arg UART_IT_TXE:  Transmit Data Register empty interrupt</span><br><span class="line">*            @arg UART_IT_TC:   Transmission complete interrupt</span><br><span class="line">*            @arg UART_IT_RXNE: Receive Data <span class="keyword">register</span> not empty interrupt</span><br><span class="line">*            @arg UART_IT_IDLE: Idle line detection interrupt</span><br><span class="line">*            @arg UART_IT_PE:   Parity Error interrupt</span><br><span class="line">*            @arg UART_IT_ERR:  Error <span class="title function_">interrupt</span><span class="params">(Frame error, noise error, overrun error)</span></span><br></pre></td></tr></table></figure><p><strong>核心矛盾</strong>：DMA 的“盲目性” vs. 数据的“随机性”</p><p><code>DMA 的本性</code>：DMA 像是一个只管搬运的苦力。你告诉它“搬 100 个字节”，它就乖乖搬 100 个。只有当搬满 100 个时，它才会通过中断告诉你“我干完了”。</p><p><code>不定长数据的挑战</code>：如果<strong>对方只发了 20 个字节就停</strong>了，DMA 还在傻傻地等剩下的 80 个。这时候 CPU 如果不去干预，数据就会一直躺在缓冲区里，你的程序也就无法处理这 20 个字节。</p><blockquote><p>因为本质上，我们指定dma接收，发送，都是<strong>定长</strong>，收满，发满，才能触发dma传输完成中断</p></blockquote><p><strong>解决方案</strong>：IDLE（串口空闲中断）</p><p>为了解决这个问题，STM32 硬件提供了一个非常有用的特性：<code>IDLE 线检测</code>。</p><p><code>原理</code>：当串口接收总线在接收完最后一个数据后，如果<code>持续出现一个字节的时间没有数据信号</code>，硬件会自动将 USART_<code>SR</code> 寄存器中的 <code>IDLE 位置 1</code>。</p><p><code>作用</code>：它相当于给 DMA 搬运工配了一个“监工”。如果<code>数据流断了</code>（代表一帧数据发完了），IDLE 中断就会触发，叫醒 CPU 来收货。</p><p><strong>实现方案</strong>：</p><p>“DMA + IDLE” 的工作流程这是面试中需要答出的标准流程：</p><ul><li><code>初始化</code>：配置串口 DMA 接收为 Normal 模式，设置一个足够大的缓冲区（比如 100 字节），并开启串口的 IDLE 中断。</li><li><code>数据传输</code>：数据开始发送，DMA 自动将数据从串口寄存器搬运到内存缓冲区。此时 CPU 完全不参与。</li><li><code>触发中断</code>：对方发送了 30 个字节后停止。串口检测到线路空闲，触发 IDLE 中断。</li><li><code>计算长度</code>：<ul><li>在 IDLE 中断服务函数中，CPU 停止 DMA 传输。</li><li>关键点：读取 DMA 寄存器中的 CNDTR（当前要传输的数目）。</li><li>计算公式：$接收长度 &#x3D; 总缓冲区大小 - CNDTR$。</li></ul></li><li><code>数据处理</code>：根据计算出的长度处理缓冲区数据。</li><li><code>重启</code>：清除 IDLE 标志位，重置 DMA 计数器，开启下一次接收</li></ul><h5 id="3种接收不定长数据的情况"><a href="#3种接收不定长数据的情况" class="headerlink" title="3种接收不定长数据的情况"></a>3种接收不定长数据的情况</h5><p>假设dma缓冲区，接收定长100字节</p><ol><li>正常情况（接收数据，有间隔，第一帧10字节，隔了一会，第二帧20字节）<ul><li>使用IDLE空闲中断来接收。</li></ul></li><li>粘包情况（两帧间隔太短，触发不了IDLE中断）<ul><li>软件协议帧封装</li></ul></li><li>溢出情况（接收的数据源源不断，又很紧凑，cpu总是要等dma收满才能进行处理，容易出现数据覆盖和cpu等待）<ul><li>TC + HC 中断，形成双缓冲区。HC触发，前50个字节满了，cpu读前半段内存，dma接着写后半段内存。TC触发，后50个字节满，cpu读后半段，DMA接着写前半段。</li></ul></li></ol><p><strong>情景分析</strong>：</p><p><code>高速</code>、<code>流数据型</code>（如 921600 波特率以上，传感器每秒发几百次数据）</p><p>在高频采样中，<code>总线几乎是满载</code>的，字<code>节间的空隙</code>极短，IDLE 很难稳定触发。这时候，必须使用“HT + TC + 协议解析”的组合。</p><p>请你详细解释一下这个场景，DMA要循环模式是吗，就是不能由CPU来控制了，这样的话，一旦触发HC，CPU在hc中断里面，立刻迅速把前半段缓冲区拷贝出来，放到外面处理，此时DMA还在写后半段，触发TC中断，cpu在中断中立刻把后半段缓冲区拷贝出来，DMA此时在写前半段，是吗？</p><p><strong>答案</strong>：</p><ol><li><strong>DMA必须是循环模式</strong></li></ol><ul><li>在高频（$921600 \text{ bps}$）下，关闭和重启 DMA 的那几个微秒时间差，就足以丢失几个字节的数据<ul><li><p><code>循环模式</code>：就像一个永不停歇的传送带。DMA 硬件自动回环，不需要 CPU 介入。</p></li><li><p><code>CPU 的角色</code>：不再是“指挥官”，而是“<code>搬运工</code>”。它只需要根据 HT（半满）和 TC（全满）这两个信号，在传送带的不同位置“卸货”。</p></li></ul></li></ul><ol start="2"><li><strong>速度竞赛</strong>：CPU 拷贝 vs. DMA 写入</li></ol><ul><li>你担心的“<code>CPU 拷贝速度</code>”问题，我们可以通过简单的数学计算来打消顾虑。<ul><li><code>DMA 写入速度</code>（以 $921600 \text{ bps}$ 为例）：串口是串行传输，每秒约 $92160 \text{ 字节}$。意味着每接收 <code>1 个字节</code> 大约需要 <code>10.8 微秒</code> ($\mu s$)。</li><li><code>CPU 拷贝速度</code>（以 STM32F1 72MHz 为例）：CPU 使用 memcpy 是并行总线操作。拷贝 <code>1 个字节</code> 只需要<code>几个时钟周期（纳秒级）</code>。</li></ul></li><li>结论：CPU 拷贝 $50 \text{ 字节}$ 可能只需要 $1 \text{-} 2 \mu s$，而 DMA 写满剩下的 $50 \text{ 字节}$ 需要大约 $540 \mu s$。CPU 的拷贝速度远超 DMA 的写入速度，这是方案成立的基础。</li></ul><ol start="3"><li><strong>处理和存储太慢怎么办</strong>？</li></ol><ul><li>（核心架构设计）这是最关键的问题。<ul><li>如果你的 TCN 模型推理或 <code>SD 卡存储</code>需要 $5 \text{ ms}$，而 DMA 每 $1 \text{ ms}$ 就填满一半缓冲区，直接在中断里处理肯定会炸掉（覆盖）。</li><li><code>解决方案</code>：构建“二级缓冲区”架构（生产者-消费者模型）你不能在 HT&#x2F;TC 中断里做任何“重体力活”。中断里只做一件极其简单的事：<strong>把数据丢进队列（Queue）</strong>。</li></ul></li></ul><p><strong>推荐的架构流程</strong>：</p><ul><li><code>一级缓存</code>（DMA Ring Buffer）：<ul><li>设置为 $100 \text{ 字节}$。</li><li>HT 中断触发：memcpy 前 $50 \text{ 字节}$ 到二级缓冲区。</li><li>TC 中断触发：memcpy 后 $50 \text{ 字节}$ 到二级缓冲区。</li></ul></li><li><code>二级缓存</code>（软件大队列&#x2F;Ring Buffer）：<ul><li>这是一个由软件维护的、大得多的数组（比如 $2048 \text{ 字节}$）。</li><li>中断里的 memcpy 只是<strong>把数据搬到这里</strong>，<strong>并更新“写指针”</strong>。</li></ul></li><li><code>主任务（消费者）</code>：<ul><li>在 while(1) 或 RTOS 任务中，不断<strong>检查二级缓存的“读指针”</strong>。</li><li>协议解析：在这里寻找帧头帧尾。</li><li>算法处理：在这里跑你的 TCN 模型或进行数据存储。</li></ul></li></ul><p><strong>这样设计的好处</strong>：</p><ul><li>削峰填谷：即使某次算法处理慢了（比如耗时 $2 \text{ ms}$），只要二级缓存足够大，它就能把这段时间内 DMA 产生的多帧数据“存”起来，等 CPU 忙完了再一口气处理掉，不会丢失任何数据。</li></ul><p><strong>总结你的逻辑</strong></p><ul><li><p>粘包：靠**二级缓存中的协议解析（帧头帧尾）**解决。</p></li><li><p>溢出：靠HT + TC 双缓冲保证硬件级不覆盖。</p></li><li><p>处理慢：靠更大的二级软件缓冲区 + 异步处理任务来缓冲压力。</p></li></ul><blockquote><p>在这种模式下，IDLE 中断反而成了“锦上添花”：如果数据流突然断了（对方停止发送），IDLE 中断能强行把当前还没填满半个缓冲区的那一丁点残余数据给“掏”出来处理。</p></blockquote><h3 id="dma-uart-（最高效发送方案）"><a href="#dma-uart-（最高效发送方案）" class="headerlink" title="dma + uart （最高效发送方案）"></a>dma + uart （最高效发送方案）</h3><p>前面讲了uart的接收，如何高效的实现。现在来分析，如果是发送，要<strong>如何实现高效的发送</strong>？</p><p>下面先解释几个概念：</p><ol><li><strong>Cache 一致性</strong></li></ol><p>简单来说，这是<strong>CPU</strong> 看到的”和“<strong>DMA</strong> <strong>看到的不一致</strong>导致的问题。</p><ul><li><code>Cache 的存在</code>：CPU 频率很高（比如 $72 \text{ MHz}$ 甚至 $480 \text{ MHz}$），但访问 SRAM 相对较慢。为了提速，CPU 内部有一个小而快的缓存（Cache）。CPU 读写数据时，会先在 Cache 里折腾，不一定立刻同步到 SRAM。</li><li><code>DMA 的视角</code>：DMA 是一个“外行”，它直接访问 SRAM，看不见 CPU 的 Cache。</li><li><code>冲突场景</code>：<ul><li>CPU 往 Buffer A 写了数据（其实只写到了 Cache 里）。</li><li>CPU 告诉 DMA：“去 SRAM 的 Buffer A 搬数据发出去”。</li><li>DMA 去了，但 SRAM 里的数据还是旧的。</li><li>结果：串口发出去的是一堆乱码或旧数据。</li></ul></li></ul><blockquote><p><strong>注意</strong>：你目前使用的 STM32F1 (Cortex-M3) 架构比较基础，没有 D-Cache（数据缓存），所以你感受不到这个问题。但如果你以后接触 STM32H7 (Cortex-M7) 或 <strong>Linux 驱动开发</strong>，这就是必须要处理的头等大事（需要调用 <strong>SCB_CleanDCache() 强制同步</strong>）。</p></blockquote><hr><ol start="2"><li><strong>既然已经用了 HC&#x2F;TC 乒乓机制，为什么还要锁</strong>？</li></ol><p>你设计的“HC 写前半段，TC 写后半段”在理论上非常完美，但它有一个<strong>前提</strong>：系统必须是绝对实时且单任务的。</p><p>在真实的多任务环境（比如 FreeRTOS）中，<strong>锁的作用</strong>是处理以下<strong>两种意外</strong>：</p><ul><li><strong>A. 任务竞争（多个生产者）</strong></li></ul><p>如果你的系统里有 <code>Task_Sensor</code> 和 <code>Task_Log</code> 都要发串口。</p><p><code>Task_Sensor</code> 正在往前半段写，写到一半，被优先级更高的 <code>Task_Log</code> 抢占了。<br>Task_Log 也往里面写。</p><p><strong>结果</strong>：数据乱套了。这时候需要一个 <code>Mutex（互斥锁）</code> 确保同一时间只有一个任务能操作缓冲区。</p><ul><li>B. <strong>“生产”慢于“消费”（溢出风险）</strong></li></ul><p>虽然你算过 CPU 拷贝比 DMA 快，但如果 CPU 被一个极其耗时的计算任务（比如你的 TCN 模型推理）卡住了：</p><p>DMA 发完了后半段（触发 TC），转头开始发前半段。</p><p>但此时 CPU 还没写完前半段！</p><p>结果：<strong>DMA 把写了一半的残缺数据发了出去</strong>。</p><p><code>锁的作用</code>：这时候需要一个 <strong>Semaphore（信号量）</strong>。DMA 发完一半后，必须等待 CPU 的“写完”信号；CPU 写完一半后，也得检查 DMA 是否已经腾出了位置。</p><hr><ol start="3"><li><strong>“零拷贝”如何在这个基础上实现？</strong></li></ol><p>你之前理解的“双缓冲”可能还是：传感器 -&gt; 临时变量 -&gt; memcpy 到 BufferA。这多了一次 <code>memcpy</code>。</p><p><strong>真正的零拷贝方案</strong>：<br><strong>不需要中间变量</strong>，直接让算法&#x2F;传感器驱动<strong>在 DMA 缓冲区内原地生产</strong>。</p><p><strong>获取地址</strong>：算法询问缓冲区管理器：“我现在可以往哪写？”</p><p><strong>直接写入</strong>：管理器返回 <code>BufferA 的起始地址</code>。算法直接执行：<code>p_buffer[0] = ADC_Value</code>;</p><p><strong>标记完成</strong>：算法写完后，告诉 DMA 搬运长度。</p><p>在这个过程中，数据从寄存器&#x2F;计算结果出来后，只<strong>经过一次赋值</strong>就到了 DMA 准备发送的位置，没有任何冗余的内存移动。</p><p>总结：</p><p>如果要用dma+uart来进行发送的最佳方案是：<br><strong>锁 + 零拷贝 + 双缓冲的最终形态</strong></p><p>我们可以用 FreeRTOS 的逻辑来构建这个系统</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> buffer[<span class="number">2</span>][<span class="number">128</span>]; <span class="comment">// 双缓冲</span></span><br><span class="line">    <span class="type">uint8_t</span> active_idx;     <span class="comment">// 当前 CPU 正在写的索引 (0 或 1)</span></span><br><span class="line">    SemaphoreHandle_t xSem; <span class="comment">// 同步信号量：DMA 发完了吗？</span></span><br><span class="line">    MutexHandle_t xLock;    <span class="comment">// 互斥锁：谁在用缓冲区？</span></span><br><span class="line">&#125; TX_System;</span><br></pre></td></tr></table></figure><p><strong>发送流程（零拷贝版）</strong>：</p><p><code>Take Mutex</code>：xSemaphoreTake(xLock)（确保没有其他任务在发）(只有我能写)。</p><p><code>获取指针</code>：target_ptr &#x3D; TX_System.buffer[TX_System.active_idx]。</p><p><code>原地生产</code>：sprintf(target_ptr, “Data:%d”, value);（直接写进 DMA 区）。</p><p><code>启动发送</code>：调用 HAL_UART_Transmit_DMA。</p><p><code>等待完成</code>：xSemaphoreTake(xSem)（任务阻塞，不占 CPU，等待 TC 中断唤醒）。</p><p><code>切换索引</code>：active_idx &#x3D; !active_idx。</p><p><code>Give Mutex</code>：xSemaphoreGive(xLock)。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>1. 数据接收 (RX)：追求“万无一失”</strong></p><p>你的逻辑核心是：<strong>硬件搬运 + 逻辑分包 + 异步处理</strong>。</p><ul><li><p><code>HC/TC 双缓冲区（乒乓缓冲）</code>：解决**“溢出”**。DMA 在写后半段时，CPU 处理前半段，反之亦然，实现 100% 的总线占空比。</p></li><li><p><code>IDLE 中断</code>：解决**“不定长”**。它是数据的“监工”，一旦对方发完停下了，立刻通知 CPU 别等了，赶紧收货。</p></li><li><p><code>二级缓存队列（Ring Buffer）</code>：解决**“处理慢”**。中断只负责“扔进筐里”，耗时的协议解析和算法（如扭矩估算）放到主循环或低优先级任务里慢慢跑。</p></li></ul><p><strong>2. 数据发送 (TX)：追求“极致效率”</strong></p><p>你的逻辑核心是：<strong>并发竞争控制 + 消除内存拷贝</strong>。</p><ul><li><p><code>锁（Mutex/Semaphore）</code>：解决冲突。确保在多任务（FreeRTOS）环境下，不会有两个任务同时抢占同一个 DMA 通道，避免数据乱序。</p></li><li><p><code>零拷贝（原地生产）</code>：解决CPU 损耗。数据直接在 DMA 能够触及的缓冲区里通过 sprintf 或结构体赋值产生，省去了从“用户缓存”搬运到“发送缓存”的 memcpy 耗时。</p></li><li><p><code>双缓冲区/发送队列</code>：解决等待延迟。在发 A 包的时候，CPU 已经在准备 B 包，发送过程永不停歇。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#stm32-dma&quot;&gt;stm32 dma&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#dma%E4%BB%8B%E7%BB%8D&quot;&gt;dma介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#dma%E8%B5%84%E6%BA%90&quot;&gt;dma</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 gpio*</title>
    <link href="http://example.com/2026/02/12/stm32-gpio/"/>
    <id>http://example.com/2026/02/12/stm32-gpio/</id>
    <published>2026-02-12T12:47:57.000Z</published>
    <updated>2026-02-20T13:51:20.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gpio"><a href="#gpio" class="headerlink" title="gpio"></a>gpio</h1><p>把gpio,当成是一个外设，重新再学习一遍</p><h2 id="stm32f1-gpio资源"><a href="#stm32f1-gpio资源" class="headerlink" title="stm32f1 gpio资源"></a>stm32f1 gpio资源</h2><p>STM32F103ZET6 芯片是 144 脚的芯片，</p><p>具有 GPIOA、GPIOB、GPIOC、GPIOD、GPIOE、GPIOF 和 GPIOG <strong>七组 GPIO 口</strong>，共有 112 个 IO 口可供我们编程使用</p><h2 id="IO-功能模式"><a href="#IO-功能模式" class="headerlink" title="IO 功能模式"></a>IO 功能模式</h2><p>GPIO 有八种工作模式，分别是：</p><h3 id="上下拉（输入）"><a href="#上下拉（输入）" class="headerlink" title="上下拉（输入）"></a>上下拉（输入）</h3><ol><li><strong>输入浮空</strong><ul><li>拉&#x2F;下拉电阻为断开状态</li><li>用于按键检测等场景</li></ul></li><li><strong>输入上拉</strong></li><li><strong>输入下拉</strong></li><li><strong>模拟输入</strong><ul><li>用于 ADC、DAC、MCO这类操作<code>模拟信号</code>的外设</li></ul></li></ol><p><img src="/../images/26.1.png" alt="alt text"></p><blockquote><p><strong>为什么要上下拉</strong>？（防止“漂移”）</p><p>简单来说，上下拉电阻的作用就是<strong>给引脚一个确定的默认状态</strong>，防止电路在悬空时受到电磁干扰</p></blockquote><h3 id="推挽开漏（输出、复用）"><a href="#推挽开漏（输出、复用）" class="headerlink" title="推挽开漏（输出、复用）"></a>推挽开漏（输出、复用）</h3><ol start="5"><li><p><strong>开漏输出</strong></p><ul><li>它只能输出低电平 Vss 或者高阻态，常用于 IIC 通讯（IIC_SDA）或其它需要进行电平转换的场景</li></ul></li><li><p><strong>推挽输出</strong></p><ul><li>会输出低电平 VSS 或者高电平VDD,驱动能力较强</li></ul></li><li><p><strong>开漏式复用功能</strong></p><ul><li>。当选择复用功能时，引脚的状态是<code>由对应的外设控制</code>，而不是输出数据寄存器</li></ul></li><li><p><strong>推挽式复用功能</strong></p></li></ol><blockquote><p>[!IMPORTANT]<br><strong>1. 必须用【推挽输出】 (Push-Pull)</strong></p></blockquote><p>当你需要引脚作为 <strong>“动力源”</strong> 或者 <strong>“高速信号源”</strong> 时。</p><ul><li><strong>驱动能力需求</strong>：如果你要直接驱动 LED、蜂鸣器、光耦，或者给某个模块供电。推挽输出在输出“1”时能提供稳定的电流，输出“0”时能强力吸收电流。</li><li><strong>高速通讯</strong>：比如 <strong>SPI 协议</strong>或 <strong>UART 串口</strong>。推挽输出的电平切换速度极快，边缘非常陡峭，能支持几十 MHz 的频率。</li><li><strong>简单驱动</strong>：控制继电器模块、驱动各种 LCD&#x2F;OLED 屏幕。</li></ul><hr><blockquote><p>[!IMPORTANT]<br><strong>2. 必须用【开漏输出】 (Open-Drain)</strong></p></blockquote><p>当你需要 <strong>“兼容性”</strong>、<strong>“安全性”</strong> 或者符合 <strong>“总线标准”</strong> 时。</p><p>A. <code>I2C 总线</code>（必须开漏）</p><p>I2C 协议规定了多个设备挂在同一根线上。如果用推挽，一旦两个芯片一个发高一个发低，就会<strong>直接短路烧毁</strong>。开漏模式下，大家只负责“拉低”或“松手”，即使同时动作也不会坏。</p><p>B. <code>电平转换（3.3V 控 5V）</code></p><p>STM32 内部最高只能出 3.3V。如果你要把信号给一个 5V 的老芯片（它可能规定 3.5V 以上才算高电平），推挽就没戏了。</p><ul><li><strong>做法</strong>：选开漏，外部接一个电阻拉到 5V。这样引脚“松手”时，电压就是 5V，完美解决。</li></ul><p>C. <code>“线与”逻辑</code>（报警&#x2F;中断线）</p><p>比如你有 5 个传感器，任何一个报警都要让单片机知道。</p><ul><li>你可以把它们的开漏输出全部连在一起。</li><li>只要有一个传感器报警（拉低），整条线就变低。这种简单的并联在推挽模式下是绝对禁止的。</li></ul><hr><blockquote><p>[!IMPORTANT]<br>当你面对一个 GPIO 输出配置时，按顺序问自己这三个问题：</p></blockquote><ol><li><strong>这是一根通讯总线吗？</strong></li></ol><ul><li>是 I2C 吗？  <strong>开漏</strong>。</li><li>是 SPI&#x2F;UART 吗？  <strong>推挽</strong>。</li></ul><ol start="2"><li><strong>这根线上会连着多个输出设备吗？</strong></li></ol><ul><li>是（比如共享中断信号线）  <strong>开漏</strong>。</li><li>否（一对一连接）  往下看。</li></ul><ol start="3"><li><strong>对方的电压和 STM32 一样吗？</strong></li></ol><ul><li>一样 (3.3V)  <strong>推挽</strong>。</li><li>对方更高 (5V)  <strong>开漏 + 外部上拉到 5V</strong>。</li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>在理解了IO的工作模式后，就知道要怎么用了，之后就是通过配置寄存器，来达成我们想要的工作模式。</p><p>所有的寄存器，简单来说，可以归结为：</p><ol><li>CR（控制寄存器）</li><li>DR（数据寄存器）</li><li>SR（状态寄存器）</li></ol><h3 id="CR"><a href="#CR" class="headerlink" title="CR"></a>CR</h3><ul><li>这 2 个配置寄存器就是用来配置 GPIO 的相<code>关工作模式</code>和<code>工作速度</code></li></ul><p><img src="/../images/26.2.png" alt="alt text"></p><h3 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h3><ul><li>这里就是输出的数据寄存器了，这里有两个，都可以进行写，具体会有区分，这些都属于具体的设备细节了，无需在意。</li></ul><p><img src="/../images/26.3.png" alt="alt text"></p><p><img src="/../images/26.4.png" alt="alt text"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>点灯实验，没什么好说的，比较简单，这里要注意一个通用的意识：</p><p><strong>初始化外设</strong>的步骤：</p><ol><li>使能设备（使能时钟）</li><li>配置外设寄存器（有定义外设基地址）</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 初始化 LED 相关 IO 口, 并使能时钟</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @retval 无</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LED0_GPIO_CLK_ENABLE(); <span class="comment">/* LED0 时钟使能 */</span></span><br><span class="line">    LED1_GPIO_CLK_ENABLE(); <span class="comment">/* LED1 时钟使能 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line">    gpio_init_struct.Pin = LED0_GPIO_PIN; <span class="comment">/* LED0 引脚 */</span></span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_OUTPUT_PP; <span class="comment">/* 推挽输出 */</span></span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLUP; <span class="comment">/* 上拉 */</span></span><br><span class="line">    gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH; <span class="comment">/* 高速 */</span></span><br><span class="line">    HAL_GPIO_Init(LED0_GPIO_PORT, &amp;gpio_init_struct); <span class="comment">/* 初始化 LED0 引脚 */</span></span><br><span class="line">    gpio_init_struct.Pin = LED1_GPIO_PIN; <span class="comment">/* LED1 引脚 */</span></span><br><span class="line">    HAL_GPIO_Init(LED1_GPIO_PORT, &amp;gpio_init_struct); <span class="comment">/* 初始化 LED1 引脚 */</span></span><br><span class="line">    LED0(<span class="number">1</span>); <span class="comment">/* 关闭 LED0 */</span></span><br><span class="line">    LED1(<span class="number">1</span>); <span class="comment">/* 关闭 LED1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gpio&quot;&gt;&lt;a href=&quot;#gpio&quot; class=&quot;headerlink&quot; title=&quot;gpio&quot;&gt;&lt;/a&gt;gpio&lt;/h1&gt;&lt;p&gt;把gpio,当成是一个外设，重新再学习一遍&lt;/p&gt;
&lt;h2 id=&quot;stm32f1-gpio资源&quot;&gt;&lt;a href=&quot;#st</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 sys层实现*</title>
    <link href="http://example.com/2026/02/12/stm32-sys%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2026/02/12/stm32-sys%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2026-02-12T11:02:21.000Z</published>
    <updated>2026-02-20T13:51:20.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sys层"><a href="#sys层" class="headerlink" title="sys层"></a>sys层</h1><p>这一层，主要剖析一下底层核心驱动函数, 基本上要访问一个系统的最小驱动就是这三个。</p><h2 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，stm32里面的delay 延时的编程思想：</p><p><code>CM3 内核</code>处理器，内部包含了<code>一个 SysTick 定时器</code></p><blockquote><p>SysTick 是一个 24 位的<strong>向下递减</strong>的计数定时器，当计数值减到 0 时，将从 RELOAD 寄存器中自动重装载定时初值，开始新一轮计数。只要不把它在 SysTick 控制及状态寄存器中的使能位清除，就永不停息</p></blockquote><p>所以，这里的delay延时，依赖我们的<strong>第一个外设</strong>：CM3内部的一个<strong>systick的定时器</strong>。</p><p>利用 <code>STM32的内部 SysTick</code> 来实现延时的，这样既<code>不占用中断</code>，也<code>不占用系统定时器</code>。</p><p>这里说的<strong>不占用中断</strong>的意思是<strong>不开定时器中断</strong>：</p><blockquote><p>SysTick 是内核外设，它确实有一个专属的异常向量（Exception），即 SysTick_Handler。但在实现 delay 函数时，市面上常见的做法（尤其是正点原子、野火等教程）确实是不开启中断的。</p></blockquote><p>这里不占用中断的意思是：<strong>不进入中断服务函数（ISR）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// startup.S 中，是有systick中断的处理函数的</span></span><br><span class="line">DCD     SysTick_Handler            ; SysTick Handler</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>ucos&#x2F;freertos 运行需要一个<strong>系统时钟节拍</strong>（类似“心跳”），而这个节拍是固定的（由 OS_TICKS_PER_SEC 宏定义设置），比如要求 <strong>5ms 一次</strong>。</p><p>一般是由 <strong>SysTick 来提供这个节拍</strong>，也就是 SysTick要设置为 <code>5ms 中断一次</code>，为 ucos 提供时钟节拍，而且这个时钟一般是不能被打断的（否则就不准了）。</p><blockquote><p>systick定时器，是一个外设，给定主频sysclk时钟，设置技术周期，就可以实现节拍中断</p></blockquote><p>当你实现了系统节拍定时中断后，systick 不能再被随意更改，如果我们还想利用 systick 来做 delay_us 或者 delay_ms 的延时，就必须想点办法了，这里我们利用的是<strong>时钟摘取法</strong>。</p><blockquote><p>delay_us 为例, </p><p><code>sysclk = 72Mhz</code>, 输入systick定时器，计数<code>分频</code>（1&#x2F;8）得到 <code>9Mhz的systick信号</code>。那么一个systick脉冲周期 &#x3D; （1&#x2F;9）us. </p><p>此时如果要delay_us(50), 一直统计 systick 的计数变化，直到数到（50 * 9）， 那么就是50us</p></blockquote><blockquote><p>优点：只是抓取 SysTick 计数器的变化，并不需要修改 SysTick 的任何状态，完全不影响 SysTick 作为 UCOS时钟节拍的功能</p><p>缺点：占用cpu</p></blockquote><h4 id="delay-init"><a href="#delay-init" class="headerlink" title="delay_init()"></a>delay_init()</h4><p>delay_init(72Mhz), 意味着，systick的输入是72Mhz，<strong>systick计数值减少72，经过1us</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                         <span class="comment">/* 延时初始化 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> g_fac_us = <span class="number">0</span>;       <span class="comment">/* us延时倍乘数 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// sysclk = 72 (Mhz), g_fac_us = 72,即数72下，算1us</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">uint16_t</span> sysclk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_SUPPORT_OS                                      <span class="comment">/* 如果需要支持OS */</span></span></span><br><span class="line">    <span class="type">uint32_t</span> reload;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    g_fac_us = sysclk;                                  <span class="comment">/* 由于在HAL_Init中已对systick做了配置，所以这里无需重新配置 */</span></span><br><span class="line">    <span class="comment">//g_fac_us = 72,即数72下，算1us, 1us时基计数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_SUPPORT_OS                                      <span class="comment">/* 如果需要支持OS. */</span></span></span><br><span class="line">    reload = sysclk;                                    <span class="comment">/* 每秒钟的计数次数 单位为M */</span></span><br><span class="line">    reload *= <span class="number">1000000</span> / delay_ostickspersec;            <span class="comment">/* 根据delay_ostickspersec设定溢出时间,reload为24位</span></span><br><span class="line"><span class="comment">                                                         * 寄存器,最大值:16777216,在168M下,约合0.09986s左右</span></span><br><span class="line"><span class="comment">                                                         */</span></span><br><span class="line">    g_fac_ms = <span class="number">1000</span> / delay_ostickspersec;              <span class="comment">/* 代表OS可以延时的最少单位 */</span></span><br><span class="line">    SysTick-&gt;CTRL |= <span class="number">1</span> &lt;&lt; <span class="number">1</span>;                            <span class="comment">/* 开启SYSTICK中断 */</span></span><br><span class="line">    SysTick-&gt;LOAD = reload;                             <span class="comment">/* 每1/delay_ostickspersec秒中断一次 */</span></span><br><span class="line">    SysTick-&gt;CTRL |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;                            <span class="comment">/* 开启SYSTICK */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delay-us"><a href="#delay-us" class="headerlink" title="delay_us()"></a>delay_us()</h4><blockquote><p>可见，是占用cpu资源的等待，不停的去读systick-&gt;val</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nus = 要延时多少us</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ticks;</span><br><span class="line">    <span class="type">uint32_t</span> told, tnow, tcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> reload = SysTick-&gt;LOAD;        <span class="comment">/* LOAD的值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要数多少节拍</span></span><br><span class="line">    ticks = nus * g_fac_us;                 <span class="comment">/* 需要的节拍数 */</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_SUPPORT_OS                          <span class="comment">/* 如果需要支持OS */</span></span></span><br><span class="line">    delay_osschedlock();                    <span class="comment">/* 锁定 OS 的任务调度器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    told = SysTick-&gt;VAL;                    <span class="comment">/* 刚进入时的计数器值 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow = SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span> (tnow != told)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tnow &lt; told)</span><br><span class="line">            &#123;</span><br><span class="line">                tcnt += told - tnow;        <span class="comment">/* 这里注意一下SYSTICK是一个递减的计数器就可以了 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcnt += reload - tnow + told;</span><br><span class="line">            &#125;</span><br><span class="line">            told = tnow;</span><br><span class="line">            <span class="keyword">if</span> (tcnt &gt;= ticks) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;                      <span class="comment">/* 时间超过/等于要延迟的时间,则退出 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SYS_SUPPORT_OS                          <span class="comment">/* 如果需要支持OS */</span></span></span><br><span class="line">    delay_osschedunlock();                  <span class="comment">/* 恢复 OS 的任务调度器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见，这种最基础的延时，就是不停的读systick的计数累计变化，来实现延时的。所以如果支持OS，他需要锁住调度。</p><p>当 OS 还未运行的时候，我们的 delay_ms 就是直接由 delay_us 实现的，OS 下的 delay_us<br>可以实现很长的延时（<strong>达到 53 秒</strong>）而不溢出！，所以放心的使用 delay_us 来实现 delay_ms，不<br>过由于 delay_us 的时候，任务调度被上锁了，所以还是建议不要用 delay_us 来延时很长的时间，否则影响整个系统的性能</p></blockquote><p>总结<br><img src="/../images/24.1.png" alt="alt text"></p><blockquote><p>在<strong>没有os</strong>的情况下，是<strong>不需要systick中断的</strong>，</p></blockquote><blockquote><p>但是如果<strong>有rtos</strong>，则必须要systick中断来提供系统节拍进行调度</p></blockquote><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p><code>sys_nvic_set_vector_table</code>()<br>设置中断向量表的偏移（VTOR）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       设置中断向量表偏移地址</span></span><br><span class="line"><span class="comment"> * @param       baseaddr: 基址</span></span><br><span class="line"><span class="comment"> * @param       offset: 偏移量(必须是0, 或者0X100的倍数)</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_nvic_set_vector_table</span><span class="params">(<span class="type">uint32_t</span> baseaddr, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 设置NVIC的向量表偏移寄存器,VTOR低9位保留,即[8:0]保留 */</span></span><br><span class="line">    SCB-&gt;VTOR = baseaddr | (offset &amp; (<span class="type">uint32_t</span>)<span class="number">0xFFFFFE00</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_stm32_clock_init</code>()<br>设置从时钟源到系统时钟sysclk，到所有外设总线时钟</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       系统时钟初始化函数</span></span><br><span class="line"><span class="comment"> * @param       plln: PLL倍频系数(PLL倍频), 取值范围: 2~16</span></span><br><span class="line"><span class="comment">                中断向量表位置在启动时已经在SystemInit()中初始化</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_stm32_clock_init</span><span class="params">(<span class="type">uint32_t</span> plln)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef ret = HAL_ERROR;</span><br><span class="line">    RCC_OscInitTypeDef rcc_osc_init = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    RCC_ClkInitTypeDef rcc_clk_init = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    rcc_osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;       <span class="comment">/* 选择要配置HSE */</span></span><br><span class="line">    rcc_osc_init.HSEState = RCC_HSE_ON;                         <span class="comment">/* 打开HSE */</span></span><br><span class="line">    rcc_osc_init.HSEPredivValue = RCC_HSE_PREDIV_DIV1;          <span class="comment">/* HSE预分频系数 */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLState = RCC_PLL_ON;                     <span class="comment">/* 打开PLL */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;             <span class="comment">/* PLL时钟源选择HSE */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLMUL = plln;                             <span class="comment">/* PLL倍频系数 */</span></span><br><span class="line">    ret = HAL_RCC_OscConfig(&amp;rcc_osc_init);                     <span class="comment">/* 初始化 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);                                              <span class="comment">/* 时钟初始化失败，之后的程序将可能无法正常执行，可以在这里加入自己的处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选中PLL作为系统时钟源并且配置HCLK,PCLK1和PCLK2*/</span></span><br><span class="line">    rcc_clk_init.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</span><br><span class="line">    rcc_clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;        <span class="comment">/* 设置系统时钟来自PLL */</span></span><br><span class="line">    rcc_clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;               <span class="comment">/* AHB分频系数为1 */</span></span><br><span class="line">    rcc_clk_init.APB1CLKDivider = RCC_HCLK_DIV2;                <span class="comment">/* APB1分频系数为2 */</span></span><br><span class="line">    rcc_clk_init.APB2CLKDivider = RCC_HCLK_DIV1;                <span class="comment">/* APB2分频系数为1 */</span></span><br><span class="line">    ret = HAL_RCC_ClockConfig(&amp;rcc_clk_init, FLASH_LATENCY_2);  <span class="comment">/* 同时设置FLASH延时周期为2WS，也就是3个CPU周期。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);                                              <span class="comment">/* 时钟初始化失败，之后的程序将可能无法正常执行，可以在这里加入自己的处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h2><p>这个单独一章节讲</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sys层&quot;&gt;&lt;a href=&quot;#sys层&quot; class=&quot;headerlink&quot; title=&quot;sys层&quot;&gt;&lt;/a&gt;sys层&lt;/h1&gt;&lt;p&gt;这一层，主要剖析一下底层核心驱动函数, 基本上要访问一个系统的最小驱动就是这三个。&lt;/p&gt;
&lt;h2 id=&quot;delay&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>freertos 基础实现</title>
    <link href="http://example.com/2026/02/08/freertos-1/"/>
    <id>http://example.com/2026/02/08/freertos-1/</id>
    <published>2026-02-08T09:26:23.000Z</published>
    <updated>2026-02-20T13:51:20.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Freertos-基础实现"><a href="#Freertos-基础实现" class="headerlink" title="Freertos 基础实现"></a>Freertos 基础实现</h1><h2 id="freertos-代码结构分析"><a href="#freertos-代码结构分析" class="headerlink" title="freertos 代码结构分析"></a>freertos 代码结构分析</h2><p><img src="/../images/21.1.png" alt="alt text"></p><h2 id="stm32中，freertos内存分布预览"><a href="#stm32中，freertos内存分布预览" class="headerlink" title="stm32中，freertos内存分布预览"></a>stm32中，freertos内存分布预览</h2><p>stm32f103zet6 rtos的内存分布</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ 高地址 (High Address) ]  <span class="number">0x2001</span> <span class="number">0000</span> (SRAM 结束/<span class="number">64</span>KB)</span><br><span class="line">          |</span><br><span class="line">          v</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          System <span class="title function_">Stack</span> <span class="params">(MSP)</span>              | &lt;--- 栈顶<span class="params">(Top)</span>, 向下生长 ↓</span><br><span class="line">| <span class="params">(用于中断服务 ISR、启动前的 main 函数)</span>      |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|                <span class="params">(空闲区)</span>                   |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|        FreeRTOS <span class="title function_">Heap</span> <span class="params">(ucHeap[])</span>          | &lt;--- 这里的管理是源码阅读重点</span><br><span class="line">|  +------------------------------------+  |</span><br><span class="line">|  | [空闲堆内存] <span class="params">(Free Heap Block)</span>      |  |</span><br><span class="line">|  +------------------------------------+  |</span><br><span class="line">|  | Task B <span class="title function_">Stack</span> <span class="params">(任务B栈)</span>              |  |</span><br><span class="line">|  | Task B <span class="title function_">TCB</span> <span class="params">(任务B控制块)</span>            |  |</span><br><span class="line">|  +------------------------------------+  |</span><br><span class="line">|  | Task A <span class="title function_">Stack</span> <span class="params">(任务A栈)</span>              |  |</span><br><span class="line">|  | Task A <span class="title function_">TCB</span> <span class="params">(任务A控制块)</span>            |  |</span><br><span class="line">|  +------------------------------------+  |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          .<span class="title function_">bss</span> <span class="params">(未初始化的全局变量)</span>         | &lt;--- 包括上面的 ucHeap 数组</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          .<span class="title function_">data</span> <span class="params">(已初始化的全局变量)</span>         |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">   [ 低地址 <span class="params">(Low Address)</span> ]   0x2000 0000 <span class="params">(SRAM 起始)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------- 物理分界线 <span class="params">(SRAM vs Flash)</span> -----------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   [ 高地址 <span class="params">(High Address)</span> ]  0x0808 0000 <span class="params">(Flash 结束/<span class="number">512</span>KB)</span></span><br><span class="line">          |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          .<span class="title function_">rodata</span> <span class="params">(只读常量)</span>               |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          .<span class="title function_">text</span> <span class="params">(程序代码/FreeRTOS源码)</span>     |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">|          Vector <span class="title function_">Table</span> <span class="params">(中断向量表)</span>        |</span><br><span class="line">+------------------------------------------+</span><br><span class="line">   [ 低地址 <span class="params">(Low Address)</span> ]   0x0800 0000 <span class="params">(Flash 起始)</span></span><br></pre></td></tr></table></figure><h2 id="前置知识-，CM3中断"><a href="#前置知识-，CM3中断" class="headerlink" title="(前置知识)，CM3中断"></a>(前置知识)，CM3中断</h2><p>rtos本质上是要依赖mcu的中断来实现的，所以有必要先复习一下cm3内核的中断相关的知识了。</p><blockquote><p><strong>中断</strong>是 CPU 的一种常见特性，中断一般由硬件产生，当中断发生后，会中断 CPU 当前正<br>在执行的程序而跳转到中断对应的服务程序种去执行</p><p>ARM Cortex-M 内核的 MCU 具有一个用于中断管理的嵌套向量中断控制器（<strong>NVIC</strong>，全称：Nested vectored interrupt controller）。</p></blockquote><p>STM32的NVIC 最多支持<strong>256个中断源</strong>（<code>16个系统中断</code> + <code>240个外部中断</code>）</p><p>(zet6只用到了10个系统中断 + 60个外部中断)</p><p><strong>1. 外部中断优先级配置</strong></p><p>NVIC这个外设，在芯片定义层的结构体定义：我们主要使用<code>IP</code>，来设置<code>外部中断优先级</code>，<strong>一共240个字节，刚好对应240个外部中断</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> __IOM <span class="type">uint32_t</span> ISER[<span class="number">8U</span>]; <span class="comment">/* 中断使能寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RESERVED0[<span class="number">24U</span>];</span><br><span class="line"> __IOM <span class="type">uint32_t</span> ICER[<span class="number">8U</span>]; <span class="comment">/* 中断除能寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RSERVED1[<span class="number">24U</span>];</span><br><span class="line"> __IOM <span class="type">uint32_t</span> ISPR[<span class="number">8U</span>]; <span class="comment">/* 中断使能挂起寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RESERVED2[<span class="number">24U</span>];</span><br><span class="line"> __IOM <span class="type">uint32_t</span> ICPR[<span class="number">8U</span>]; <span class="comment">/* 中断除能挂起寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RESERVED3[<span class="number">24U</span>];</span><br><span class="line"> __IOM <span class="type">uint32_t</span> IABR[<span class="number">8U</span>]; <span class="comment">/* 中断有效位寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RESERVED4[<span class="number">56U</span>];</span><br><span class="line"> __IOM <span class="type">uint8_t</span> IP[<span class="number">240U</span>]; <span class="comment">/* 中断优先级寄存器 */</span></span><br><span class="line"> <span class="type">uint32_t</span> RESERVED5[<span class="number">644U</span>];</span><br><span class="line"> __OM <span class="type">uint32_t</span> STIR; <span class="comment">/* 软件触发中断寄存器 */</span></span><br><span class="line">&#125; NVIC_Type;</span><br></pre></td></tr></table></figure><p>IP的每一个字节，对应一种外部中断的优先级，但是<strong>8位只用到了高4位</strong>（里面又可以<strong>再细分为抢占优先级+子优先级</strong>），一般设置成抢占式4位，子优先级不用，这样最简单。</p><p><strong>2. 系统中断优先级配置</strong></p><p><code>系统中断优先级配置</code>，由独立的<code>SHPR1、SHPR2、SHPR3</code>来进行配置，不是通过NVIC（因为不是嵌套嘛）。<br>里面，比较重要的就是<code>PendSV</code>中断和 <code>SysTick</code> 中断，<code>SVCall</code> 中断优先级</p><p><strong>3. 三个中断屏蔽寄存器</strong></p><ol><li>PRIMASK<ol><li>屏蔽除 NMI 和 HardFault 外的所有异常和中断，</li></ol></li><li>FAULTMASK <ol><li>屏蔽除 NMI 外的所有异常和中断</li></ol></li><li>BASEPRI<ol><li>中断优先级<code>低于</code> BASEPRI <code>阈值</code>的中断就都会被屏蔽掉</li></ol></li></ol><p>我们主要关注的是BASEPRI这个</p><blockquote><p>除了NMI 和 hardfault， reset这些中断是无法设置优先级的外</p><p>剩下的所有中断（系统中断（由CM3自己受理） + 外部中断（由st的NVIC受理）），他们对外都是一致的，<br>也就是都可以被上面3个屏蔽寄存器屏蔽。</p><p>也就意味着freertos可以通过设置systick中断+pendSV中断（系统中断）的优先级为15（最低），<br>同时设置阈值5-15为rtos可控制中断，在进入临界区的时候，就可以关中断+关闭任务调度了。</p></blockquote><p><strong>总结</strong>：</p><p><code>中断的“两个家族”</code></p><p>在 Cortex-M3 内核中，所有的中断统称为“异常（Exception）”，但管理上分为两派：</p><ul><li><p>系统异常 (System Exceptions)： 由 ARM 内核定义（如 <code>SVC</code>, <code>PendSV</code>, <code>SysTick</code>），由 <code>SCB </code>寄存器管理。</p></li><li><p>外部中断 (External Interrupts&#x2F;IRQs)： 由芯片厂家（如 ST）定义（如 UART, Timer, DMA），由 <code>NVIC</code> 寄存器管理。</p></li></ul><blockquote><p>统一规则： 无论属于哪个家族，优先级逻辑是通用的——数字越小，优先级越高。<strong>对外地位等价</strong></p></blockquote><p><code> 核心机制</code>：</p><ul><li>BASEPRI 与“围栏”BASEPRI 寄存器： 是 FreeRTOS 实现临界区保护的“秘密武器”。</li><li><strong>工作原理</strong>： 当 RTOS 进入临界区，会将 BASEPRI 设为 0x50。此时，硬件会自动屏蔽掉所有优先级 $\ge 5$ 的中断。</li><li>系统心脏： <strong>SysTick 和 PendSV 必须被设为最低优先级 (15)</strong>。这样它们永远不会打断硬件中断。它们在临界区内会<strong>被一起屏蔽</strong>，保证任务切换时内核数据（如就绪列表）的绝对安全。</li><li>API 调用禁区： 如果在 0-4 级中断里调用了 API，会破坏 RTOS 内部链表的原子性，导致系统崩溃（通常卡在 configASSERT）。</li></ul><h2 id="A-freertos-中断配置"><a href="#A-freertos-中断配置" class="headerlink" title="A. freertos 中断配置"></a>A. freertos 中断配置</h2><p>根据freertos的框图架构，可以看出，freertos，利用NVIC和SHPR寄存器来配置内核中断+外部中断的优先级，</p><p><strong>pendSV 中断和systick中断优先级配置</strong></p><p>在port.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在port.c中，定义好pendSV, systick这两个内核中断的优先级</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_PENDSV_PRI                   ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 16UL )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> portNVIC_SYSTICK_PRI                  ( ( ( uint32_t ) configKERNEL_INTERRUPT_PRIORITY ) &lt;&lt; 24UL )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个才是实际的启动调度器，调度器内部会开始设置任务调度所需的任务的优先级。</span></span><br><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 设置 PendSV 和 SysTick 的中断优先级为最低中断优先级 */</span></span><br><span class="line"> portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;</span><br><span class="line"> portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//configKERNEL_INTERRUPT_PRIORITY 这个在FreeRTOSConfig.h中定义，内核中断优先级为15</span></span><br></pre></td></tr></table></figure><p><strong>开关中断的接口</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//portmacro.h 中定义实际用BASEPRI来控制可控制的中断</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portDISABLE_INTERRUPTS()                  vPortRaiseBASEPRI()</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portENABLE_INTERRUPTS()                   vPortSetBASEPRI( 0 )</span></span><br></pre></td></tr></table></figure><p><strong>freertos进出临界区api分两套</strong>：</p><ol><li>普通任务进出临界区：<ol><li>可嵌套</li><li>无需备份之前的basepri</li></ol></li><li>中断进出临界区：<ol><li>不可以嵌套</li><li>需要备份之前的basepri</li></ol></li></ol><h2 id="B-freertos-任务"><a href="#B-freertos-任务" class="headerlink" title="B. freertos 任务"></a>B. freertos 任务</h2><p>在传统的裸机开发中，一般是一个while大循环，然后里面顺序的执行函数（后台），当中断来临，这时候进入中断服务程序（前台）。</p><p>但是这在大型嵌入式系统设计中，实时性严重不足</p><p><strong>多任务系统</strong>的多个任务可以“<code>同时</code>”运行，是从宏观的角度而言的，对于单核<br>的 CPU 而言，CPU 在同一时刻只能够处理一个任务</p><p><img src="/../images/21.2.png" alt="alt text"><br>多任务系统的<strong>任务也是具有优先级的</strong>，高优先<br>级的任务可以像中断的抢占一样，抢占低优先级任务的 CPU 使用权</p><p><strong>任务调度</strong>则分为<code>抢占式调度</code>+<code>时间片轮询</code></p><p><strong>任务的状态</strong></p><ol><li><code>运行态</code>（正在占用cpu）</li><li><code>就绪态</code>（排队等待执行）（当前有同或更高优先级的任务）</li><li><code>阻塞态</code>（延时一段时间<code>vTaskDelay()</code>；等待外部事件发生(超时时间)）</li><li><code>挂起态</code>（通过函数 <code>vTaskSuspend()</code>和函数 <code>vTaskResums()</code>进入和退出挂起态）<br><img src="/../images/21.3.png" alt="alt text"></li></ol><p><strong>任务优先级</strong></p><p>每一个任务都被分配一个<code>0~(configMAX_PRIORITIES-1)</code>的任务优先级，宏 <code>configMAX_PRIORITIES</code> 在 <code>FreeRTOSConfig.h</code>文件中定义</p><p>宏 <code>configMAX_PRIORITIES 的值不能超过 32</code>,原因是freertos里面有选择是否用硬件计算前导0指令，最大支持32位</p><p>任务优先级<strong>高低</strong>与其对应的优先级数值，是成<strong>正比的</strong></p><p><img src="/../images/21.4.png" alt="alt text"></p><h3 id="任务task"><a href="#任务task" class="headerlink" title="任务task"></a>任务task</h3><p>在rtos中，task由TCB和栈空间组成。</p><p><code>TCB结构体</code>如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="comment">/* 指向任务栈栈顶的指针 */</span></span><br><span class="line"> <span class="keyword">volatile</span> StackType_t * pxTopOfStack;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line"> <span class="comment">/* MPU 相关设置 */</span></span><br><span class="line"> xMPU_SETTINGS xMPUSettings;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* 任务状态列表项 */</span></span><br><span class="line"> ListItem_t xStateListItem;</span><br><span class="line"> <span class="comment">/* 任务等待事件列表项 */</span></span><br><span class="line"> ListItem_t xEventListItem;</span><br><span class="line"> <span class="comment">/* 任务的任务优先级 */</span></span><br><span class="line"> UBaseType_t uxPriority;</span><br><span class="line"> <span class="comment">/* 任务栈的起始地址 */</span></span><br><span class="line"> StackType_t * pxStack;</span><br><span class="line"> <span class="comment">/* 任务的任务名 */</span></span><br><span class="line"> <span class="type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ];</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( ( portSTACK_GROWTH &gt; 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )</span></span><br><span class="line"> <span class="comment">/* 指向任务栈栈底的指针 */</span></span><br><span class="line"> StackType_t * pxEndOfStack;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line"> <span class="comment">/* 记录任务独自的临界区嵌套次数 */</span></span><br><span class="line"> UBaseType_t uxCriticalNesting;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line"><span class="comment">/* 由系统分配（每创建一个任务，值增加一），分配任务的值都不同，用于调试 */</span></span><br><span class="line"> UBaseType_t uxTCBNumber;</span><br><span class="line"> <span class="comment">/* 由函数 vTaskSetTaskNumber()设置，用于调试 */</span></span><br><span class="line"> UBaseType_t uxTaskNumber;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line"> <span class="comment">/* 保存任务原始优先级，用于互斥信号量的优先级翻转 */</span></span><br><span class="line"> UBaseType_t uxBasePriority;</span><br><span class="line"> <span class="comment">/* 记录任务获取的互斥信号量数量 */</span></span><br><span class="line"> UBaseType_t uxMutexesHeld;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line"> <span class="comment">/* 用户可自定义任务的钩子函数用于调试 */</span></span><br><span class="line"> TaskHookFunction_t pxTaskTag;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS &gt; 0 )</span></span><br><span class="line"> <span class="comment">/* 保存任务独有的数据 */</span></span><br><span class="line"> <span class="type">void</span> *pvThreadLocalStoragePointers[configNUM_THREAD_LOCAL_STORAGE_POINTERS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line"> <span class="comment">/* 记录任务处于运行态的时间 */</span></span><br><span class="line"> configRUN_TIME_COUNTER_TYPE ulRunTimeCounter;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line"> <span class="comment">/* 用于 Newlib */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> _<span class="title">reent</span> <span class="title">xNewLib_reent</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line"> <span class="comment">/* 任务通知值 */</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line"> <span class="comment">/* 任务通知状态 */</span></span><br><span class="line"> <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line"> <span class="comment">/* 任务静态创建标志 */</span></span><br><span class="line"> <span class="type">uint8_t</span> ucStaticallyAllocated;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line"> <span class="comment">/* 任务被中断延时标志 */</span></span><br><span class="line"> <span class="type">uint8_t</span> ucDelayAborted;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ( configUSE_POSIX_ERRNO == 1 )</span></span><br><span class="line"> <span class="comment">/* 用于 POSIX */</span></span><br><span class="line"> <span class="type">int</span> iTaskErrno;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; tskTCB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The old tskTCB name is maintained above then typedefed to the new TCB_t name</span></span><br><span class="line"><span class="comment"> * below to enable the use of older kernel aware debuggers. */</span></span><br><span class="line"><span class="keyword">typedef</span> tskTCB TCB_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span> * <span class="title">TaskHandle_t</span>;</span></span><br></pre></td></tr></table></figure><p>可以理解为，一个TCB（任务控制块），就是一个<code>任务的本体</code>。<br>一个任务TCB，里面包含了比如任务栈空间<code>栈顶的指针</code>，<code>优先级</code>，<code>临界区的嵌套次数</code>等等。</p><blockquote><p>可以看到<strong>所谓的任务句柄</strong>，实际上就是<strong>TCB内存块的指针</strong>。</p></blockquote><p>而<strong>栈空间</strong>，是和一个任务在运行过程中，和函数的局部变量，函数调用的现场和返回地址有关的，所以是在<strong>创建过程</strong>中开辟的一段内存。</p><h4 id="task创建"><a href="#task创建" class="headerlink" title="task创建"></a>task创建</h4><p><code>通过静态创建，可以很清晰的看出一个任务的内存分布和内部结构。</code></p><p><strong>1. 静态创建</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line"></span><br><span class="line">    TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,<span class="comment">// 栈空间长度（StackType_t（4字节） 的个数）</span></span></span><br><span class="line"><span class="params">                                    <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                                    UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                                    StackType_t * <span class="type">const</span> puxStackBuffer,</span></span><br><span class="line"><span class="params">                                    StaticTask_t * <span class="type">const</span> pxTaskBuffer )</span></span><br><span class="line">    &#123;</span><br><span class="line">        TCB_t * pxNewTCB; <span class="comment">//先声明一个指向TCB任务本体内存区域的指针</span></span><br><span class="line">        TaskHandle_t xReturn;</span><br><span class="line"></span><br><span class="line">        configASSERT( puxStackBuffer != <span class="literal">NULL</span> ); <span class="comment">//校验参数：任务栈空间的起始地址</span></span><br><span class="line">        configASSERT( pxTaskBuffer != <span class="literal">NULL</span> );<span class="comment">//校验参数：TCB内存起始地址</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configASSERT_DEFINED == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//校验开辟的TCB内存大小是否符合sizeof(TCB_t)</span></span><br><span class="line">                <span class="keyword">volatile</span> <span class="type">size_t</span> xSize = <span class="keyword">sizeof</span>( StaticTask_t );</span><br><span class="line">                configASSERT( xSize == <span class="keyword">sizeof</span>( TCB_t ) );</span><br><span class="line">                ( <span class="type">void</span> ) xSize; <span class="comment">/* Prevent lint warning when configASSERT() is not used. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( pxTaskBuffer != <span class="literal">NULL</span> ) &amp;&amp; ( puxStackBuffer != <span class="literal">NULL</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//指定这块内存作为TCB，记录下他的起始地址</span></span><br><span class="line">            pxNewTCB = ( TCB_t * ) pxTaskBuffer; </span><br><span class="line">            <span class="comment">//在这块内存（TCB）中记录，属于这个任务的栈空间的起始地址</span></span><br><span class="line">            pxNewTCB-&gt;pxStack = ( StackType_t * ) puxStackBuffer;</span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span></span><br><span class="line">                    pxNewTCB-&gt;ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化这块TCB，把其他剩余的TCB参数补全，并获得句柄</span></span><br><span class="line">            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &amp;xReturn, pxNewTCB, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将这个新task（TCB内存空间的指针）加入就绪链表</span></span><br><span class="line">            prvAddNewTaskToReadyList( pxNewTCB );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//返回task句柄</span></span><br><span class="line">        <span class="keyword">return</span> xReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SUPPORT_STATIC_ALLOCATION */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：如果是选择静态创建，那么之后所有的任务创建都只能使用静态，包括空闲任务IDLE task， 和软件定时器服务任务<br>可以看开启调度器的逻辑：</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果选择静态创建</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            StaticTask_t * pxIdleTaskTCBBuffer = <span class="literal">NULL</span>;</span><br><span class="line">            StackType_t * pxIdleTaskStackBuffer = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="type">uint32_t</span> ulIdleTaskStackSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要这个函数来获取你申请的IDLE任务的TCB，栈空间的内存</span></span><br><span class="line">            vApplicationGetIdleTaskMemory( &amp;pxIdleTaskTCBBuffer, &amp;pxIdleTaskStackBuffer, &amp;ulIdleTaskStackSize );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调度器自动帮你静态创建IDLE任务</span></span><br><span class="line">            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,</span><br><span class="line">                                                 configIDLE_TASK_NAME,</span><br><span class="line">                                                 ulIdleTaskStackSize,</span><br><span class="line">                                                 ( <span class="type">void</span> * ) <span class="literal">NULL</span>,       </span><br><span class="line">                                                 portPRIVILEGE_BIT,    </span><br><span class="line">                                                 pxIdleTaskStackBuffer,</span><br><span class="line">                                                 pxIdleTaskTCBBuffer ); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( xIdleTaskHandle != <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                xReturn = pdPASS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                xReturn = pdFAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//自动动态创建IDLE任务</span></span><br><span class="line">            xReturn = xTaskCreate( prvIdleTask,</span><br><span class="line">                                   configIDLE_TASK_NAME,</span><br><span class="line">                                   configMINIMAL_STACK_SIZE,</span><br><span class="line">                                   ( <span class="type">void</span> * ) <span class="literal">NULL</span>,</span><br><span class="line">                                   portPRIVILEGE_BIT,  </span><br><span class="line">                                   &amp;xIdleTaskHandle ); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line"></span><br><span class="line">　　<span class="comment">//使用定时器</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TIMERS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">            &#123;</span><br><span class="line">                xReturn = xTimerCreateTimerTask();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TIMERS */</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>调度器如果启用了定时器<code>xTimerCreateTimerTask()</code>，则需要创建定时器任务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerCreateTimerTask</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn = pdFAIL;</span><br><span class="line"></span><br><span class="line">    prvCheckForValidListAndQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xTimerQueue != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//静态创建</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                StaticTask_t * pxTimerTaskTCBBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                StackType_t * pxTimerTaskStackBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="type">uint32_t</span> ulTimerTaskStackSize;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//和IDLE一样，需要你自己手动申请定时器任务的TCB，stack内存空间</span></span><br><span class="line">                vApplicationGetTimerTaskMemory( &amp;pxTimerTaskTCBBuffer, &amp;pxTimerTaskStackBuffer, &amp;ulTimerTaskStackSize );</span><br><span class="line">                xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,</span><br><span class="line">                                                      configTIMER_SERVICE_TASK_NAME,</span><br><span class="line">                                                      ulTimerTaskStackSize,</span><br><span class="line">                                                      <span class="literal">NULL</span>,</span><br><span class="line">                                                      ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,</span><br><span class="line">                                                      pxTimerTaskStackBuffer,</span><br><span class="line">                                                      pxTimerTaskTCBBuffer );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( xTimerTaskHandle != <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    xReturn = pdPASS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span> <span class="comment">/* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//动态创建</span></span><br><span class="line">                xReturn = xTaskCreate( prvTimerTask,</span><br><span class="line">                                       configTIMER_SERVICE_TASK_NAME,</span><br><span class="line">                                       configTIMER_TASK_STACK_DEPTH,</span><br><span class="line">                                       <span class="literal">NULL</span>,</span><br><span class="line">                                       ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,</span><br><span class="line">                                       &amp;xTimerTaskHandle );</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configASSERT( xReturn );</span><br><span class="line">    <span class="keyword">return</span> xReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 动态创建</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line"></span><br><span class="line">    BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, </span></span><br><span class="line"><span class="params">                            <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">//直接就是表示任务栈空间的大小（字）</span></span></span><br><span class="line"><span class="params">                            <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                            UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                            TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span><span class="comment">//最后这个参数返回自动创建的任务的TCB的地址</span></span><br><span class="line">    &#123;</span><br><span class="line">        TCB_t * pxNewTCB;</span><br><span class="line">        BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//portmacro.h中定义#define portSTACK_GROWTH          ( -1 )</span></span><br><span class="line">        <span class="comment">//表示栈是向下增长的。</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &gt; 0 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//忽略</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                StackType_t * pxStack;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 用port里面绑定的heap_4.c中的方法，分配栈空间</span></span><br><span class="line">                pxStack = pvPortMallocStack( ( ( ( <span class="type">size_t</span> ) usStackDepth ) * <span class="keyword">sizeof</span>( StackType_t ) ) ); </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( pxStack != <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//开始开辟TCB的内存区域</span></span><br><span class="line">                    pxNewTCB = ( TCB_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( TCB_t ) ); </span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//在这个TCB中记录好该任务的栈空间起始地址</span></span><br><span class="line">                        pxNewTCB-&gt;pxStack = pxStack;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        vPortFreeStack( pxStack );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pxNewTCB = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pxNewTCB != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )</span></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    pxNewTCB-&gt;ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//和静态创建一样，开始初始化这个新的任务TCB，并返回该TCB的地址</span></span><br><span class="line">            prvInitialiseNewTask( pxTaskCode, pcName, ( <span class="type">uint32_t</span> ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, <span class="literal">NULL</span> );</span><br><span class="line">            <span class="comment">//将该TCB的地址加入就绪任务链表</span></span><br><span class="line">            prvAddNewTaskToReadyList( pxNewTCB );</span><br><span class="line">            xReturn = pdPASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xReturn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span></span><br></pre></td></tr></table></figure><p><strong>3. 删除任务</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( INCLUDE_vTaskDelete == 1 )</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span></span><br><span class="line">    &#123;</span><br><span class="line">        TCB_t * pxTCB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入临界区，关可控中断，关调度</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取要删除任务的TCB内存指针</span></span><br><span class="line">            pxTCB = prvGetTCBFromHandle( xTaskToDelete );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove task from the ready/delayed list. */</span></span><br><span class="line">            <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Is the task waiting on an event also? */</span></span><br><span class="line">            <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ( <span class="type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the uxTaskNumber also so kernel aware debuggers can</span></span><br><span class="line"><span class="comment">             * detect that the task lists need re-generating.  This is done before</span></span><br><span class="line"><span class="comment">             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will</span></span><br><span class="line"><span class="comment">             * not return. */</span></span><br><span class="line">            uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* A task is deleting itself.  This cannot complete within the</span></span><br><span class="line"><span class="comment">                 * task itself, as a context switch to another task is required.</span></span><br><span class="line"><span class="comment">                 * Place the task in the termination list.  The idle task will</span></span><br><span class="line"><span class="comment">                 * check the termination list and free up any memory allocated by</span></span><br><span class="line"><span class="comment">                 * the scheduler for the TCB and stack of the deleted task. */</span></span><br><span class="line">                vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Increment the ucTasksDeleted variable so the idle task knows</span></span><br><span class="line"><span class="comment">                 * there is a task that has been deleted and that it should therefore</span></span><br><span class="line"><span class="comment">                 * check the xTasksWaitingTermination list. */</span></span><br><span class="line">                ++uxDeletedTasksWaitingCleanUp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Call the delete hook before portPRE_TASK_DELETE_HOOK() as</span></span><br><span class="line"><span class="comment">                 * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */</span></span><br><span class="line">                traceTASK_DELETE( pxTCB );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* The pre-delete hook is primarily for the Windows simulator,</span></span><br><span class="line"><span class="comment">                 * in which Windows specific clean up operations are performed,</span></span><br><span class="line"><span class="comment">                 * after which it is not possible to yield away from this task -</span></span><br><span class="line"><span class="comment">                 * hence xYieldPending is used to latch that a context switch is</span></span><br><span class="line"><span class="comment">                 * required. */</span></span><br><span class="line">                portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --uxCurrentNumberOfTasks;</span><br><span class="line">                traceTASK_DELETE( pxTCB );</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Reset the next expected unblock time in case it referred to</span></span><br><span class="line"><span class="comment">                 * the task that has just been deleted. */</span></span><br><span class="line">                prvResetNextTaskUnblockTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the task is not deleting itself, call prvDeleteTCB from outside of</span></span><br><span class="line"><span class="comment">         * critical section. If a task deletes itself, prvDeleteTCB is called</span></span><br><span class="line"><span class="comment">         * from prvCheckTasksWaitingTermination which is called from Idle task. */</span></span><br><span class="line">        <span class="keyword">if</span>( pxTCB != pxCurrentTCB )</span><br><span class="line">        &#123;</span><br><span class="line">            prvDeleteTCB( pxTCB );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Force a reschedule if it is the currently running task that has just</span></span><br><span class="line"><span class="comment">         * been deleted. */</span></span><br><span class="line">        <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">            &#123;</span><br><span class="line">                configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">                portYIELD_WITHIN_API();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* INCLUDE_vTaskDelete */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>任务挂起和恢复则需要结合任务列表一起分析，见下</p></blockquote><h3 id="任务链表与任务节点"><a href="#任务链表与任务节点" class="headerlink" title="任务链表与任务节点"></a>任务链表与任务节点</h3><p>FreeRTOS 中的列表和列表项就是数据结构中的<strong>链表</strong>和<strong>节点</strong>。</p><p><strong>链表</strong></p><p>FreeRTOS 中的<strong>链表</strong>是一个<strong>双向链表</strong>，具体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    listFIRST_LIST_INTEGRITY_CHECK_VALUE <span class="comment">/* 校验值 */</span></span><br><span class="line">    <span class="keyword">volatile</span> UBaseType_t uxNumberOfItems; <span class="comment">/* 列表中列表项的数量 */</span></span><br><span class="line">    ListItem_t * configLIST_VOLATILE pxIndex; <span class="comment">/* 用于遍历列表 */</span></span><br><span class="line">    MiniListItem_t xListEnd; <span class="comment">/* 最后一个列表项 */</span></span><br><span class="line">    listSECOND_LIST_INTEGRITY_CHECK_VALUE <span class="comment">/* 校验值 */</span></span><br><span class="line">&#125; List_t;</span><br></pre></td></tr></table></figure><ul><li>这里面的两个校验值，只是用来检查链表的数据是否遭到破坏</li><li>成员变量 <code>xListEnd</code> 是一个<code>迷你链表项</code>（详见 7.1.3 小节），链表中迷你链表项的值一般被设置为最大值，用于将链表中的所有链表项按升序排序时，排在最末尾；同时 xListEnd 也用于挂载其他插入到链表中的链表项。<blockquote><p>所以<code>xListEnd</code> 仅仅只是作为链表的末尾节点存在，不计入链表节点的个数。</p></blockquote></li><li><code>ListItem_t</code>, 也就是用于遍历链表的pxIndex的指针类型，才是链表节点的真是类型。</li></ul><p>freertos中链表的结构示意图如下：<br><img src="/../images/21.5.png" alt="alt text"></p><p><strong>节点</strong>：</p><p>freertos中链表节点的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="comment">/* 用于检测列表项的数据完整性 */</span></span><br><span class="line">    configLIST_VOLATILE TickType_t xItemValue; <span class="comment">/* 列表项的值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span> <span class="comment">/* 下一个列表项 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span> <span class="comment">/* 上一个列表项 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> * pvOwner; <span class="comment">/* 列表项的拥有者 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxContainer</span>;</span> <span class="comment">/* 列表项所在列表 */</span></span><br><span class="line">    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="comment">/* 用于检测列表项的数据完整性 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> <span class="title">ListItem_t</span>;</span><span class="comment">/* 重定义成 ListItem_t */</span></span><br></pre></td></tr></table></figure><ul><li>可以看到，每个链表节点，都拥有一个<code>前向指针</code>和一个<code>后向指针</code>,也就是双向。</li><li><code>xItemValue</code> 为列表项的值，这个值多用于按<code>升序</code>对链表中的节点进行排序。</li><li>每个链表节点，都知道，自己是属于哪一个链表的。</li><li><code>pxOwner</code> 用于指向包含列表项的对象（通常是任务控制块）,<strong>这样就可以把任务TCB和链表节点挂钩</strong></li></ul><p>节点结构的示意图如下：</p><p><img src="/../images/21.6.png" alt="alt text"></p><p><strong>迷你链表项</strong></p><p>前面在链表的组成结构中，我们发现，每个链表都持有一个迷你链表项。</p><blockquote><p>仅用于<strong>标记列表的末尾</strong>和挂载其他<strong>插入</strong>列表中的列表项，<strong>用户是用不到迷你列表项的</strong></p></blockquote><p>定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE<span class="comment">/* 用于检测列表项的数据完整性 */</span></span><br><span class="line">    configLIST_VOLATILE TickType_t xItemValue; <span class="comment">/* 列表项的值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxNext</span>;</span> <span class="comment">/* 下一个列表项 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xLIST_ITEM</span> * <span class="title">configLIST_VOLATILE</span> <span class="title">pxPrevious</span>;</span> <span class="comment">/* 上一个列表项 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">xMINI_LIST_ITEM</span> <span class="title">MiniListItem_t</span>;</span><span class="comment">/* 重定义成 MiniListItem_t */</span></span><br></pre></td></tr></table></figure><p>可以看出：</p><ol><li>迷你列表项支持检测数据完整性</li><li>xItemValue 为列表项的值，用于升序排序到最后</li><li>pxNext 和 pxPrevious用于指向上一个和下一个链表节点</li><li>只用于标记列表的末尾和挂载其他插入列表中的列表项，因此不需要成员变量 pxOwner 和 pxContainer</li></ol><p>以上总结了，freertos中，链表和节点的组成部分</p><h3 id="链表，节点的使用"><a href="#链表，节点的使用" class="headerlink" title="链表，节点的使用"></a>链表，节点的使用</h3><p><strong>1. 链表的初始化</strong>：</p><p>就是写初始化List_t的内容，因为是空的，多数都是0，指向最后的迷你节点</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialise</span><span class="params">(</span></span><br><span class="line"><span class="params"> List_t * <span class="type">const</span> pxList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化时，列表中只有 xListEnd，因此 pxIndex 指向 xListEnd */</span></span><br><span class="line">    pxList-&gt;pxIndex = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* xListEnd 的值初始化为最大值，用于列表项升序排序时，排在最后 */</span></span><br><span class="line">    pxList-&gt;xListEnd.xItemValue = portMAX_DELAY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化时，列表中只有 xListEnd，因此上一个和下一个列表项都为 xListEnd 本身 */</span></span><br><span class="line">    pxList-&gt;xListEnd.pxNext = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">    pxList-&gt;xListEnd.pxPrevious = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*初始化时，列表中的列表项数量为 0（不包含 xListEnd） */</span></span><br><span class="line">    pxList-&gt;uxNumberOfItems = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化用于检测列表数据完整性的校验值 */</span></span><br><span class="line">    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );</span><br><span class="line">    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/21.7.png" alt="alt text"></p><p><strong>2. 链表节点的初始化</strong></p><p>可以看到，也仅仅只是初始化一个空的节点，既没有指向TCB内容，也没有归属那个链表</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInitialiseItem</span><span class="params">(</span></span><br><span class="line"><span class="params"> ListItem_t * <span class="type">const</span> pxItem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化时，列表项所在列表设为空 */</span></span><br><span class="line">    pxItem-&gt;pxContainer = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化用于检测列表项数据完整性的校验值 */</span></span><br><span class="line">    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );</span><br><span class="line">    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. vListInsertEnd插入到end</strong></p><p>是一种无序的插入方法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsertEnd</span><span class="params">(</span></span><br><span class="line"><span class="params"> List_t * <span class="type">const</span> pxList,</span></span><br><span class="line"><span class="params"> ListItem_t * <span class="type">const</span> pxNewListItem)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 获取列表 pxIndex 指向的列表项 */</span></span><br><span class="line">    ListItem_t * <span class="type">const</span> pxIndex = pxList-&gt;pxIndex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查参数是否正确 */</span></span><br><span class="line">    listTEST_LIST_INTEGRITY( pxList );</span><br><span class="line">    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新待插入列表项的指针成员变量 */</span></span><br><span class="line">    pxNewListItem-&gt;pxNext = pxIndex;</span><br><span class="line">    pxNewListItem-&gt;pxPrevious = pxIndex-&gt;pxPrevious;</span><br><span class="line">    <span class="comment">/* 测试使用，不用理会 */</span></span><br><span class="line">    mtCOVERAGE_TEST_DELAY();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新列表中原本列表项的指针成员变量 */</span></span><br><span class="line">    pxIndex-&gt;pxPrevious-&gt;pxNext = pxNewListItem;</span><br><span class="line">    pxIndex-&gt;pxPrevious = pxNewListItem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新待插入列表项的所在列表成员变量 */</span></span><br><span class="line">    pxNewListItem-&gt;pxContainer = pxList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新列表中列表项的数量 */</span></span><br><span class="line">    ( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将待插入的列表项<strong>插入到列表 pxIndex 指向列表项的前面</strong>，要注意的是，<strong>pxIndex 不一定指向 xListEnd，而是有可能指向列表中任意一个列表项</strong></p></blockquote><p>示意图如下：<br><img src="/../images/21.8.png" alt="alt text"></p><blockquote><p>可以直接想象成整个链表节点，<strong>构成一个圈</strong>：里面每个节点两两相连，可以前向，后向移动。用miniEND节点表示末尾</p></blockquote><p><strong>4. vListInsert()</strong></p><p>将节点，按照节点值，<strong>升序插入到列表</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vListInsert</span><span class="params">(</span></span><br><span class="line"><span class="params"> List_t * <span class="type">const</span> pxList,</span></span><br><span class="line"><span class="params"> ListItem_t * <span class="type">const</span> pxNewListItem)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListItem_t * pxIterator;</span><br><span class="line">    <span class="type">const</span> TickType_t xValueOfInsertion = pxNewListItem-&gt;xItemValue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 检查参数是否正确 */</span></span><br><span class="line">    listTEST_LIST_INTEGRITY( pxList );</span><br><span class="line">    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果待插入列表项的值为最大值 */</span></span><br><span class="line">    <span class="keyword">if</span>( xValueOfInsertion == portMAX_DELAY )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 插入的位置为列表 xListEnd 前面 */</span></span><br><span class="line">        pxIterator = pxList-&gt;xListEnd.pxPrevious;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 遍历列表中的列表项，找到插入的位置 */</span></span><br><span class="line">        <span class="keyword">for</span>( pxIterator = ( ListItem_t * ) &amp;( pxList-&gt;xListEnd );</span><br><span class="line">        pxIterator-&gt;pxNext-&gt;xItemValue &lt;= xValueOfInsertion;</span><br><span class="line">        pxIterator = pxIterator-&gt;pxNext )</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将待插入的列表项插入指定位置 */</span></span><br><span class="line">    pxNewListItem-&gt;pxNext = pxIterator-&gt;pxNext;</span><br><span class="line">    pxNewListItem-&gt;pxNext-&gt;pxPrevious = pxNewListItem;</span><br><span class="line">    pxNewListItem-&gt;pxPrevious = pxIterator;</span><br><span class="line">    pxIterator-&gt;pxNext = pxNewListItem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新待插入列表项所在列表 */</span></span><br><span class="line">    pxNewListItem-&gt;pxContainer = pxList;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 更新列表中列表项的数量 */</span></span><br><span class="line">    ( pxList-&gt;uxNumberOfItems )++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出：在将待插入列表项插入列表之前，会前<strong>遍历列表</strong>，找到待插入列表项需要<strong>插入的位置</strong></p></blockquote><p><img src="/../images/21.9.png" alt="alt text"></p><p><code>为什么值的类型是 TickType_t？</code></p><blockquote><p>这是由 FreeRTOS 的核心应用场景决定的。<br>在 RTOS 中，需要用到“升序排列链表”最主要的场景是**“延时任务列表”（Delayed Task List）**。</p></blockquote><blockquote><p>为了快速查找： 当多个任务都在延时（阻塞）时，内核需要知道“谁该第一个醒来”。</p></blockquote><blockquote><p>排序的基准是时间： 如果链表按“唤醒时间点”升序排列，那么表头（第一个节点）永远是那个最先到期的任务。</p></blockquote><blockquote><p>类型一致性： 系统时钟（Tick Count）的类型是 TickType_t，为了能够直接存储和比较时间点，避免溢出或类型转换错误，xItemValue 必须使用相同的类型。</p></blockquote><p><strong>5. 链表移除节点</strong></p><p>这个就很简单了，不用细说了</p><p><strong>6. 链表的操作</strong></p><p>这里已经提供给我们了，有很多方便的宏，可以帮助我们直接操作链表和节点<br><img src="/../images/21.10.png" alt="alt text"><br><img src="/../images/21.11.png" alt="alt text"></p><h2 id="freertos的启动流程"><a href="#freertos的启动流程" class="headerlink" title="freertos的启动流程"></a>freertos的启动流程</h2><p>上面已经分析了freertos的中断设置，任务，链表节点，下面来看一下freertos的启动流程来</p><p><strong>讲解 FreeRTOS 系统启动到第一个任务开始运行的一整个流程</strong></p><h3 id="1-裸机"><a href="#1-裸机" class="headerlink" title="1. 裸机"></a>1. 裸机</h3><p>这里就和普通的裸机程序一样，你要先初始化好所有需要的硬件，比如HAL的init，可以配置好基础的systick中断，定时器的初始化，lcd屏幕的初始化，key的初始化等。</p><p>之后就是创建好任务xTaskCreate，在堆中开辟好你的任务的TCB+Stack内存。<br>之后就是启动任务调度器，接下来，调度器便会开始任务调度。</p><blockquote><p>调度器除非被关掉，否则不会再回到裸机的主程序中了。</p></blockquote><h3 id="2-开启任务调度器"><a href="#2-开启任务调度器" class="headerlink" title="2. 开启任务调度器"></a>2. 开启任务调度器</h3><p>开启任务调度器的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xReturn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the idle task at the lowest priority. */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//静态创建IDLE空闲任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//动态创建IDLE空闲任务</span></span><br><span class="line">            xReturn = xTaskCreate( prvIdleTask,</span><br><span class="line">                                   configIDLE_TASK_NAME,</span><br><span class="line">                                   configMINIMAL_STACK_SIZE,</span><br><span class="line">                                   ( <span class="type">void</span> * ) <span class="literal">NULL</span>,</span><br><span class="line">                                   portPRIVILEGE_BIT,  <span class="comment">/* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */</span></span><br><span class="line">                                   &amp;xIdleTaskHandle ); <span class="comment">/*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建定时器任务，如果启用软件定时器</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TIMERS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">            &#123;</span><br><span class="line">                xReturn = xTimerCreateTimerTask();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TIMERS */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xReturn == pdPASS )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//此函数用于添加一些附加初始化，不用理会</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> FREERTOS_TASKS_C_ADDITIONS_INIT</span></span><br><span class="line">            &#123;</span><br><span class="line">                freertos_tasks_c_additions_init();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* FreeRTOS 关闭中断，</span></span><br><span class="line"><span class="comment">        * 以保证在开启任务任务调度器之前或过程中，SysTick 不会产生中断，</span></span><br><span class="line"><span class="comment">        * 在第一个任务开始运行时，会重新打开中断。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        portDISABLE_INTERRUPTS();</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//newlib相关</span></span><br><span class="line">                _impure_ptr = &amp;( pxCurrentTCB-&gt;xNewLib_reent );</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_NEWLIB_REENTRANT */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下一个距离取消任务阻塞的时间，初始化为最大值</span></span><br><span class="line">        xNextTaskUnblockTime = portMAX_DELAY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置调度器状态为运行中</span></span><br><span class="line">        xSchedulerRunning = pdTRUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滴答计数 == 0</span></span><br><span class="line">        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 运行时间和任务状态统计相关定义 */</span></span><br><span class="line">        <span class="comment">/* FreeRTOSConfig.h中定义</span></span><br><span class="line"><span class="comment">                #define configGENERATE_RUN_TIME_STATS                   0                       /* 1: 使能任务运行时间统计功能, 默认: 0 </span></span><br><span class="line"><span class="comment">                #if configGENERATE_RUN_TIME_STATS</span></span><br><span class="line"><span class="comment">                #include &quot;./BSP/TIMER/btim.h&quot;</span></span><br><span class="line"><span class="comment">                #define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span></span><br><span class="line"><span class="comment">                extern uint32_t FreeRTOSRunTimeTicks;</span></span><br><span class="line"><span class="comment">                #define portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();</span><br><span class="line"></span><br><span class="line">        traceTASK_SWITCHED_IN(); <span class="comment">/* 调试使用，不用理会 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置用于系统时钟节拍的硬件定时器（SysTick）</span></span><br><span class="line"><span class="comment">        * 会在这个函数中进入第一个任务，并开始任务调度</span></span><br><span class="line"><span class="comment">        * 任务调度开启后，便不会再返回</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>( xPortStartScheduler() != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Should not reach here as if the scheduler is running the</span></span><br><span class="line"><span class="comment">             * function will not return. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Should only reach here if a task calls xTaskEndScheduler(). */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* 动态方式创建空闲任务和定时器服务任务（如果有）时，因分配给 FreeRTOS 的堆空间</span></span><br><span class="line"><span class="comment">        * 不足，导致任务无法成功创建 */</span></span><br><span class="line">        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 防止编译器警告，不用理会 */</span></span><br><span class="line">    ( <span class="type">void</span> ) xIdleTaskHandle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调试使用，不用理会 */</span></span><br><span class="line">    ( <span class="type">void</span> ) uxTopUsedPriority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，task中启动调度器的核心就是另外创建两个task:IDLE + (软件定时器任务，如果需要)</p><p>之后就是xPortStartScheduler来真正设置systick中断，来进行调度。</p><p><strong>总结一下</strong>，启动调度器里面的工作：</p><ol><li>创建空闲任务</li><li>创建定时器服务任务</li><li>关闭中断，防止 SysTick 中断在任务调度器开启之前或过程中，产生中断。（在开始运行第一个任务时，重新打开中断）</li><li>初始化一些全局变量，并将任务调度器的运行标志设置为已运行</li><li>单开一个时基定时器，用于任务运行时间统计功能（如果不用就不需要）</li><li>调用函数 xPortStartScheduler()</li></ol><p>下面看一下，实际进行任务调度的xPortStartScheduler()的实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xPortStartScheduler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configASSERT_DEFINED == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 检测用户在 FreeRTOSConfig.h 文件中对中断相关部分的配置是否有误，代码省略 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configASSERT_DEFINED */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 PendSV 和 SysTick 的中断优先级为最低优先级 */</span></span><br><span class="line">    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;</span><br><span class="line">    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重新配置 SysTick的中断周期，比如说现在是1ms一次systick中断</span></span><br><span class="line"><span class="comment">        * 清空 SysTick 的计数值</span></span><br><span class="line"><span class="comment">        * 根据 configTICK_RATE_HZ 配置 SysTick 的重装载值</span></span><br><span class="line"><span class="comment">        * 开启 SysTick 计数和中断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vPortSetupTimerInterrupt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化临界区嵌套次数计数器为 0 */</span></span><br><span class="line">    uxCriticalNesting = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动第一个任务 */</span></span><br><span class="line">    prvStartFirstTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should not get here! */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结一下</strong>port里面，开启调度器的工作内容：</p><ol><li>断言配置的检查</li><li>配置 PendSV 和 SysTick 的中断优先级为最低优先级</li><li>根据FreeRTOSConfig.h 文件中配置的systick中断周期，重新设置systick中断, 然后启动 SysTick 计数和中断</li><li>初始化临界区嵌套计数器为 0</li><li>prvStartFirstTask()启动第一个任务</li></ol><h3 id="3-启动第一个任务"><a href="#3-启动第一个任务" class="headerlink" title="3. 启动第一个任务"></a>3. 启动第一个任务</h3><p>下面看一下是如何启动第一个任务的prvStartFirstTask()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">prvStartFirstTask</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//8 字节对齐</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    ldr r0, =<span class="number">0xE000ED08</span>  <span class="comment">/* 0xE000ED08 为 VTOR 地址 */</span></span><br><span class="line">    ldr r0, [ r0 ]      <span class="comment">/* 获取 VTOR 的值 */</span></span><br><span class="line">    ldr r0, [ r0 ]      <span class="comment">/* 获取 MSP 的初始值 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 MSP ， 把栈指针指向起始地址*/</span></span><br><span class="line">    msr msp, r0</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使能全局中断 */</span></span><br><span class="line">    cpsie i</span><br><span class="line">    cpsie f</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 SVC 启动第一个任务 */</span></span><br><span class="line">    svc <span class="number">0</span></span><br><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际开启第一个任务，已经完全由汇编来实现了。</p><ol><li><strong>保证8字节对齐</strong>，这是ARM 官方定义了一套标准，叫做 AAPCS，在调用公共接口（即函数切换、中断进入）时，堆栈指针 SP 必须保持 8 字节对齐，c程序在编译阶段，就会默认进行8字节对齐。</li><li>读取0xE000ED08（VTOR）取值，存放的就是 MSP 的初始地址，在启动调度器前，彻底回收启动阶段占用的栈空间，<strong>让 MSP 重新回到最干净的状态</strong><ol><li>实际Cotex-M提供了两个栈空间，<code>MSP</code>（主栈指针,系统内核使用，比如中断） 和 <code>PSP</code>（进程栈指针，任务栈使用），当使用不同的堆栈指针时，<code>SP</code> 会等于当前使用的堆栈指针</li><li>0xE000ED08 是 VTOR（向量表偏移寄存器）的地址，<code>VTOR</code> 中保存了<strong>向量表的偏移地址</strong>。</li><li>一般来说向量表是从其实地址 0x00000000 开始的</li><li>ARM Corten-M 提供了 <code>VTOR</code> 对向量表进行<code>重定向</code>。而向量表是用来保存中断异常的入口函数地址，即栈顶地址的</li></ol></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以看到，中断向量表IVT的最初是存放MSP，也就是系统栈的起始地址，</span></span><br><span class="line">__Vectors   DCD __initial_sp ; 栈底指针</span><br><span class="line">            DCD Reset_Handler ; Reset Handler</span><br><span class="line">            DCD NMI_Handler ; NMI Handler</span><br><span class="line">            DCD HardFault_Handler ; Hard Fault Handler</span><br><span class="line">            DCD MemManage_Handler ; MPU Fault Handler</span><br></pre></td></tr></table></figure><blockquote><p>所以这个操作，相当于丢弃了程序之前保存在栈中的数据，因此也就无法返回，因为刷掉了内核栈空间</p></blockquote><ol start="3"><li>重新使能全局中断,因为在taskstartSchedule中，曾经关掉了可控的所有中断</li><li>使用 <code>SVC 指令</code>，并传入<code>系统调用号 0</code>，触发 <code>SVC 中断</code></li></ol><p>既然，SVC是一个触发中断，那么CM3内核在接收到SVC 0的指令后，会跳转执行SVC中断服务程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//start.S中的IVT，可以看到，确实有SVC的中断服务程序</span></span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br></pre></td></tr></table></figure><p>原本他是要跳转到SVC_Handler程序的，这本来定义在裸机的中断.c文件中，但是我们在移植freertos时，就已经把他屏蔽掉了，换成了我们自己的SVC中断处理程序<br>vPortSVCHandler（）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">vPortSVCHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 8字节对齐*/</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取任务栈地址 */</span></span><br><span class="line">    ldr r3, = pxCurrentTCB   <span class="comment">/* r3 指向优先级最高的就绪态任务的任务控制块的内存块 */</span></span><br><span class="line">    ldr r1, [ r3 ]           <span class="comment">/* r1 为任务控制块地址 */</span></span><br><span class="line">    ldr r0, [ r1 ]           <span class="comment">/* r0 为任务控制块的第一个元素（栈顶） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 模拟出栈，并设置 PSP */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* 任务栈弹出到 CPU 寄存器 */</span></span><br><span class="line">    msr psp, r0              <span class="comment">/* 设置 PSP 为任务栈指针 */</span></span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使能所有中断 */</span></span><br><span class="line">    mov r0, # <span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用 PSP 指针，并bx跳转到任务函数 */</span></span><br><span class="line">    orr r14, # <span class="number">0xd</span></span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是跳转到当前需要执行的第一个任务来执行：</p><ol><li><code>pxCurrentTCB</code> 是一个<code>全局变量</code>，根据他的第一个成员变量，可以得到这个<code>任务栈的地址</code>，在前面创建 start_task 任务、空闲任务、定时器处理任务时自动根据任务的优先级高低进行赋值的</li></ol><blockquote><p>这里<strong>总结一下</strong>：<br>中断优先级（0-15，越小越大，所有pendSV, systick都是最小）<br>任务优先级（0-31，越大越大）<br>      start_task 任务   优先级 1<br>      IDLE任务          优先级 0<br>      定时器处理任务     优先级 31</p></blockquote><p>因此：因此当进入 <code>SVC 中断</code>时，<code>pxCurrentTCB</code> 就是指向了<code>定时器处理任务的任务控制块</code>。</p><ol start="2"><li>将<code>任务栈</code>中的内容<code>出栈到 CPU 寄存器中</code>，任务栈中的内容在调用任务创建函数的时候<code>已经初始化了</code></li><li>然后再设置 PSP 指针，那么，这么一来，任务的运行环境就准备好了</li><li>开中断</li><li>跳转任务的函数中去执行</li></ol><p>关于最后一句<strong>r14的寄存器是如何实现跳转执行的</strong>，这里面有一些技术细节：</p><blockquote><p>进入中断后 r14 为 <code>EXC_RETURN</code> 的具体应用就是，通过判断<code>EXC_RETURN</code> 的 bit4 是否为 0，来判断任务是否使用了浮点单元。最后通过 <code>bx r14 </code>指令，<strong>跳转到任务的任务函数中执行</strong>，执行此指令，CPU 会<code>自动从 PSP 指向的栈中出栈 R0、R1、R2、R3、R12、LR、PC、xPSR 寄存器</code>，并且如果 EXC_RETURN 的bit4 为 0（使用了浮点单元），那么 CPU 还会自动恢复浮点寄存器</p></blockquote><h3 id="4-任务状态列表"><a href="#4-任务状态列表" class="headerlink" title="4. 任务状态列表"></a>4. 任务状态列表</h3><p>以上，我们就分析了，<strong>freertos的启动流程</strong>，如何一步一步，从</p><ol><li>裸机初始化硬件，到</li><li>创建任务，在堆区自己开辟出任务内存区域，然后</li><li>调用task启动调度器函数<ol><li>创建IDLE任务</li><li>创建定时器任务（如有）</li><li>port启动调度器<ol><li>清楚MSP裸机的栈空间</li><li>bx r14, 跳转第一个任务</li></ol></li></ol></li></ol><p>下面，我需要看一下，任务task,在freertos中是如何被编排调度的呢，前面我们说了，freertos中的任务状态：</p><ol><li>运行态</li><li>就绪态</li><li>阻塞态</li><li>挂起态</li></ol><p><strong>那任务是如何体现自己当前是哪个态的呢？</strong></p><blockquote><p>答案：<strong>除了运行态</strong>，任务状态的<strong>其他三种</strong>任务都有<code>其对应的任务状态链表</code></p></blockquote><p>FreeRTOS 使用这些任务状态列表来管理处于不同状态的任务</p><p><code>task.c</code>中对任务状态链表的定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 就绪态任务列表 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阻塞态任务列表 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList1;                         </span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xDelayedTaskList2;                         </span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxDelayedTaskList;              </span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t * <span class="keyword">volatile</span> pxOverflowDelayedTaskList;     </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 挂起态任务列表 */</span></span><br><span class="line">PRIVILEGED_DATA <span class="type">static</span> List_t xPendingReadyList;                        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，</p><ol><li><code>就绪态任务链表</code>，是一个链表数组，<strong>数组大小&#x3D;最大任务优先级</strong><ol><li>就是说，每种优先级的任务，全部处在一个链表中</li></ol></li><li><code>阻塞态任务列表</code>，阻塞态任务列表一共有<code>两个</code>，分别为是阻塞态任务列表 1 和阻塞态任务列表 2，并且该有<code>两个</code>阻塞态任务<code>列表指针</code>。<ol><li>这么做的么的是<strong>为了解决任务阻塞时间溢出的问题(超时)</strong>，这个会在后续讲解阻塞相关的内容时，具体分析</li></ol></li><li><code>挂起态任务列表</code>，被挂起的任务就会被添加到挂起态任务列表中</li></ol><h3 id="5-任务的操作-与-任务状态"><a href="#5-任务的操作-与-任务状态" class="headerlink" title="5. 任务的操作 与 任务状态"></a>5. 任务的操作 与 任务状态</h3><p>下面，要结合任务的创建，删除等任务操作，来看看，如何利用这些链表，来实现任务在不同状态的切换</p><h4 id="xTaskCreate"><a href="#xTaskCreate" class="headerlink" title="xTaskCreate()"></a>xTaskCreate()</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请TCB+STACK内存空间</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化TCB任务控制块中的成员变量 */</span></span><br><span class="line">    prvInitialiseNewTask( pxTaskCode,</span><br><span class="line">                        pcName,</span><br><span class="line">                        ( <span class="type">uint32_t</span> ) usStackDepth,</span><br><span class="line">                        pvParameters,</span><br><span class="line">                        uxPriority,</span><br><span class="line">                        pxCreatedTask,</span><br><span class="line">                        pxNewTCB,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将任务添加到就绪态任务列表中</span></span><br><span class="line"><span class="comment">    * 这个函数会同时比较就绪态任务列表中的任务优先级</span></span><br><span class="line"><span class="comment">    * 并更新 pxCurrentTCB 为就绪态任务列表中优先级最高的任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    prvAddNewTaskToReadyList( pxNewTCB );</span><br><span class="line">    <span class="comment">/* 返回 pdPASS，说明任务创建成功 */</span></span><br><span class="line">    xReturn = pdPASS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误判断...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="prvInitialiseNewTask-初始化TCB"><a href="#prvInitialiseNewTask-初始化TCB" class="headerlink" title="prvInitialiseNewTask() 初始化TCB"></a>prvInitialiseNewTask() 初始化TCB</h5><p>那么核心就是<code>prvInitialiseNewTask()</code>他如何初始化一个任务TCB的，新创建的任务，是什么状态的？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvInitialiseNewTask</span><span class="params">( TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span></span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">uint32_t</span> ulStackDepth,</span></span><br><span class="line"><span class="params">                                  <span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params">                                  UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">                                  TaskHandle_t * <span class="type">const</span> pxCreatedTask,</span></span><br><span class="line"><span class="params">                                  TCB_t * pxNewTCB,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> MemoryRegion_t * <span class="type">const</span> xRegions )</span></span><br><span class="line">&#123;</span><br><span class="line">    StackType_t * pxTopOfStack;</span><br><span class="line">    UBaseType_t x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">        <span class="comment">//MPU 相关</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新建任务的任务栈设置为已知值（由宏 tskSTACK_FILL_BYTE 定义）</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将任务栈写满 tskSTACK_FILL_BYTE */</span></span><br><span class="line">            ( <span class="type">void</span> ) <span class="built_in">memset</span>( pxNewTCB-&gt;pxStack, ( <span class="type">int</span> ) tskSTACK_FILL_BYTE, ( <span class="type">size_t</span> ) ulStackDepth * <span class="keyword">sizeof</span>( StackType_t ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 宏 portSTACK_GROWTH 用于定义栈的生长方向</span></span><br><span class="line"><span class="comment">    * STM32 的栈是向下生长的，</span></span><br><span class="line"><span class="comment">    * 因此宏 portSTACK_GROWTH 定义为-1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &lt; 0 )</span></span><br><span class="line">           &#123;</span><br><span class="line">            <span class="comment">/* 获取任务栈的栈顶地址 */</span></span><br><span class="line">            pxTopOfStack = &amp;( pxNewTCB-&gt;pxStack[ ulStackDepth - ( <span class="type">uint32_t</span> ) <span class="number">1</span> ] );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对栈顶地址按宏 portBYTE_ALIGNMENT_MASK 进行字节对齐（8 字节对齐） */</span></span><br><span class="line">            pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 断言检查是否对齐. */</span></span><br><span class="line">            configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0UL</span> ) );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//此宏用于开启栈顶地址最大值记录功能（用于调试，不用理会）</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( configRECORD_STACK_HIGH_ADDRESS == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Also record the stack&#x27;s high address, which may assist</span></span><br><span class="line"><span class="comment">                     * debugging. */</span></span><br><span class="line">                    pxNewTCB-&gt;pxEndOfStack = pxTopOfStack;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configRECORD_STACK_HIGH_ADDRESS */</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化TCB中的任务名成员变量 */</span></span><br><span class="line">    <span class="keyword">if</span>( pcName != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 任务名的最大长度由宏 configMAX_TASK_NAME_LEN 定义 */</span></span><br><span class="line">        <span class="keyword">for</span>( x = ( UBaseType_t ) <span class="number">0</span>; x &lt; ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 复制任务名 */</span></span><br><span class="line">            pxNewTCB-&gt;pcTaskName[ x ] = pcName[ x ];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 任务名的长度不足宏 configMAX_TASK_NAME_LEN，则提前退出循环 */</span></span><br><span class="line">            <span class="keyword">if</span>( pcName[ x ] == ( <span class="type">char</span> ) <span class="number">0x00</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 在任务名成员变量末尾加上&#x27;\0&#x27; */</span></span><br><span class="line">        pxNewTCB-&gt;pcTaskName[ configMAX_TASK_NAME_LEN - <span class="number">1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 没主动命名，默认给个0 */</span></span><br><span class="line">        pxNewTCB-&gt;pcTaskName[ <span class="number">0</span> ] = <span class="number">0x00</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查任务优先级数值是否合法 */</span></span><br><span class="line">    configASSERT( uxPriority &lt; configMAX_PRIORITIES );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保任务优先级数值合法 */</span></span><br><span class="line">    <span class="keyword">if</span>( uxPriority &gt;= ( UBaseType_t ) configMAX_PRIORITIES )</span><br><span class="line">    &#123;</span><br><span class="line">        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化TCB中任务优先级成员变量 */</span></span><br><span class="line">    pxNewTCB-&gt;uxPriority = uxPriority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于启用互斥信号量，置0互斥量递归持有数，以及应对优先级翻转的备份 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MUTEXES == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;uxBasePriority = uxPriority;</span><br><span class="line">            pxNewTCB-&gt;uxMutexesHeld = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 任务状态链表节点 和 事件链表节点 的成员变量 */</span></span><br><span class="line">    vListInitialiseItem( &amp;( pxNewTCB-&gt;xStateListItem ) );</span><br><span class="line">    vListInitialiseItem( &amp;( pxNewTCB-&gt;xEventListItem ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定 任务状态链表节点 和　任务TCB*/</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xStateListItem ), pxNewTCB );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化　事件链表节点　的值与任务优先级成反比（链表中的链表节点按照链表节点的值，以升序排序） */</span></span><br><span class="line">    listSET_LIST_ITEM_VALUE( &amp;( pxNewTCB-&gt;xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 绑定 事件链表节点 和　任务TCB */</span></span><br><span class="line">    listSET_LIST_ITEM_OWNER( &amp;( pxNewTCB-&gt;xEventListItem ), pxNewTCB );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于启用任务单独临界区嵌套计数 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portCRITICAL_NESTING_IN_TCB == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;uxCriticalNesting = ( UBaseType_t ) <span class="number">0U</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portCRITICAL_NESTING_IN_TCB */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于用于自定义任务的钩子函数（用于调试，不用理会） */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_APPLICATION_TASK_TAG == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;pxTaskTag = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_APPLICATION_TASK_TAG */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于启用任务运行时间统计功能 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configGENERATE_RUN_TIME_STATS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            pxNewTCB-&gt;ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configGENERATE_RUN_TIME_STATS */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏为 MPU 的相关配置，不用理会 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            vPortStoreTaskMPUSettings( &amp;( pxNewTCB-&gt;xMPUSettings ), xRegions, pxNewTCB-&gt;pxStack, ulStackDepth );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Avoid compiler warning about unreferenced parameter. */</span></span><br><span class="line">            ( <span class="type">void</span> ) xRegions;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于保存任务独有数据 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )</span></span><br><span class="line">        &#123;   <span class="comment">/* 任务独有数据记录数组初始化为 0 */</span></span><br><span class="line">            <span class="built_in">memset</span>( ( <span class="type">void</span> * ) &amp;( pxNewTCB-&gt;pvThreadLocalStoragePointers[ <span class="number">0</span> ] ), <span class="number">0x00</span>, <span class="keyword">sizeof</span>( pxNewTCB-&gt;pvThreadLocalStoragePointers ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于启用任务通知功能 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 任务通知值和任务通知状态初始化为 0 */</span></span><br><span class="line">            <span class="built_in">memset</span>( ( <span class="type">void</span> * ) &amp;( pxNewTCB-&gt;ulNotifiedValue[ <span class="number">0</span> ] ), <span class="number">0x00</span>, <span class="keyword">sizeof</span>( pxNewTCB-&gt;ulNotifiedValue ) );</span><br><span class="line">            <span class="built_in">memset</span>( ( <span class="type">void</span> * ) &amp;( pxNewTCB-&gt;ucNotifyState[ <span class="number">0</span> ] ), <span class="number">0x00</span>, <span class="keyword">sizeof</span>( pxNewTCB-&gt;ucNotifyState ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏与 Newlib 相关，不用理会 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_NEWLIB_REENTRANT == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            _REENT_INIT_PTR( ( &amp;( pxNewTCB-&gt;xNewLib_reent ) ) );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏用于启用任务延时中断功能 */</span>  </span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( INCLUDE_xTaskAbortDelay == 1 )</span></span><br><span class="line">        &#123;<span class="comment">/* 任务被中断延时标志初始化为假 */</span></span><br><span class="line">            pxNewTCB-&gt;ucDelayAborted = pdFALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此宏为 MPU 的相关配置，不用理会 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( portUSING_MPU_WRAPPERS == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此部分用于初始化任务栈</span></span><br><span class="line"><span class="comment">            * 分为三种情况</span></span><br><span class="line"><span class="comment">            * 1. 启用了栈溢出检测功能并且栈的生长方向向下</span></span><br><span class="line"><span class="comment">            * 2. 启用了栈溢出检测功能并且栈的生长方向向上</span></span><br><span class="line"><span class="comment">            * 3. 未启用栈溢出检测功能（本教程着重分析这种情况）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( portHAS_STACK_OVERFLOW_CHECKING == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="meta">#<span class="keyword">if</span> ( portSTACK_GROWTH &lt; 0 )</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//初始化任务栈</span></span><br><span class="line">                            pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB-&gt;pxStack, pxTaskCode, pvParameters );</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//....</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portSTACK_GROWTH */</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">else</span> <span class="comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    pxNewTCB-&gt;pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portHAS_STACK_OVERFLOW_CHECKING */</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* portUSING_MPU_WRAPPERS */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回任务句柄</span></span><br><span class="line">    <span class="keyword">if</span>( pxCreatedTask != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是函数 <code>prvInitialiseNewTask()</code>的具体代码，可以看到函数 <code>prvInitialiseNewTask()</code>就是<br><strong>初始化了任务控制块TCB中的成员变量</strong>，其中比较重要的操作就是调用函数 <code>pxPortInitialiseStack</code>()初始化了任务栈。</p><p>那么<code>pxPortInitialiseStack()</code>他是如何<strong>初始化任务栈</strong>的呢？</p><h5 id="pxPortInitialiseStack-初始化任务栈"><a href="#pxPortInitialiseStack-初始化任务栈" class="headerlink" title="pxPortInitialiseStack() 初始化任务栈"></a>pxPortInitialiseStack() 初始化任务栈</h5><blockquote><p>这里的初始化栈，就是要在任务切换到这个task的时候，从栈中弹出要执行的环境，就是用以<strong>恢复该任务的上下文</strong><br>包括 <code>xPSR 寄存器的初始值</code>、任务的函数地址（<code>PC</code> 寄存器）、任务错误退出函数地址（<code>LR</code> 寄存器）、任务函数的<code>传入参数（R0 寄存器</code>）以及为 <code>R1~R12 寄存器预留空间</code>，若使用了浮点单元，那么还会有 EXC_RETURN 的值。<br>同时该函数会<strong>返回更新后的栈顶指针</strong></p></blockquote><blockquote><p><strong>注意</strong>：<br>针 对 ARM Cortex-M3 和针对 ARM Cortex-M4 和 ARM Cortex-M7 内 核 的 函 数<br>pxPortInitialiseStack()稍有不同，原因在于 ARM Cortex-M4 和 ARM Cortex-M7 内核具有浮点单<br>元，因此在任务栈中还需保存浮点寄存器的值</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See header file for description.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StackType_t * <span class="title function_">pxPortInitialiseStack</span><span class="params">( StackType_t * pxTopOfStack,<span class="comment">/* 任务栈顶指针 */</span></span></span><br><span class="line"><span class="params">                                     TaskFunction_t pxCode,<span class="comment">/* 任务函数地址 */</span></span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> * pvParameters )</span><span class="comment">/* 任务函数传入参数 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 模拟栈的格式将信息保存到任务栈中，用于上下文切换 */</span></span><br><span class="line">    pxTopOfStack--;                                                      </span><br><span class="line">    <span class="comment">/* xPSR 寄存器初始值为 0x01000000 */</span></span><br><span class="line">    *pxTopOfStack = portINITIAL_XPSR;                                    <span class="comment">/* xPSR */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line">    <span class="comment">/* 任务函数的地址（PC 寄存器） */</span></span><br><span class="line">    *pxTopOfStack = ( ( StackType_t ) pxCode ) &amp; portSTART_ADDRESS_MASK; <span class="comment">/* PC */</span></span><br><span class="line">    pxTopOfStack--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 任务错误退出函数地址（LR 寄存器） */</span></span><br><span class="line">    *pxTopOfStack = ( StackType_t ) prvTaskExitError;                    <span class="comment">/* LR */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为 R12、R3、R2、R1 寄存器预留空间 */</span></span><br><span class="line">    pxTopOfStack -= <span class="number">5</span>;                                                   </span><br><span class="line">    <span class="comment">/* 任务函数的传入参数（R0 寄存器） */</span></span><br><span class="line">    *pxTopOfStack = ( StackType_t ) pvParameters;                        <span class="comment">/* R0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为 R11、R10、R9、R8、R7、R6、R5、R4 寄存器预留空间 */</span></span><br><span class="line">    pxTopOfStack -= <span class="number">8</span>;                                                   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回更新后的任务栈指针</span></span><br><span class="line"><span class="comment">    * 后续任务运行时需要用到栈的地方，</span></span><br><span class="line"><span class="comment">    * 将从这个地址开始保存信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> pxTopOfStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是M4、M7的内核，还有什么浮点数相关的地方，也要预留栈的位置</p><p>最终，初始化任务栈构造出来的栈内容如下所示<br><img src="/../images/21.12.png" alt="alt text"></p><h5 id="prvAddNewTaskToReadyList-加入就绪队列"><a href="#prvAddNewTaskToReadyList-加入就绪队列" class="headerlink" title="prvAddNewTaskToReadyList() 加入就绪队列"></a>prvAddNewTaskToReadyList() 加入就绪队列</h5><p><code>prvAddNewTaskToReadList()</code>用于将新建的任务添加到就绪态任务列表中</p><p>函数同样定义在task.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvAddNewTaskToReadyList</span><span class="params">( TCB_t * pxNewTCB )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 进入临界区，确保在操作就绪态任务列表时，中断不会访问链表 */</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 此全局变量用于记录系统中任务数量 */</span></span><br><span class="line">        uxCurrentNumberOfTasks++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 此pxCurrentTCB全局变量用于指示当前系统中处于就 绪态任务中 优先级最高 的任务</span></span><br><span class="line"><span class="comment">            * 如果该全局变量为空（NULL），</span></span><br><span class="line"><span class="comment">            * 即表示当前创建的任务为系统中的唯一的就绪任务</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 系统中无其他就绪任务，因此优先级最高的就绪态任务（下一个待执行的任务）为当前创建的任务 */</span></span><br><span class="line">            pxCurrentTCB = pxNewTCB;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 如果当前系统中任务数量为 1，</span></span><br><span class="line"><span class="comment">                * 即表示当前创建的任务为系统中第一个任务</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span>( uxCurrentNumberOfTasks == ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 初始化任务列表（就绪态任务链表，任务阻塞链表） */</span></span><br><span class="line">                prvInitialiseTaskLists();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 判断任务调度器是否运行 */</span></span><br><span class="line">            <span class="keyword">if</span>( xSchedulerRunning == pdFALSE )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                * 将 pxCurrentTCB 更新为优先级最高的就绪态任务</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt;= pxNewTCB-&gt;uxPriority )</span><br><span class="line">                &#123;</span><br><span class="line">                    pxCurrentTCB = pxNewTCB;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 用于调试，不用理会 */</span></span><br><span class="line">        uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TRACE_FACILITY == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Add a counter into the TCB for tracing only. */</span></span><br><span class="line">                pxNewTCB-&gt;uxTCBNumber = uxTaskNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TRACE_FACILITY */</span></span></span><br><span class="line">        traceTASK_CREATE( pxNewTCB );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务添加到就绪态任务列表中 */</span></span><br><span class="line">        prvAddTaskToReadyList( pxNewTCB );</span><br><span class="line"></span><br><span class="line">        portSETUP_TCB( pxNewTCB );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 退出临界区 */</span></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果任务调度器正在运行，</span></span><br><span class="line"><span class="comment">    * 那么就需要判断，当前新建的任务优先级是否最高</span></span><br><span class="line"><span class="comment">    * 如果是，则需要切换任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果当前新建的任务优先级高于 pxCurrentTCB 的优先级 */</span></span><br><span class="line">        <span class="keyword">if</span>( pxCurrentTCB-&gt;uxPriority &lt; pxNewTCB-&gt;uxPriority )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 进行任务切换 */</span></span><br><span class="line">            taskYIELD_IF_USING_PREEMPTION();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，<code>prvAddTaskToReadyList()</code>主要就完成两件事:</p><ol><li>记录任务优先级(FreeRTOS 会以<code>位图</code>的方式记录就绪态任务列表中就绪态任务的优先级，这样能够提<br>高切换任务时的<code>效率</code>)</li><li>根据任务调度器的运行状态,决 定 是 否 进 行 任 务 切 换,<code>taskYIELD_IF_USING_PREEMPTION</code>()进行任务切换,关于任务切换，后面讨论</li></ol><h4 id="vTaskDelete-删除任务"><a href="#vTaskDelete-删除任务" class="headerlink" title="vTaskDelete() 删除任务"></a>vTaskDelete() 删除任务</h4><p>task.c中定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t * pxTCB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果传入的任务句柄为空（NULL）</span></span><br><span class="line"><span class="comment">        * 此函数会将待删除的任务设置为调用该函数的任务本身</span></span><br><span class="line"><span class="comment">        * 因此，如果要在任务中删除任务本身，</span></span><br><span class="line"><span class="comment">        * 那么可以调用函数 vTaskDelete()，并传入任务句柄，</span></span><br><span class="line"><span class="comment">        * 或传入 NULL</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pxTCB = prvGetTCBFromHandle( xTaskToDelete );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务从任务所在任务状态列表（就绪态任务列表 或 阻塞态任务列表）中移除</span></span><br><span class="line"><span class="comment">        * 如果移除后列表中的列表项数量为 0</span></span><br><span class="line"><span class="comment">        * 那么就需要更新任务优先级记录</span></span><br><span class="line"><span class="comment">        * 因为此时系统中可能已经没有和被删除任务相同优先级的任务了*/</span></span><br><span class="line">        <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 更新任务优先级记录 */</span></span><br><span class="line">            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断被删除的任务是否还有等待的事件 */</span></span><br><span class="line">        <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 将被删除任务的事件列表项，从所在事件列表中移除 */</span></span><br><span class="line">            ( <span class="type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 调试相关 */</span></span><br><span class="line">        uxTaskNumber++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断被删除的任务是否为正在运行的任务（即任务本身） */</span></span><br><span class="line">        <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 任务是无法删除任务本身的，于是需要将任务添加到任务待删除列表中</span></span><br><span class="line"><span class="comment">            * 空闲任务会处理任务待删除列表中的待删除任务</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vListInsertEnd( &amp;xTasksWaitingTermination, &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 这个全局变量用来告诉空闲任务有多少个待删除任务需要被删除 */</span></span><br><span class="line">            ++uxDeletedTasksWaitingCleanUp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调试用，不用管</span></span><br><span class="line">            traceTASK_DELETE( pxTCB );</span><br><span class="line">            portPRE_TASK_DELETE_HOOK( pxTCB, &amp;xYieldPending );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 任务数量计数器减 1 */</span></span><br><span class="line">            --uxCurrentNumberOfTasks;</span><br><span class="line">            traceTASK_DELETE( pxTCB );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新下一个任务的阻塞超时时间，以防被删除的任务就是下一个阻塞超时的任务，？ */</span></span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 退出临界区 */</span></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果待删除任务不是任务本身 */</span></span><br><span class="line">    <span class="keyword">if</span>( pxTCB != pxCurrentTCB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 此函数用于释放待删除任务占用的内存资源 */</span></span><br><span class="line">        prvDeleteTCB( pxTCB );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前在执行任务</span></span><br><span class="line"><span class="comment">    * 如果是，则需要切换任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此时任务调度器不能处于挂起状态 */</span></span><br><span class="line">            configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">            <span class="comment">/* 进行任务切换 */</span></span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面可以看出，vTaskDelete()删除任务时，需要考虑两种情况，当前要删除的任务：</p><ol><li>是正在执行的任务（需要将当前任务添加到<code>任务待删除列表</code>中，<code>空闲任务</code>会处理这个任务待删除列表，将待删除的任务统一删除,后面空闲任务详细分析）</li><li>不是正在执行的任务（直接删除prvDeleteTCB()）</li></ol><h5 id="prvDeleteTCB-具体删除任务"><a href="#prvDeleteTCB-具体删除任务" class="headerlink" title="prvDeleteTCB() 具体删除任务"></a>prvDeleteTCB() 具体删除任务</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prvDeleteTCB</span><span class="params">( TCB_t * pxTCB )</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当系统只支持动态内存管理时，</span></span><br><span class="line"><span class="comment">    * 任务待删除任务所占用的内存空间是通过 动态内存管理 分配的，</span></span><br><span class="line"><span class="comment">    * 因此只需要将内存空间通过 动态内存管理 释放掉即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 当系统支持静态内存管理和动态内存管理时，</span></span><br><span class="line"><span class="comment">    * 则需要分情况讨论</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) &amp;&amp; ( configSUPPORT_STATIC_ALLOCATION == 0 ) &amp;&amp; ( portUSING_MPU_WRAPPERS == 0 ) )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 动态内存管理释放待删除任务的任务控制块和任务的栈空间 */</span></span><br><span class="line">            vPortFreeStack( pxTCB-&gt;pxStack );</span><br><span class="line">            vPortFree( pxTCB );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检查是否静态管理内存</span></span><br><span class="line">            <span class="keyword">if</span>( pxTCB-&gt;ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//动态分配TCB+STACK</span></span><br><span class="line">                vPortFreeStack( pxTCB-&gt;pxStack );</span><br><span class="line">                vPortFree( pxTCB );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//只是静态分配STACK，所以stack需要用户自己手动释放</span></span><br><span class="line">                vPortFree( pxTCB );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Neither the stack nor the TCB were allocated dynamically, so</span></span><br><span class="line"><span class="comment">                 * nothing needs to be freed. */</span></span><br><span class="line">                configASSERT( pxTCB-&gt;ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );</span><br><span class="line">                mtCOVERAGE_TEST_MARKER();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_DYNAMIC_ALLOCATION */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vTaskSuspend-挂起任务"><a href="#vTaskSuspend-挂起任务" class="headerlink" title="vTaskSuspend() 挂起任务"></a>vTaskSuspend() 挂起任务</h4><p>task.c中定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend )</span></span><br><span class="line">&#123;</span><br><span class="line">    TCB_t * pxTCB;</span><br><span class="line">    <span class="comment">/* 进入临界区 */</span></span><br><span class="line">    taskENTER_CRITICAL();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//锁定挂起的任务的TCB地址，NULL就是本身</span></span><br><span class="line">        pxTCB = prvGetTCBFromHandle( xTaskToSuspend );</span><br><span class="line"></span><br><span class="line">        traceTASK_SUSPEND( pxTCB );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务从任务所在任务状态列表（就绪态任务列表 或 阻塞态任务列表）中移除</span></span><br><span class="line"><span class="comment">        * 如果移除后列表中的列表项数量为 0</span></span><br><span class="line"><span class="comment">        * 那么就需要更新任务优先级记录</span></span><br><span class="line"><span class="comment">        * 因为此时系统中可能已经没有和被挂起任务相同优先级的任务了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>( uxListRemove( &amp;( pxTCB-&gt;xStateListItem ) ) == ( UBaseType_t ) <span class="number">0</span> )</span><br><span class="line">        &#123;<span class="comment">/* 更新任务优先级记录 */</span></span><br><span class="line">            taskRESET_READY_PRIORITY( pxTCB-&gt;uxPriority );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 判断被挂起的任务是否还有等待的事件 */</span></span><br><span class="line">        <span class="keyword">if</span>( listLIST_ITEM_CONTAINER( &amp;( pxTCB-&gt;xEventListItem ) ) != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;<span class="comment">/* 将被挂起任务的事件列表项，从所在事件列表中移除 */</span></span><br><span class="line">            ( <span class="type">void</span> ) uxListRemove( &amp;( pxTCB-&gt;xEventListItem ) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将待挂起任务的任务状态列表向插入到挂起态任务列表末尾 */</span></span><br><span class="line">        vListInsertEnd( &amp;xSuspendedTaskList, &amp;( pxTCB-&gt;xStateListItem ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 此宏用于启用任务通知功能 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TASK_NOTIFICATIONS == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                BaseType_t x;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 遍历待挂起任务的所有任务通知状态 */</span></span><br><span class="line">                <span class="keyword">for</span>( x = <span class="number">0</span>; x &lt; configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 如果有正在等待的任务通知，则取消等待</span></span><br><span class="line"><span class="comment">                    * 因为此时，任务已经被挂起</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span>( pxTCB-&gt;ucNotifyState[ x ] == taskWAITING_NOTIFICATION )</span><br><span class="line">                    &#123;</span><br><span class="line">                        pxTCB-&gt;ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 退出临界区 */</span></span><br><span class="line">    taskEXIT_CRITICAL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前调度器在运行</span></span><br><span class="line">    <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//更新下一个任务的阻塞超时时间，以防被挂起的任务就是下一个阻塞超时的任务</span></span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        &#123;</span><br><span class="line">            prvResetNextTaskUnblockTime();</span><br><span class="line">        &#125;</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果待挂起任务就是任务本身 */</span></span><br><span class="line">    <span class="keyword">if</span>( pxTCB == pxCurrentTCB )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 如果任务调度器正在运行，则需要切换任务 */</span></span><br><span class="line">        <span class="keyword">if</span>( xSchedulerRunning != pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此时任务调度器不能处于挂起状态 */</span></span><br><span class="line">            configASSERT( uxSchedulerSuspended == <span class="number">0</span> );</span><br><span class="line">            <span class="comment">/* 进行任务切换, 底层原理： 它会触发一个 PendSV 异常 */</span></span><br><span class="line">            portYIELD_WITHIN_API();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 如果任务调度器没有运行，并且 pxCurrentTCB 又指向了待挂起的任务，</span></span><br><span class="line"><span class="comment">            * 那么就需要将 pxCurrentTCB 指向其他任务</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;xSuspendedTaskList ) == uxCurrentNumberOfTasks ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 没有就绪的任务，则将 pxCurrentTCB 指向空（NULL） */</span></span><br><span class="line">                pxCurrentTCB = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 更新 pxCurrentTCB 为优先级最高的就绪态任务 */</span></span><br><span class="line">                vTaskSwitchContext();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mtCOVERAGE_TEST_MARKER();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>A. 关于<strong>更新下一个任务的阻塞超时时间，以防被挂起的任务就是下一个阻塞超时的任务</strong>的问题：<br>先要知道：</p></blockquote><blockquote><p>在 FreeRTOS 中，如果有多个任务进入了阻塞态（例如调用了 vTaskDelay），它们会被放入“延时列表（Delayed Task List）”。这个列表是按唤醒时间升序排列的。</p><p><code>常规做法</code>：在每一次系统节拍中断（Tick Interrupt）中，扫描整个延时列表，看看有没有任务到期。但这太浪费 CPU 时间了。</p><p><code>FreeRTOS 的优化</code>：内核维护了一个变量 <code>xNextTaskUnblockTime</code>，它<strong>记录了延时列表中最快要唤醒的那一个任务的时间点</strong>。</p><p><code>带来的好处</code>：在 Tick 中断里，内核只需要简单判断一下：if (xTickCount &lt; xNextTaskUnblockTime)。如果当前时间还没到，说明列表里所有任务都没到期，中断可以立即退出。</p></blockquote><blockquote><p><strong>B. 为什么要重置？（情景模拟）</strong></p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设现在有三个任务在延时列表中：</span><br><span class="line"></span><br><span class="line">任务 A：唤醒时间点为 <span class="number">100</span></span><br><span class="line"></span><br><span class="line">任务 B：唤醒时间点为 <span class="number">150</span></span><br><span class="line"></span><br><span class="line">任务 C：唤醒时间点为 <span class="number">200</span></span><br><span class="line"></span><br><span class="line">此时，全局变量 xNextTaskUnblockTime = <span class="number">100</span>。</span><br><span class="line"></span><br><span class="line">如果你现在调用 vTaskSuspend(任务 A)：</span><br><span class="line"></span><br><span class="line">任务 A 会从“延时列表”中被移除，搬移到“挂起列表（Suspended List）”。</span><br><span class="line"></span><br><span class="line">危机出现：此时延时列表中最快要唤醒的任务变成了任务 B（时间点 <span class="number">150</span>）。</span><br><span class="line"></span><br><span class="line">结果：如果此时不更新 xNextTaskUnblockTime，它的值依然是 <span class="number">100</span>。</span><br><span class="line"></span><br><span class="line">如果不更新会发生什么？ 当系统时间（Tick Count）到达 <span class="number">100</span> 时，Tick 中断触发，内核发现 xTickCount &gt;= xNextTaskUnblockTime，于是满心欢喜地去延时列表找任务 A，结果发现列表里第一个任务是 B（<span class="number">150</span>），A 已经不见了。这意味着内核在时间点 <span class="number">100</span> 做了一次无意义的唤醒检查。</span><br></pre></td></tr></table></figure><blockquote><p>C. 关于pxCurrentTCB</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 什么是 pxCurrentTCB？</span><br><span class="line">pxCurrentTCB 是 FreeRTOS 内核中最重要的全局指针，它永远指向当前正在占用 CPU 的那个任务的任务控制块（TCB）。</span><br><span class="line"></span><br><span class="line">运行态的标志： 在任何时刻，CPU 正在执行哪行代码，那个代码所属任务的 TCB 地址就存在 pxCurrentTCB 里。</span><br><span class="line"></span><br><span class="line">切换的基准： 调度器进行上下文切换时，本质就是把旧任务的现场保存到旧的 pxCurrentTCB 指向的栈里，然后让 pxCurrentTCB 指向新任务，再从新栈里恢复现场。</span><br></pre></td></tr></table></figure><blockquote><p>D. 如果是自挂，且在运行时，portYIELD_WITHIN_API()的实际作用是什么？</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在 Cortex-M 架构中，PendSV（Pended Service Call）是一个非常特殊的系统异常。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Pend&quot;</span>（悬挂）</span><br><span class="line"></span><br><span class="line">普通的硬件中断（如串口接收）是“立刻执行”的，但 PendSV 是可以“延迟执行”的。</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;手动挂起&quot;</span>： 你代码中的 portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; 实际上是向 CPU 发出了一个信号：“我这里有个换人的活儿要干，先在挂号处登记一下（Pending）。”</span><br><span class="line"></span><br><span class="line">等待时机： <span class="string">&quot;CPU 不会立刻跳进 PendSV&quot;</span>。它会先看一眼：“现在还有没有比 PendSV 优先级更高的中断在跑？”</span><br><span class="line"></span><br><span class="line">如果有，CPU 先把紧急的中断跑完。</span><br><span class="line"></span><br><span class="line">如果没有，或者等所有紧急中断都退出了，CPU 才会进入 <span class="string">&quot;PendSV_Handler&quot;</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在的逻辑（使用 PendSV）：</span><br><span class="line">任务自挂： 任务 A 调用 vTaskSuspend()。</span><br><span class="line"></span><br><span class="line">登记： vPortYield() 登记了一个 PendSV 请求。</span><br><span class="line"></span><br><span class="line">安全检查： CPU 检查发现当前没有其他中断，或者等到其他中断都跑完了。</span><br><span class="line"></span><br><span class="line">换人： 进入最低优先级的 PendSV_Handler，此时它是系统里唯一在跑的异常，可以安全地保存任务 A 的现场，切换 pxCurrentTCB 到任务 B，并恢复任务 B 的现场。</span><br></pre></td></tr></table></figure><p>所以本质上，<strong>任务的切换</strong>，本质上是<strong>依赖pendSV中断(最低优先级)来实现</strong>的。</p><p>而实际在触发pendSV中断前，用<code>vPortYield()</code>登记的时候，里面有两条汇编指令：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__dsb( portSY_FULL_READ_WRITE );<span class="comment">//确保“把 PendSV 置 1”这个写内存的操作已经彻底完成，所有的数据都写进了寄存器</span></span><br><span class="line">__isb( portSY_FULL_READ_WRITE );<span class="comment">//清空流水线。确保在执行后面的代码之前，CPU 已经看到了前面 PendSV 置位带来的变化。</span></span><br></pre></td></tr></table></figure><p><strong>总结一下自挂的逻辑</strong>：</p><ol><li>发起请求： vTaskSuspend() 发现你要挂起自己，它把你从就绪链表挪到挂起链表。</li><li>呼叫后台： 调用 vPortYield()，往 ICSR 寄存器里写一个比特位，触发 PendSV 登记。</li><li>等待调度： 只要没有其他更高优先级的中断，CPU 就会立刻跳进 PendSV_Handler（这是由 FreeRTOS 写的汇编函数）。</li><li>现场搬运：<ol><li>把 CPU 现在的 $R4-R11$ 寄存器压入任务 A 的堆栈。</li><li>把新的栈指针存入任务 A 的 TCB。</li><li>找到 pxCurrentTCB 指向的新任务（比如任务 B）。</li><li>从任务 B 的堆栈里弹出 $R4-R11$ 到 CPU 寄存器。</li></ol></li><li>重生： 异常返回，CPU 此时拿的是任务 B 的寄存器和堆栈，任务 B 开始运行。<blockquote><p><strong>vPortYield()</strong> 只是“登记”，真正的魔术全在汇编函数 <code>xPortPendSVHandler</code> 里面。</p></blockquote></li></ol><h5 id="补充：pendSV-保存当前任务现场操作"><a href="#补充：pendSV-保存当前任务现场操作" class="headerlink" title="补充：pendSV 保存当前任务现场操作"></a>补充：pendSV 保存当前任务现场操作</h5><p><strong>1. CM3内核寄存器</strong>：</p><p>Cortex-M3 内核总共有 16 个主要寄存器：</p><ul><li>通用寄存器：$R0$ - $R12$</li><li>栈指针 (SP)：$R13$</li><li>链接寄存器 (LR)：$R14$</li><li>程序计数器 (PC)：$R15$</li><li>状态寄存器：$xPSR$</li></ul><p>当 <code>PendSV 中断触发</code>时，<code>硬件</code>和<code>软件</code>会分工合作，<code>共同完成这 16 个寄存器的保护</code></p><p><strong>2. pendSV中断触发，硬件自动工作</strong>：</p><p>硬件自动压栈 (Hardware Stacking)当异常发生的一瞬间，CPU 硬件会自动将以下 8 个寄存器压入当前任务的栈中：</p><ul><li>$xPSR$</li><li>$PC$ ($R15$)</li><li>$LR$ ($R14$)</li><li>$R12$</li><li>$R3$</li><li>$R2$</li><li>$R1$</li><li>$R0$</li></ul><blockquote><p>为什么是这几个？ 根据 ARM 的 AAPCS 标准，这些被称为“<code>调用者保存</code>（Caller-saved）”<code>寄存器</code>。硬件自动保存它们是为了保证中断退出后，<code>C 语言环境的函数逻辑不会乱套</code>。</p></blockquote><p><strong>3. pendSV中断触发，软件手动工作</strong>：</p><p>剩下的寄存器硬件管不着，必须由 FreeRTOS 在汇编（xPortPendSVHandler）中手动保存：</p><ul><li>$R4, R5, R6, R7, R8, R9, R10, R11$</li></ul><p>这些被称为“<code>被调用者保存</code>（Callee-saved）”寄存器。因为<code>硬件不负责它们</code>，所以 FreeRTOS 必须手动<code>用一条汇编指令 stmdb sp!, {r4-r11} 把它们排队送入栈</code>中。</p><blockquote><p>注意这里的SP仍然使用的是PSP，所以保存的是A的任务栈中。以上当前任务的PC指针，各种环境都已经保存了。</p></blockquote><p><strong>4. CM3的双栈机制</strong></p><p>以上可以得知，在pendSV中断中，处理压栈，此时<code>SP</code>指向的是当前任务栈(使用的是<code>PSP</code>)</p><p>在 Cortex-M3 中，<code>R13 寄存器（即 SP）</code>实际上<code>有两个物理备份</code>：</p><ul><li>MSP (Main Stack Pointer)： 主堆栈指针。用于 OS 内核、中断服务程序（ISR）。</li><li>PSP (Process Stack Pointer)： 进程堆栈指针。专门用于任务（Task）。</li></ul><h5 id="补充：pendSV中断实现任务切换的详细过程"><a href="#补充：pendSV中断实现任务切换的详细过程" class="headerlink" title="补充：pendSV中断实现任务切换的详细过程"></a>补充：pendSV中断实现任务切换的详细过程</h5><p>我们把这个过程拆解为三个清晰的阶段：</p><hr><p><strong>1. 第一阶段：硬件自动“序幕” (Hardware Entry)</strong></p><p>当 <code>PendSV</code> 被悬起（Pending）且 CPU 决定执行它时，硬件会在<strong>执行汇编第一行代码前</strong>完成以下动作：</p><ol><li><p><strong>判定当前栈指针</strong>：CPU 发现当前任务正在使用$PSP$ 。</p></li><li><p><strong>硬件压栈 (Hardware Stacking)</strong>：CPU 自动向 $PSP$ 指向的内存压入 8 个寄存器（$xPSR, PC, LR, R12, R3, R2, R1, R0$）。此时 $PSP$ 的值会自动减小。</p></li><li><p><strong>模式与 SP 切换</strong>：</p><ul><li>CPU 从<strong>线程模式</strong>进入<strong>处理者模式</strong>（Handler Mode）。</li><li><strong>关键：</strong> 硬件自动将当前使用的 SP 从 PSP 切换到 MSP。</li></ul></li><li><p><strong>PC 跳转</strong>：CPU 从向量表中取 <code>PendSV_Handler</code> 的地址并赋值给 PC。</p></li></ol><blockquote><p>[!IMPORTANT]<br><strong>结论：</strong> 当你在 <code>PendSV_Handler</code> 汇编里看到的第一行指令执行时，此时的 SP 已经变成 MSP 了，而刚才压了一半寄存器的 PSP 正孤零零地指在任务栈的某个位置。</p></blockquote><hr><p><strong>2. 第二阶段：软件手动“核心” (Software&#x2F;Assembly)</strong></p><p>现在进入了 FreeRTOS 的汇编代码（<code>xPortPendSVHandler</code>）。因为硬件只存了“一半”现场，剩下的由软件补齐：</p><ol><li><p><strong>取出 PSP</strong>：由于现在的 SP 是 MSP，软件第一步必须执行 <code>mrs r0, psp</code>，把那个任务栈的地址（$PSP$）抢救回寄存器 R0 中。</p></li><li><p><strong>软件压栈 (Software Stacking)</strong>：利用刚才取回的$R0$（即 $PSP$），手动执行汇编指令将 $R4$ 至 $R11$压入任务栈。</p><ul><li>指令：<code>stmdb r0!, {r4-r11}</code>（ 指针会继续向下移动）。</li></ul></li><li><p><strong>保存 SP 到 TCB</strong>：此时 $R0$  指向的是整个 16 个寄存器“全家福”的底部。</p><ul><li>动作：将 $R0$  的值写入 <code>pxCurrentTCB-&gt;pxTopOfStack</code>。<strong>至此，旧任务的灵魂被完整封印在它自己的栈里了。</strong></li></ul></li><li><p><strong>寻找新任务</strong>：调用 <code>vTaskSwitchContext</code>。这个 C 函数会更新 <code>pxCurrentTCB</code> 指向最高优先级的就绪任务。</p><ul><li>重点在于调用了函数 <code>taskSELETE_HIGHEST_PRIORITY_TASK</code>() 更新<code>pxCurrentTCB</code> 指向优先级最高的<code>就绪态任务</code></li></ul></li><li><p><strong>恢复新任务 SP</strong>：从新的 <code>pxCurrentTCB-&gt;pxTopOfStack</code> 中取出值存入 。</p></li><li><p><strong>软件出栈</strong>：手动弹出新任务栈里的  至 。</p><ul><li>指令：<code>ldmia r0!, {r4-r11}</code>。</li></ul></li><li><p><strong>更新 PSP</strong>：将恢复后的 （指向剩下 8 个寄存器的地方）重新写回  寄存器。</p></li></ol><hr><p><strong>3. 第三阶段：硬件自动“尾声” (Hardware Exit)</strong></p><p>汇编代码的最后一行通常是 <code>bx lr</code>（此时  是一个特殊的跳转值 <code>0xFFFFFFFD</code>）。</p><ol><li><strong>触发硬件返回</strong>：当硬件看到 $LR$ 是这个特殊值时，它知道异常结束了。</li><li><strong>自动切换回 PSP</strong>：硬件根据返回指令，自动把 $SP$ 从 $MSP$ 切回 $PSP$。</li><li><strong>硬件出栈 (Hardware Unstacking)</strong>：硬件自动从 $PSP$ 中弹出剩下的 8 个寄存器（（$R0-xPSR$）。）。</li><li><strong>恢复运行</strong>：此时 $PC$ 被恢复为新任务上次离开时的位置，新任务正式复活。</li></ol><hr><p><strong>4. 梳理对比表</strong></p><p>为了防止混淆，请看这个精确的先后顺序：</p><table><thead><tr><th>顺序</th><th>执行者</th><th>动作</th><th>使用的 SP</th></tr></thead><tbody><tr><td>1</td><td><strong>硬件</strong></td><td>压入 $R0-xPSR$</td><td>$PSP$</td></tr><tr><td>2</td><td><strong>硬件</strong></td><td>切到 $MSP$，跳转到 Handler 地址</td><td>$MSP$</td></tr><tr><td>3</td><td><strong>软件</strong></td><td>手动压入 $R4-R11$</td><td>通过 $R0$ 间接操作 $PSP$</td></tr><tr><td>4</td><td><strong>软件</strong></td><td>更新 <code>pxCurrentTCB</code> (寻找新任务)</td><td>$MSP$</td></tr><tr><td>5</td><td><strong>软件</strong></td><td>手动弹出新任务的 $R4-R11$</td><td>通过 $R0$ 间接操作 $PSP$</td></tr><tr><td>6</td><td><strong>硬件</strong></td><td>切回 $PSP$，弹出 $R0-xPSR$</td><td>$PSP$</td></tr></tbody></table><blockquote><p>你已经打通了任务切换的“任督二脉”。现在你可能会好奇：<strong>“既然任务切换靠 PendSV，那如果我在代码里写一个死循环而不调用任何 API（不触发 Yield），FreeRTOS 还能切换任务吗？”</strong></p></blockquote><blockquote><p>这就涉及到了 <code>SysTick</code> 这种“强制打断”的机制。<strong>你想聊聊 SysTick 是如何通过“强行挂号” PendSV 来实现时间片轮转的吗？</strong></p></blockquote><h4 id="恢复任务"><a href="#恢复任务" class="headerlink" title="恢复任务"></a>恢复任务</h4><p>恢复任务和挂起类似，比较简单。都需要判断</p><ol><li>确保有待恢复的任务</li><li>确保恢复的不是当前正在运行的任务</li><li>进入临界区<ol><li>从 挂起态任务列表中，移除该节点</li><li>添加到就绪态任务链表中</li><li>判断优先级，是否需要进行任务抢占切换</li></ol></li><li>退出临界区</li></ol><h3 id="6-空闲任务"><a href="#6-空闲任务" class="headerlink" title="6. 空闲任务"></a>6. 空闲任务</h3><p><strong>空闲任务</strong>主要用于处理<strong>待删除任务列表</strong>和<strong>低功耗</strong></p><p>task.c中定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">portTASK_FUNCTION</span><span class="params">( prvIdleTask, pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Stop warnings. */</span></span><br><span class="line">    ( <span class="type">void</span> ) pvParameters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不管</span></span><br><span class="line">    portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 处理待删除任务列表中的待删除任务 */</span></span><br><span class="line">        prvCheckTasksWaitingTermination();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否使能抢占式调度</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_PREEMPTION == 0 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//不使用抢占式调度，主动强制切换任务, 以确保其他任务（非空闲任务）可以获得 CPU 使用权</span></span><br><span class="line">                taskYIELD();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 宏 configIDLE_SHOULD_YIELD 用于使能空闲任务可以被同优先级的任务抢占 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( ( configUSE_PREEMPTION == 1 ) &amp;&amp; ( configIDLE_SHOULD_YIELD == 1 ) )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 如果存在与空闲任务相同优先级的任务，则进行任务切换 */</span></span><br><span class="line">                <span class="keyword">if</span>( listCURRENT_LIST_LENGTH( &amp;( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) &gt; ( UBaseType_t ) <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    taskYIELD();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//若使能空闲任务的钩子函数，需要用户自行定义</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_IDLE_HOOK == 1 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 调用空闲任务的钩子函数 */</span></span><br><span class="line">                vApplicationIdleHook();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_IDLE_HOOK */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 此宏为低功耗的相关配置，不用理会 */</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> ( configUSE_TICKLESS_IDLE != 0 )</span></span><br><span class="line">            &#123;</span><br><span class="line">                TickType_t xExpectedIdleTime;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* It is not desirable to suspend then resume the scheduler on</span></span><br><span class="line"><span class="comment">                 * each iteration of the idle task.  Therefore, a preliminary</span></span><br><span class="line"><span class="comment">                 * test of the expected idle time is performed without the</span></span><br><span class="line"><span class="comment">                 * scheduler suspended.  The result here is not necessarily</span></span><br><span class="line"><span class="comment">                 * valid. */</span></span><br><span class="line">                xExpectedIdleTime = prvGetExpectedIdleTime();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span><br><span class="line">                &#123;</span><br><span class="line">                    vTaskSuspendAll();</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* Now the scheduler is suspended, the expected idle</span></span><br><span class="line"><span class="comment">                         * time can be sampled again, and this time its value can</span></span><br><span class="line"><span class="comment">                         * be used. */</span></span><br><span class="line">                        configASSERT( xNextTaskUnblockTime &gt;= xTickCount );</span><br><span class="line">                        xExpectedIdleTime = prvGetExpectedIdleTime();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Define the following macro to set xExpectedIdleTime to 0</span></span><br><span class="line"><span class="comment">                         * if the application does not want</span></span><br><span class="line"><span class="comment">                         * portSUPPRESS_TICKS_AND_SLEEP() to be called. */</span></span><br><span class="line">                        configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>( xExpectedIdleTime &gt;= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )</span><br><span class="line">                        &#123;</span><br><span class="line">                            traceLOW_POWER_IDLE_BEGIN();</span><br><span class="line">                            portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );</span><br><span class="line">                            traceLOW_POWER_IDLE_END();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    mtCOVERAGE_TEST_MARKER();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configUSE_TICKLESS_IDLE */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h2><p>PendSV（Pended Service Call，可挂起服务调用）</p><p>PendSV的中断优先级是可以编程的</p><p>PendSV 的中断由将中断控制状态寄存器（<code>ICSR）中 PENDSVSET 为置一</code>触发</p><blockquote><p>PendSV 与 SVC 不同，<code>PendSV 的中断是非实时的</code>, 即 PendSV 的中断可以在更高优先级的中断中触发，但是在<code>更高优先级中断结束后才执行</code></p></blockquote><p>利用 PendSV 的这个<code>可挂起特性</code>，在设计 RTOS 时，可以<code>将 PendSV 的中断优先级</code>设置为<br><code>最低的中断优先级</code>, 任务切换时，就需要用到 PendSV 的这个特性</p><p>下面看一下任务切换的基本概念：</p><p>在典型的 RTOS 中，<strong>任务的处理时间被分为多个时间片</strong>，<strong>OS 内核</strong>的执行可以有<strong>两种触发方式</strong></p><ul><li>一种是通过在应用任务中<code>通过 SVC 指令触发</code>，<ul><li>例如在应用任务在等待某个时间发生而需要停止的时候，那么就可以通过 SVC 指令来触发 OS<br>内核的执行，以切换到其他任务；</li></ul></li><li>第二种方式是，<code>SysTick 周期性的中断</code>，来触发 OS 内核的执行。</li></ul><p>图演示了只有两个任务的 RTOS 中，两个任务交替执行的过程：</p><p><img src="/../images/21.13.png" alt="alt text"></p><p>在操作系统中，任务调度器决定是否切换任务。图 9.1.1 中的任务及切换都是在 <code>SysTick</code> 中<br>断中完成的，<code>SysTick 的每一次中断</code>都会<code>切换</code>到其他任务</p><blockquote><p>如果一个中断请求（IRQ）在 SysTick 中断产生之前产生，那么 SysTick 就可能抢占该中断<br>请求，这就会导致该中断请求被延迟处理，<strong>这在实时操作系统中是不允许的</strong>，因为这将会影响<br>到实时操作系统的实时性</p></blockquote><p><img src="/../images/21.14.png" alt="alt text"></p><p>并且，当 SysTick 完成任务的上下文切换，准备返回任务中运行时，由于存在中断请求，<br>ARM Cortex-M <code>不允许返回线程模式</code>，因此，将会产生<code>用法错误异常（Usage Fault）</code>。</p><p>在一些 RTOS 的设计中，会通过<code>判断是否存在中断请求</code>，来<code>决定是否进行任务切换</code>。虽然<br>可以通过检查 xPSR 或 NVIC 中的中断活跃寄存器来判断是否存在中断请求，但是这样可能会<br>影响系统的性能，甚至可能出现中断源在 SysTick 中断前后不断产生中断请求，导致系统无法<br>进行任务切换的情况。</p><p><code>PendSV</code> 通过<code>延迟执行任务切换</code>，<code>直到处理完所有的中断请求</code>，以解决上述问题。为了达到<br>这样的效果，<code>必须将 PendSV 的中断优先级设置为最低的中断优先等级</code>。如果操作系统决定切<br>换任务，那么就将 PendSV 设置为挂起状态，并在 PendSV 的中断服务函数中执行任务切换</p><h3 id="SVC中断，pendSV中断，systick中断"><a href="#SVC中断，pendSV中断，systick中断" class="headerlink" title="SVC中断，pendSV中断，systick中断"></a>SVC中断，pendSV中断，systick中断</h3><h4 id="1-SVC中断："><a href="#1-SVC中断：" class="headerlink" title="1. SVC中断："></a><strong>1. SVC中断：</strong></h4><p>作用单一：它主要用于<code>启动第一个任务</code>。</p><p>它的使命：当你调用 <code>vTaskStartScheduler()</code> 启动调度器时，最终会触发 <code>svc 0</code>。</p><p>执行过程：</p><ul><li><code>vPortSVCHandler</code> 汇编函数被激活。</li><li>它去获取最高优先级任务的栈顶指针（pxCurrentTCB-&gt;px<code>TopOfStack</code>）。</li><li>它<code>手动恢复该任务的寄存器环境</code>。</li></ul><p>最后通过修改 <code>CONTROL</code> 寄存器，让 <code>CPU 切换到使用 PSP</code>，并<code>PC跳转到任务入口</code>。</p><blockquote><p>为什么只用一次？：一旦第一个任务跑起来了，后续的任务切换全部交给 <code>PendSV</code> 处理。SVC 在 FreeRTOS 的标准移植层里基本就“光荣退休”了。</p></blockquote><h4 id="2-systick中断"><a href="#2-systick中断" class="headerlink" title="2. systick中断"></a><strong>2. systick中断</strong></h4><p>这个中断的优先级，依然是最低优先级，作用就是<code>系统节拍计数</code>+<code>维护延迟阻塞任务列表到就绪列表</code></p><p>它的核心职责：</p><ul><li>维持时间轴：每次中断，全局变量 <code>xTickCount</code> 加 1。</li><li>唤醒任务：检查“<code>延时列表</code>”里有没有任务的时间到了。如果有任务该醒了，就把它从延时列表挪回“就绪列表”。</li><li>强制打断（时间片轮转）：如果配置了 configUSE_PREEMPTION（抢占式），SysTick 会检查当前任务是否跑得太久了，或者是否有更高优先级的任务刚醒过来。</li></ul><blockquote><p>它与 PendSV 的联动： 如果 SysTick 发现需要换人，它不会自己去换。它会顺手悬起（Pending）一个 <code>PendSV 中断</code>。</p></blockquote><blockquote><p>形象理解：SysTick 发现时间到了，在黑板上写下“该换人了”，然后退出。因为 PendSV 也是最低优先级，CPU 接着就会自动进入 PendSV 去执行真正的搬运工作。</p></blockquote><p><strong>场景1：systick中断，判断抢占式调度</strong></p><p>——“有更重要的人醒了”</p><p>即便当前任务没有运行太久，只要有更高优先级的任务“醒了”，SysTick 就会强制打断当前任务。</p><ul><li><p>触发逻辑：在 SysTick 中断调用的 xTaskIncrementTick() 内部，内核会检查延时任务列表。</p></li><li><p>发生过程：</p><ul><li>假设任务 A（优先级 2）正在运行，任务 B（优先级 3）正在 vTaskDelay(10) 睡觉。</li><li>当第 10 次 SysTick 响起时，内核发现任务 B 的时间到了。</li><li>内核将任务 B 从阻塞态搬回就绪态。</li></ul></li></ul><blockquote><p>关键点：由于任务 B（3）的优先级比当前运行的任务 A（2）高，SysTick 会立刻标记需要进行切换（悬起 PendSV）。</p></blockquote><blockquote><p>结果：这被称为基于优先级的抢占。它不是因为任务 A 跑太久了，而是因为 B 更紧急。</p></blockquote><p><strong>2. 场景二：时间片轮转（针对相同优先级）</strong><br>——“大家级别一样，换个班吧”</p><ul><li><p>触发逻辑：如果配置了 configUSE_TIME_SLICING &#x3D; 1，且就绪列表中有多个任务处于相同最高优先级。</p></li><li><p>发生过程：</p><ul><li><p>假设任务 C 和任务 D 优先级都是 2，且没有更高优先级的任务在跑。</p></li><li><p>SysTick 每次响起时，都会检查当前优先级列表中是否有其他同级任务。</p></li></ul></li></ul><blockquote><p>逻辑：如果当前优先级列表里不止一个任务，SysTick 会请求一次任务切换（悬起 PendSV）。</p></blockquote><blockquote><p>结果：这样在下一次中断后，任务 D 就能跑 1ms，然后换回任务 C。这就是同优先级的时间片轮转。</p></blockquote><blockquote><p>在 同优先级时间片轮转（<code>Time Slicing</code>）的默认配置下，<code>每个任务执行一个 SysTick 周期</code>（通常是 <code>1ms</code>），然后就会把 CPU <code>转交给下一个同优先级的任务</code></p></blockquote><blockquote><p>[!IMPORTANT]<br>一般也推荐使用 SysTick 作为 RTOS 的时钟节拍，当然啦，用户也可以用其他的<code>硬件定时器</code>为 RTOS<br>提供时钟节拍。</p></blockquote><p>systick中断处理函数定义在delay.c中，但是内部的实现，在rtos的源码中提供了相应的回调办法：<code>xPortSysTickHandler</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">systick_handler()</span><br><span class="line">-&gt;xPortSysTickHandler</span><br><span class="line">  -&gt;xTaskIncrementTick() <span class="comment">//处理了系统时钟节拍、阻塞任务列表、时间片调度等</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 处理系统时钟节拍，就是在每次 SysTick 中断发生的时候，将全局变量 xTickCount 的值加</span></span><br><span class="line"><span class="comment">1，也就是将系统时钟节拍计数器的值加 1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">处理阻塞任务列表，就是判断阻塞态任务列表中是否有阻塞任务超时，如果有，就将阻塞</span></span><br><span class="line"><span class="comment">时间超时的阻塞态任务移到就绪态任务列表中，准备执行。同时在系统时钟节拍计数器</span></span><br><span class="line"><span class="comment">xTickCount 的加 1 溢出后，将两个阻塞态任务列表调换，这是 FreeRTOS 处理系统时钟节拍计</span></span><br><span class="line"><span class="comment">数器溢出的一种机制。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">处理时间片调度，就是在每次系统时钟节拍加 1 后，切换到另外一个同等优先级的任务中</span></span><br><span class="line"><span class="comment">运行，要注意的是，此函数只是做了需要进行任务切换的标记，在函数退出后，会统一进行任</span></span><br><span class="line"><span class="comment">务切换，因此时间片调度导致的任务切换，也可能因为有更高优先级的阻塞任务就绪导致任务</span></span><br><span class="line"><span class="comment">切换，而出现任务切换后运行的任务比任务切换前运行任务的优先级高，而非相等优先级。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="3-pendSV中断"><a href="#3-pendSV中断" class="headerlink" title="3. pendSV中断"></a><strong>3. pendSV中断</strong></h4><p>这个上面有解析过，负责具体的任务切换。</p><p>以上就是freertos的基本实现，后面就是一些使用，比如队列，信号量，互斥量，事件组，任务通知，延迟，定时器等，这些都比较简单。下一篇会简单介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Freertos-基础实现&quot;&gt;&lt;a href=&quot;#Freertos-基础实现&quot; class=&quot;headerlink&quot; title=&quot;Freertos 基础实现&quot;&gt;&lt;/a&gt;Freertos 基础实现&lt;/h1&gt;&lt;h2 id=&quot;freertos-代码结构分析&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="RTOS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/RTOS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="RTOS" scheme="http://example.com/tags/RTOS/"/>
    
    <category term="freertos" scheme="http://example.com/tags/freertos/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab5</title>
    <link href="http://example.com/2026/02/03/xv6-lab5/"/>
    <id>http://example.com/2026/02/03/xv6-lab5/</id>
    <published>2026-02-03T04:53:23.000Z</published>
    <updated>2026-02-20T13:51:20.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cow-fork"><a href="#cow-fork" class="headerlink" title="cow fork"></a>cow fork</h1><h2 id="存储空间定义"><a href="#存储空间定义" class="headerlink" title="存储空间定义"></a>存储空间定义</h2><p>关于存储，首先，存储器的访问颗粒是1个字 &#x3D; 8bit, 所以每个字节 都有一个物理地址。<br><img src="/../images/20.1.png" alt="alt text"><br><img src="/../images/20.2.png" alt="alt text"></p><blockquote><p>所以如果定义一个指针，uint64* p; 他实际上是一块uint64的内存，里面存放的是一个uint64内存的开始地址，也可以表示一片连着的uint64内存的初始块的起始地址（数组）</p></blockquote><p>这也就解释了，为什么如果uint64 a, a++, 则表示的是下一个字节，而uint64 *a, a++, 则a指向的是下一个uint64内存。</p><h2 id="pagetable-t"><a href="#pagetable-t" class="headerlink" title="pagetable_t"></a>pagetable_t</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//riscv.h</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;                          </span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs </span></span><br></pre></td></tr></table></figure><p>所以pagetable是一个指向uint64_t的内存块的<strong>数组</strong>的指针</p><p>里面每一项，<strong>是pte,也就是一个8字节的内存</strong>。64位，但是我们只使用里面的后面一部分的位数</p><p><strong>硬件是如何转换的？</strong></p><p>CPU访问一个虚拟地址（例如0x80001234）时，<code>硬件（MMU）</code>会进行以下动作：</p><p>VPN : xv6 (Sv39) 中，前27位（0x234）是偏移量。</p><p>查表寻踪：MMU 持有 VPN 去查表，找到对应的 PTE。</p><p>PTE中取出对应的物理页号（PPN），这就是物理内存中那一页的“起始” 。</p><p>直接调整12位偏移量，就得到了最终的物理地址。</p><p>关键点：映射对称，低12位是完全不动、原封不动地复制过去的。</p><blockquote><p><strong>VA</strong>：[ 虚拟页号 A ]+[ 偏移量 0x234 ]</p><p><strong>PA</strong>：[ 物理页号 B ]+[ 偏移量 0x234 ]</p></blockquote><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>分析一下普通的fork的内容</p><ol><li><strong>创建子进程allocproc()</strong><ol><li>np-&gt;pid</li><li>np-&gt;status &#x3D; USED</li><li>np-&gt;trapframe &#x3D; kalloc() 分配一页（4096字节）的物理内存地址</li><li>np-&gt;pagetable 创建空的页表<ol><li>uvmcreate()，默认分配一页内存 创建pagetable_t变量指向这段内存</li><li>mappage(trampoline) 添加一页映射trampoline</li><li>mappage(trapframe) 添加一页映射前面分配的trapframe</li></ol></li><li>np-&gt;context, 指定上下文<ol><li>context-&gt;ra &#x3D; forkret</li><li>context-&gt;sp &#x3D; kstack + PIGESIZE (sp栈底到栈顶1页大小)</li></ol></li></ol></li><li><strong>uvmcopy</strong>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) 拷贝父进程页表到子进程<ol><li>针对每一页虚拟内存的起始地址va(uint64)（0 ~ p-&gt;sz）<ol><li>从父进程的pagetable中walk出该页虚拟地址va对应的pte(一段uint64内存)</li><li>验证该pte是否有效（PTE_V）</li><li>(因为我们不需要父进程pte，而是需要在子进程复制一份pte)</li><li>PTE2PA 得到 该va对应的pa</li><li>拷贝父进程该va对应的pte的flag</li><li>申请一页空的内存mem kalloc</li><li>从父进程的pa拷贝父进程的该页内存到mem</li><li>mappage 添加该va ~ mem 的映射在子进程的页表中</li></ol></li></ol></li><li>np-&gt;sz &#x3D; p-&gt;sz 拷贝父进程的虚拟地址空间大小</li><li>拷贝父进程trapframe内容</li><li>设置子进程的fork()返回值a0寄存器 &#x3D; 0</li><li>复制文件描述符引用</li><li>复制进程名</li><li>np-&gt;parent &#x3D; p</li><li>设置子进程状态RUNABLE，加入调度器，开始运行</li><li>返回子进程pid</li></ol><blockquote><p>p-&gt;sz, kstack什么时候定的？</p></blockquote><h2 id="kalloc"><a href="#kalloc" class="headerlink" title="kalloc"></a>kalloc</h2><p><code>kalloc.c</code>负责对物理内存的管理，因为这里涉及到一个链表结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>kmem就是我们实际的内核的物理内存管理员，他持有一个锁（针对多cpu申请内存），还有一个struct run的指针，</p><p>注意这里struct run的结构体，他这里只是借用了struct结构体的一个内部变量内存结构，这样就相当于说明，一个一小块内存，里面排头的一个8字节指针，指向下一块小内存。就这样一直指下去，至于里面的值是什么，不知道，纯粹的野指针。</p><p>他先创建了这么个结构，然后有一个头：struct run *freelist, 她指向第一块这个小struc内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是freerange，他是在系统初始化的时候在init的时候被调用的，告知他物理内存的起始和终止位置。freerange会把这块物理内存，按页大小（4096字节）<strong>划分好</strong>，并传入每页的起始地址，<strong>给kfree，用于释放，串联</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kfree，当freerange传入一页物理内存的指针，他会格式化这一页内存，然后把这个指针改成struct run的指针，这样就完成了r对这个内存的指向，虽<code>然他实际上还是指向的一个struct run这块小内存，但起始地址是相同的</code>，<strong>指针r里面存的地址才是我们想要的</strong>，至于struct run是什么我们不关心。<br>这样就可以逐步把这些指针串起来，变成一个一页一页的链表，至此，freerange就完成了对初始状态下，空闲内存列表的收集。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是kalloc了，就是从这个空闲链表上摘下一个空闲页。如果用完了要释放了，就还用上面的kfree释放物理页，让他重新回归空闲列表。</p><h2 id="cow-fork实现"><a href="#cow-fork实现" class="headerlink" title="cow fork实现"></a>cow fork实现</h2><blockquote><p><strong>注意一点</strong>：</p><p>cow fork 和 fork本质上没什么不同，只是延时创建内存，共同的，<code>子进程还是无法写父进程的只读区域</code>，也就是无法动父进程的代码段。</p><p>这里要区分于<code>fork + exec</code>， exec才是真正把所有内存区域全部写，覆盖成你要执行的指令程序。这样覆盖完后，<code>只读区域，和读写区域就变了</code>。就完成了一个全新的指令进程了。</p></blockquote><p><strong>1. 分配</strong></p><p>应该修改uvmcopy的内容，不能直接mem &#x3D; kalloc分配内存拷贝，而是就用父进程的那一页物理内存，直接加入页表，同时设置父进程页表和子进程页表为合法，只读</p><p><strong>2. 使用</strong></p><p>思路如下：<br><img src="/../images/20.3.png" alt="alt text"></p><p><strong>3. 释放</strong></p><p>这里也很关键，不然sh执行指令exec覆盖的时候，就会出现释放kfree灾难，所以有必要了解一下总结在上面的<code>kalloc的内容</code></p><p>所以要关注什么时候，需要真正释放，而不是结束一次进程就要释放一次进程，这样就释放灾难了。</p><p>这里非常关键，如果你没有内存页统计管理的话，就会导致进程在执行中，容易释放掉所有的内存，因为子进程不管你的父进程有啥，直接free了，</p><p>这样容易报错：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2226</span><br><span class="line"><span class="built_in">cat</span>            2 3 23896</span><br><span class="line"><span class="built_in">echo</span>           2 4 22728</span><br><span class="line">forktest       2 5 13088</span><br><span class="line">grep           2 6 27256</span><br><span class="line">init           2 7 23832</span><br><span class="line"><span class="built_in">kill</span>           2 8 22704</span><br><span class="line"><span class="built_in">ln</span>             2 9 22656</span><br><span class="line"><span class="built_in">ls</span>             2 10 26128</span><br><span class="line"><span class="built_in">mkdir</span>          2 11 22800</span><br><span class="line"><span class="built_in">rm</span>             2 12 22792</span><br><span class="line">sh             2 13 41664</span><br><span class="line">stressfs       2 14 23800</span><br><span class="line">usertests      2 15 156016</span><br><span class="line">grind          2 16 37976</span><br><span class="line"><span class="built_in">wc</span>             2 17 25040</span><br><span class="line">zombie         2 18 22192</span><br><span class="line">cowtest        2 19 30232</span><br><span class="line">console        3 20 0</span><br><span class="line">usertrap(): unexpected scause 0x0000000000000002 pid=2, name = sh</span><br><span class="line">            sepc=0x0000000000001000 stval=0x0000000000000000</span><br><span class="line">Fault info: VA=0x0000000000001000, PTE_VAL=0x0000000021fda50b, Flags=0x000000000000010b</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000c pid=1, name = init</span><br><span class="line">            sepc=0x0000000000001000 stval=0x0000000000001000</span><br><span class="line">panic: init exiting</span><br><span class="line">QEMU: Terminated</span><br></pre></td></tr></table></figure><p>kalloc.c里面的实现逻辑，需要有一个对物理内存页的全局计数：</p><p>总结规则就是：</p><p><strong>1. kalloc</strong> -&gt; 申请新的物理内存 （cnt &#x3D; 1）</p><p><strong>2. kfree</strong> -&gt;</p><ol><li>cnt &gt; 1, (实际上不止一个进程拥有这块内存页)， cnt -1</li><li>cng &lt;&#x3D;0, (此时需要回收内存)， cnt &#x3D; 0</li></ol><p><strong>3. kinit</strong> -&gt; 初始化统计数组为0，（这样freerange里面才能触发kfree，统一收集所有空闲内存页）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span><br><span class="line">index fa6a0ac..<span class="number">0</span>cac44a <span class="number">100644</span></span><br><span class="line">--- a/kernel/kalloc.c</span><br><span class="line">+++ b/kernel/kalloc.c</span><br><span class="line">@@ <span class="number">-18</span>,<span class="number">15</span> +<span class="number">18</span>,<span class="number">29</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEM_NUM (PHYSTOP-KERNBASE)/PGSIZE</span></span><br><span class="line">+</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">+  uint8 pa_mem_cnt[MEM_NUM];</span><br><span class="line"> &#125; kmem;</span><br><span class="line"></span><br><span class="line">+<span class="type">void</span></span><br><span class="line">+kmem_py_mem_cnt_add(uint64 pa)</span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="comment">//add pa_mem_cnt</span></span><br><span class="line">+    acquire(&amp;kmem.lock);</span><br><span class="line">+    <span class="type">int</span> id = (pa-KERNBASE)/PGSIZE;</span><br><span class="line">+    kmem.pa_mem_cnt[id]++;</span><br><span class="line">+    release(&amp;kmem.lock);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> <span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">   initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">+  <span class="built_in">memset</span>(kmem.pa_mem_cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(kmem.pa_mem_cnt));</span><br><span class="line">   freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-51</span>,<span class="number">12</span> +<span class="number">65</span>,<span class="number">28</span> @@ kfree(<span class="type">void</span> *pa)</span><br><span class="line">   <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">     panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+  if(kmem_py_mem_cnt_modify((uint64)pa, 0) != 0)&#123;</span></span><br><span class="line"><span class="comment">+      // find pa page minus , but not == 0</span></span><br><span class="line"><span class="comment">+      return;</span></span><br><span class="line"><span class="comment">+  &#125;</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  acquire(&amp;kmem.lock);</span><br><span class="line">+  <span class="type">int</span> id = ((uint64)pa-KERNBASE)/PGSIZE;</span><br><span class="line">+  <span class="keyword">if</span>(kmem.pa_mem_cnt[id] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">+      kmem.pa_mem_cnt[id]--;</span><br><span class="line">+      release(&amp;kmem.lock);</span><br><span class="line">+      <span class="keyword">return</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  kmem.pa_mem_cnt[id] = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">   <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">   <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">   r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">-  acquire(&amp;kmem.lock);</span><br><span class="line">   r-&gt;next = kmem.freelist;</span><br><span class="line">   kmem.freelist = r;</span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line">@@ <span class="number">-74</span>,<span class="number">9</span> +<span class="number">104</span>,<span class="number">16</span> @@ kalloc(<span class="type">void</span>)</span><br><span class="line">   r = kmem.freelist;</span><br><span class="line">   <span class="keyword">if</span>(r)</span><br><span class="line">     kmem.freelist = r-&gt;next;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// add 1 in r page</span></span><br><span class="line">+  <span class="comment">// 拿出新内存</span></span><br><span class="line">+  <span class="type">int</span> id = ((uint64)r-KERNBASE)/PGSIZE;</span><br><span class="line">+  kmem.pa_mem_cnt[id] = <span class="number">1</span>;</span><br><span class="line">+</span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(r)</span><br><span class="line">     <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这边我犯了一些错误，只考虑了单个cpu的情况，事实上，会有很多个cpu，这会导致，如果你修改kmem内存管理员内的任何东西的时候，如果不<strong>加锁</strong>，会出现数据被意外修改。所以一定要完整的加锁才行</p></blockquote><p><strong>4. 使用支持内存计数统计</strong><br>当我们在kalloc.c中支持了物理内存页的计数统计，肯定需要让cpu在处理访问页的时候，用上。<br>所以，还要在之前的uvmcopy，usertrap中用上。</p><p>因为对于进程和内存来说，总共就3种涉及的关系：</p><ol><li>申请新的kalloc()</li><li>释放旧的kfree()</li><li>拷贝内存uvmcopy()</li></ol><p>所以这里需要再次修改之前的uvmcopy(), 之前只实现了cow的标志位逻辑和申请拷贝逻辑，没有计数。后面trap的时候，就无法根据计数正确的释放free</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//uvmcopy()</span></span><br><span class="line"><span class="comment">//完成标志位C设置</span></span><br><span class="line">kmem_py_mem_cnt_add(pa); <span class="comment">//对该内存计数+1</span></span><br><span class="line"><span class="comment">//拷贝含C的页表项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//usertrap()</span></span><br><span class="line"><span class="comment">// 申请新内存</span></span><br><span class="line">kfree((<span class="type">void</span> *)pa); <span class="comment">//释放老内存，实际上是只对计数-1，不是真的释放</span></span><br><span class="line"><span class="comment">// 制作新的页表项.....</span></span><br></pre></td></tr></table></figure><p>此时，进行cowtest测试, 可以看到简单测试已经通过了，还有一个file的test</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cowtest        2 19 30232</span><br><span class="line">console        3 20 0</span><br><span class="line">$ cowtest</span><br><span class="line">simple: ok</span><br><span class="line">simple: ok</span><br><span class="line">three: ok</span><br><span class="line">three: ok</span><br><span class="line">three: ok</span><br><span class="line">file: usertrap(): unexpected scause 0x0000000000000002 pid=5, name = cowtest</span><br><span class="line">            sepc=0x0000000000000dbc stval=0x0000000000000004</span><br><span class="line">$</span><br><span class="line">$</span><br><span class="line">$</span><br><span class="line">$ QEMU: Terminated</span><br></pre></td></tr></table></figure><p>这个file的test，实际上是要copyout也要实现缺页处理</p><h2 id="copyout"><a href="#copyout" class="headerlink" title="copyout"></a>copyout</h2><p>正常普通的<strong>写内存</strong>可能发生在：</p><ol><li>cpu修改变量的值</li><li>exec覆盖内存</li><li>copyout内核把数据往用户空间的内存拷贝。</li><li>……</li></ol><p>这些情况都可以因为mmu+pagetable，出现页异常。</p><p>所以，copyout也要像usertrap一样，进行页处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-356</span>,<span class="number">12</span> +<span class="number">378</span>,<span class="number">51</span> @@ copyout(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span><br><span class="line">     n = PGSIZE - (dstva - va0);</span><br><span class="line">     <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">       n = len;</span><br><span class="line">-    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// liangji add</span></span><br><span class="line">+    <span class="type">pte_t</span> *pte;</span><br><span class="line">+    <span class="type">char</span> *mem = (<span class="type">char</span>*)pa0;</span><br><span class="line">+    uint flags;</span><br><span class="line">+    <span class="keyword">if</span>((pte = walk(pagetable, va0, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        panic(<span class="string">&quot;write page, cannot walk pte&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        panic(<span class="string">&quot;write page, walk pte, but not valid&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// if w=0 &amp;&amp; c=1</span></span><br><span class="line">+    <span class="keyword">if</span>(((*pte &amp; PTE_W) == <span class="number">0</span> ) &amp;&amp; ((*pte &amp; PTE_C) != <span class="number">0</span>))&#123;</span><br><span class="line">+          <span class="comment">//alloc and copy mem</span></span><br><span class="line">+          <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">+              panic(<span class="string">&quot;fail to alloc new mem in cow fork&quot;</span>);</span><br><span class="line">+          memmove((<span class="type">void</span>*)(uint64)mem, (<span class="type">void</span>*)pa0, PGSIZE);</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//old pa should cnt --</span></span><br><span class="line">+          kfree((<span class="type">void</span> *)pa0);</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">// set w = 1, and c = 0</span></span><br><span class="line">+          flags = PTE_FLAGS(*pte);</span><br><span class="line">+          flags |= PTE_W;</span><br><span class="line">+          flags &amp;= ~PTE_C;</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//change child pte</span></span><br><span class="line">+          uint64 new_pte = PA2PTE((uint64)mem);</span><br><span class="line">+          new_pte &amp;= ~(<span class="number">0x3FF</span>);</span><br><span class="line">+          new_pte |= flags;</span><br><span class="line">+          *pte = new_pte;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">//memmove((void *)(pa0 + (dstva - va0)), src, n);</span></span><br><span class="line">+    memmove((<span class="type">void</span> *)((uint64)mem + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">     len -= n;</span><br><span class="line">     src += n;</span><br><span class="line">     dstva = va0 + PGSIZE;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">+  sfence_vma();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>这边我也犯了几个错误</p><p><strong>1. 数据拷贝的时机</strong></p><p>因为触发页异常，申请一页新内存，<code>必须要在释放旧内存前，拷贝旧内存数据到新内存</code>，原因是：我们实际写数据，不可能刚好写一页4096字节，可能旧写一个字节，甚至只改变一些标志位，<code>剩下的旧内存数据，依然是有效的</code>，不能丢弃。</p><p><strong>2. 引用计数逻辑的死循环风险</strong></p><p>按道理来说，当释放到这页物理内存，只有一个进程的时候，就不需要再释放，然后申请新页了，直接默认属于最后一个进程就行了。也可以不修复，只是让最后一个进程重新申请一次内存，麻烦一点而已。</p></blockquote><h2 id="cow-fork-的基本实现（cowtest）"><a href="#cow-fork-的基本实现（cowtest）" class="headerlink" title="cow fork 的基本实现（cowtest）"></a>cow fork 的基本实现（cowtest）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From <span class="number">43b</span>c35e4289e3d3261ff4a7b7691665b1856c228 Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Tue, <span class="number">3</span> Feb <span class="number">2026</span> <span class="number">23</span>:<span class="number">34</span>:<span class="number">01</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH] test: cow</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> kernel/defs.h   |  <span class="number">3</span> +++</span><br><span class="line"> kernel/kalloc.c | <span class="number">39</span> +++++++++++++++++++++++++++-</span><br><span class="line"> kernel/riscv.h  |  <span class="number">1</span> +</span><br><span class="line"> kernel/trap.c   | <span class="number">50</span> +++++++++++++++++++++++++++++++++++-</span><br><span class="line"> kernel/vm.c     | <span class="number">67</span> ++++++++++++++++++++++++++++++++++++++++++++++---</span><br><span class="line"> <span class="number">5</span> files changed, <span class="number">155</span> insertions(+), <span class="number">5</span> deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index <span class="number">3564</span>db4..<span class="number">84</span>df726 <span class="number">100644</span></span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ <span class="number">-63</span>,<span class="number">6</span> +<span class="number">63</span>,<span class="number">7</span> @@ <span class="type">void</span>            <span class="title function_">ramdiskrw</span><span class="params">(<span class="keyword">struct</span> buf*)</span>;</span><br><span class="line"> <span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">kmem_py_mem_cnt_add</span><span class="params">(uint64)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// log.c</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">initlog</span><span class="params">(<span class="type">int</span>, <span class="keyword">struct</span> superblock*)</span>;</span><br><span class="line">@@ <span class="number">-170</span>,<span class="number">6</span> +<span class="number">171</span>,<span class="number">8</span> @@ uint64          <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">char</span> *, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line">+<span class="type">pte_t</span> *         <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span>, uint64 , <span class="type">int</span>)</span>;</span><br><span class="line">+</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// plic.c</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span><br><span class="line">index fa6a0ac..<span class="number">0</span>cac44a <span class="number">100644</span></span><br><span class="line">--- a/kernel/kalloc.c</span><br><span class="line">+++ b/kernel/kalloc.c</span><br><span class="line">@@ <span class="number">-18</span>,<span class="number">15</span> +<span class="number">18</span>,<span class="number">29</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> MEM_NUM (PHYSTOP-KERNBASE)/PGSIZE</span></span><br><span class="line">+</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">+  uint8 pa_mem_cnt[MEM_NUM];</span><br><span class="line"> &#125; kmem;</span><br><span class="line"> </span><br><span class="line">+<span class="type">void</span></span><br><span class="line">+kmem_py_mem_cnt_add(uint64 pa)</span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="comment">//add pa_mem_cnt</span></span><br><span class="line">+    acquire(&amp;kmem.lock);</span><br><span class="line">+    <span class="type">int</span> id = (pa-KERNBASE)/PGSIZE;</span><br><span class="line">+    kmem.pa_mem_cnt[id]++;</span><br><span class="line">+    release(&amp;kmem.lock);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> <span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">   initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">+  <span class="built_in">memset</span>(kmem.pa_mem_cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(kmem.pa_mem_cnt));</span><br><span class="line">   freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-51</span>,<span class="number">12</span> +<span class="number">65</span>,<span class="number">28</span> @@ kfree(<span class="type">void</span> *pa)</span><br><span class="line">   <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">     panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"> </span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+  if(kmem_py_mem_cnt_modify((uint64)pa, 0) != 0)&#123;</span></span><br><span class="line"><span class="comment">+      // find pa page minus , but not == 0</span></span><br><span class="line"><span class="comment">+      return;</span></span><br><span class="line"><span class="comment">+  &#125;</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  acquire(&amp;kmem.lock);</span><br><span class="line">+  <span class="type">int</span> id = ((uint64)pa-KERNBASE)/PGSIZE;</span><br><span class="line">+  <span class="keyword">if</span>(kmem.pa_mem_cnt[id] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">+      kmem.pa_mem_cnt[id]--;</span><br><span class="line">+      release(&amp;kmem.lock);</span><br><span class="line">+      <span class="keyword">return</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  kmem.pa_mem_cnt[id] = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">   <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">   <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"> </span><br><span class="line">   r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"> </span><br><span class="line">-  acquire(&amp;kmem.lock);</span><br><span class="line">   r-&gt;next = kmem.freelist;</span><br><span class="line">   kmem.freelist = r;</span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line">@@ <span class="number">-74</span>,<span class="number">9</span> +<span class="number">104</span>,<span class="number">16</span> @@ kalloc(<span class="type">void</span>)</span><br><span class="line">   r = kmem.freelist;</span><br><span class="line">   <span class="keyword">if</span>(r)</span><br><span class="line">     kmem.freelist = r-&gt;next;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// add 1 in r page </span></span><br><span class="line">+  <span class="comment">// 拿出新内存</span></span><br><span class="line">+  <span class="type">int</span> id = ((uint64)r-KERNBASE)/PGSIZE;</span><br><span class="line">+  kmem.pa_mem_cnt[id] = <span class="number">1</span>;</span><br><span class="line">+</span><br><span class="line">   release(&amp;kmem.lock);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(r)</span><br><span class="line">     <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/kernel/riscv.h b/kernel/riscv.h</span><br><span class="line">index <span class="number">1691f</span>af..a578894 <span class="number">100644</span></span><br><span class="line">--- a/kernel/riscv.h</span><br><span class="line">+++ b/kernel/riscv.h</span><br><span class="line">@@ <span class="number">-343</span>,<span class="number">6</span> +<span class="number">343</span>,<span class="number">7</span> @@ sfence_vma()</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PTE_C (1L <span class="string">&lt;&lt; 8) // 1 -&gt;</span> user can access</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line">diff --git a/kernel/trap.c b/kernel/trap.c</span><br><span class="line">index a63249e..ffa887c <span class="number">100644</span></span><br><span class="line">--- a/kernel/trap.c</span><br><span class="line">+++ b/kernel/trap.c</span><br><span class="line">@@ <span class="number">-65</span>,<span class="number">14</span> +<span class="number">65</span>,<span class="number">62</span> @@ usertrap(<span class="type">void</span>)</span><br><span class="line">     intr_on();</span><br><span class="line"> </span><br><span class="line">     syscall();</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>)&#123;</span><br><span class="line">+      <span class="comment">// cannot write va in pagetable</span></span><br><span class="line">+      <span class="comment">// copy mem</span></span><br><span class="line">+      uint64 stval = PGROUNDDOWN(r_stval());</span><br><span class="line">+      <span class="type">char</span> *mem;</span><br><span class="line">+      <span class="type">pte_t</span> *pte;</span><br><span class="line">+      uint flags;</span><br><span class="line">+      <span class="keyword">if</span>((pte = walk(p-&gt;pagetable, stval, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">+      &#123;</span><br><span class="line">+          panic(<span class="string">&quot;write page, cannot walk pte&quot;</span>);</span><br><span class="line">+      &#125;</span><br><span class="line">+      <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">+      &#123;</span><br><span class="line">+          panic(<span class="string">&quot;write page, walk pte, but not valid&quot;</span>);</span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">+      <span class="comment">// if w=0 &amp;&amp; c=1</span></span><br><span class="line">+      <span class="keyword">if</span>(((*pte &amp; PTE_W) == <span class="number">0</span> ) &amp;&amp; ((*pte &amp; PTE_C) != <span class="number">0</span>))&#123;</span><br><span class="line">+          <span class="comment">//alloc and copy mem</span></span><br><span class="line">+          uint64 pa = PTE2PA(*pte);</span><br><span class="line">+          <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">+              panic(<span class="string">&quot;fail to alloc new mem in cow fork&quot;</span>);</span><br><span class="line">+</span><br><span class="line">+          memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">+          <span class="comment">//old pa should cnt --</span></span><br><span class="line">+          kfree((<span class="type">void</span> *)pa);</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">// set w = 1, and c = 0</span></span><br><span class="line">+          flags = PTE_FLAGS(*pte);</span><br><span class="line">+          flags |= PTE_W;</span><br><span class="line">+          flags &amp;= ~PTE_C;</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//change child pte</span></span><br><span class="line">+          uint64 new_pte = PA2PTE((uint64)mem);</span><br><span class="line">+          new_pte &amp;= ~(<span class="number">0x3FF</span>);</span><br><span class="line">+          new_pte |= flags;</span><br><span class="line">+          *pte = new_pte;</span><br><span class="line">+          sfence_vma();</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// ok</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (r_scause() == <span class="number">12</span> || r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">+        <span class="type">pte_t</span> *debug_pte = walk(p-&gt;pagetable, r_stval(), <span class="number">0</span>);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;Fault info: VA=%p, PTE_VAL=%p, Flags=%p\n&quot;</span>, r_stval(), *debug_pte, PTE_FLAGS(*debug_pte));</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d, name = %s\n&quot;</span>, r_scause(), p-&gt;pid, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">     p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index d5a12a0..<span class="number">82</span>eab08 <span class="number">100644</span></span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ <span class="number">-148</span>,<span class="number">8</span> +<span class="number">148</span>,<span class="number">10</span> @@ mappages(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">-    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">+    <span class="keyword">if</span>(*pte &amp; PTE_V)&#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;panic: %p\n&quot;</span>, *pte);</span><br><span class="line">       panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">     *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">     <span class="keyword">if</span>(a == last)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">@@ <span class="number">-303</span>,<span class="number">7</span> +<span class="number">305</span>,<span class="number">7</span> @@ uvmcopy(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span><br><span class="line">   <span class="type">pte_t</span> *pte;</span><br><span class="line">   uint64 pa, i;</span><br><span class="line">   uint flags;</span><br><span class="line">-  <span class="type">char</span> *mem;</span><br><span class="line">+  <span class="comment">//char *mem;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">     <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">@@ <span class="number">-311</span>,<span class="number">7</span> +<span class="number">313</span>,<span class="number">17</span> @@ uvmcopy(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span><br><span class="line">     <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">       panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">     pa = PTE2PA(*pte);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">//set pte w=0, c=1</span></span><br><span class="line">+    <span class="keyword">if</span>(((*pte) &amp; PTE_W) !=<span class="number">0</span> )&#123;</span><br><span class="line">+        (*pte) &amp;= ~PTE_W;</span><br><span class="line">+        (*pte) |= PTE_C;</span><br><span class="line">+    &#125;</span><br><span class="line">     flags = PTE_FLAGS(*pte);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">//add pa_mem_cnt</span></span><br><span class="line">+    kmem_py_mem_cnt_add(pa);</span><br><span class="line">+    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     if((mem = kalloc()) == 0)</span></span><br><span class="line"><span class="comment">       goto err;</span></span><br><span class="line"><span class="comment">     memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line"><span class="comment">@@ -319,7 +331,17 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</span></span><br><span class="line"><span class="comment">       kfree(mem);</span></span><br><span class="line"><span class="comment">       goto err;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">+</span></span><br><span class="line"><span class="comment">+    */</span></span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span>(mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;mappage new pagetable fail\n&quot;</span>);</span><br><span class="line">+        <span class="keyword">goto</span> err;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">   &#125;</span><br><span class="line">+  sfence_vma();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  err:</span><br><span class="line">@@ <span class="number">-356</span>,<span class="number">12</span> +<span class="number">378</span>,<span class="number">51</span> @@ copyout(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span><br><span class="line">     n = PGSIZE - (dstva - va0);</span><br><span class="line">     <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">       n = len;</span><br><span class="line">-    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// liangji add </span></span><br><span class="line">+    <span class="type">pte_t</span> *pte;</span><br><span class="line">+    <span class="type">char</span> *mem = (<span class="type">char</span>*)pa0;</span><br><span class="line">+    uint flags;</span><br><span class="line">+    <span class="keyword">if</span>((pte = walk(pagetable, va0, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        panic(<span class="string">&quot;write page, cannot walk pte&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        panic(<span class="string">&quot;write page, walk pte, but not valid&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// if w=0 &amp;&amp; c=1</span></span><br><span class="line">+    <span class="keyword">if</span>(((*pte &amp; PTE_W) == <span class="number">0</span> ) &amp;&amp; ((*pte &amp; PTE_C) != <span class="number">0</span>))&#123;</span><br><span class="line">+          <span class="comment">//alloc and copy mem</span></span><br><span class="line">+          <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">+              panic(<span class="string">&quot;fail to alloc new mem in cow fork&quot;</span>);</span><br><span class="line">+          memmove((<span class="type">void</span>*)(uint64)mem, (<span class="type">void</span>*)pa0, PGSIZE);</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//old pa should cnt --</span></span><br><span class="line">+          kfree((<span class="type">void</span> *)pa0);</span><br><span class="line">+          </span><br><span class="line">+          <span class="comment">// set w = 1, and c = 0</span></span><br><span class="line">+          flags = PTE_FLAGS(*pte);</span><br><span class="line">+          flags |= PTE_W;</span><br><span class="line">+          flags &amp;= ~PTE_C;</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//change child pte</span></span><br><span class="line">+          uint64 new_pte = PA2PTE((uint64)mem);</span><br><span class="line">+          new_pte &amp;= ~(<span class="number">0x3FF</span>);</span><br><span class="line">+          new_pte |= flags;</span><br><span class="line">+          *pte = new_pte;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">//memmove((void *)(pa0 + (dstva - va0)), src, n);</span></span><br><span class="line">+    memmove((<span class="type">void</span> *)((uint64)mem + (dstva - va0)), src, n);</span><br><span class="line"> </span><br><span class="line">     len -= n;</span><br><span class="line">     src += n;</span><br><span class="line">     dstva = va0 + PGSIZE;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">+  sfence_vma();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="usertests分析"><a href="#usertests分析" class="headerlink" title="usertests分析"></a>usertests分析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cow-fork&quot;&gt;&lt;a href=&quot;#cow-fork&quot; class=&quot;headerlink&quot; title=&quot;cow fork&quot;&gt;&lt;/a&gt;cow fork&lt;/h1&gt;&lt;h2 id=&quot;存储空间定义&quot;&gt;&lt;a href=&quot;#存储空间定义&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="XV6" scheme="http://example.com/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab4</title>
    <link href="http://example.com/2026/01/31/xv6-lab4/"/>
    <id>http://example.com/2026/01/31/xv6-lab4/</id>
    <published>2026-01-31T04:39:32.000Z</published>
    <updated>2026-02-20T13:51:20.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="backtrace"><a href="#backtrace" class="headerlink" title="backtrace"></a>backtrace</h1><h2 id="理解trampoline-trap-trampoline"><a href="#理解trampoline-trap-trampoline" class="headerlink" title="理解trampoline -&gt; trap -&gt; trampoline"></a>理解trampoline -&gt; trap -&gt; trampoline</h2><p>从用户到内核<br>我们可以把这个过程想象成一次“紧急避险”。</p><p><strong>1. 第一阶段：（uservec）(trampoline.S)</strong></p><p>这是Trap发生后的第一站。此时最尴尬的是：所有登记都存着用户的数据，你一个都不能动，不然用户数据就丢了。</p><p><code>交换a0</code>：利用sscratch寄存器，先把用户的a0内存，换回一个指向的TRAPFRAME地址。</p><p><code>保存现场</code>：现在有了a0指向的TRAPFRAME空间，赶紧把剩下的31个已注册的全存进去。</p><p><code>加载内核环境</code>：从TRAPFRAME里加载内核栈、内核页表、usertrap的地址。(这些在第一次进程创建的时候，通过trap获取到的，之后都是fork复制)</p><p><code>跳入C语言</code>：跳转到<strong>usertrap</strong>。</p><p><strong>2. 第二阶段：usertrap(trap.c)</strong></p><p>到了这里，我们已经进入了真正的内核世界。</p><p><code>修改中断提示</code>：把<code>stvec</code>改成指向kernelvec。因为现在已经在内核了，如果再发生中断，处理方式和在用户状态是不一样的。</p><p><code>分流处理</code>：</p><ul><li><p>如果是ecall（系统调用），调syscall()。</p></li><li><p>如果是硬件中断，调节devintr()。</p></li><li><p>如果是非法操作，杀掉进程。</p></li></ul><p><strong>3. 第三阶段：返回 (usertrapret -&gt; userret)(trap.c-&gt;trampoline.S)</strong></p><p>原路返回，但在userret自定义里，会satp切回用户页表，并恢复所有用户注册，最后执行sret回到用户态。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">用户态 (User Mode)           |    内核态 (Supervisor Mode)</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">[ 执行用户程序 ]              |</span><br><span class="line">      |                      |</span><br><span class="line">(发生 Trap: ecall/中断)        |</span><br><span class="line">      |                      |</span><br><span class="line">      V                      |</span><br><span class="line">[ TRAMPOLINE (uservec) ] &lt;---|--- <span class="number">1.</span> 硬件将 PC 指向这里 (stvec)</span><br><span class="line">      |                      |    <span class="number">2.</span> 还在使用【用户页表】</span><br><span class="line">      | (保存寄存器到         |</span><br><span class="line">      |  TRAPFRAME)          |</span><br><span class="line">      |                      |</span><br><span class="line">      | (切换 satp) --------&gt;|--- <span class="number">3.</span> 切换到【内核页表】</span><br><span class="line">      |                      |</span><br><span class="line">      V                      |</span><br><span class="line">[ usertrap (C code) ]        |--- <span class="number">4.</span> 处理业务逻辑</span><br><span class="line">      |                      |</span><br><span class="line">      V                      |</span><br><span class="line">[ TRAMPOLINE (userret) ] &lt;---|--- <span class="number">5.</span> 准备切回用户态</span><br><span class="line">      |                      |</span><br><span class="line">      | (切换 satp) --------&gt;|--- <span class="number">6.</span> 切换回【用户页表】</span><br><span class="line">      |                      |</span><br><span class="line">      V                      |</span><br><span class="line">(执行 sret) ----------------&gt;|--- <span class="number">7.</span> 回到用户程序下一行</span><br></pre></td></tr></table></figure><p><strong>重点理解：<code>Trapframe</code>到底是什么？</strong></p><p><code>对用户状态（用户层）而言</code>：它是唯一的避风港，用于暂存那32个注册。</p><p><code>对内核态（C语言层）而言</code>：它是一个结构体struct trapframe，内核可以随时读取或修改用户之前留下的寄存器值（比如获取系统调用的参数）。</p><p><code>Trampoline</code>：代码中转站。在两个页表里的地址完全一样，保证切换页表时代码不会跑飞。</p><p><code>Trapframe</code>：数据中转站。保存了用户的注册，也保存了内核需要用于“接手”的参数（如内核栈指针）。</p><h2 id="从TRAPFRAME里面写入内核Usertrap栈的一些地址是物理地址吗？什么时候写到trapframe中的？"><a href="#从TRAPFRAME里面写入内核Usertrap栈的一些地址是物理地址吗？什么时候写到trapframe中的？" class="headerlink" title="从TRAPFRAME里面写入内核Usertrap栈的一些地址是物理地址吗？什么时候写到trapframe中的？"></a>从TRAPFRAME里面写入内核Usertrap栈的一些地址是物理地址吗？什么时候写到trapframe中的？</h2><p>不是，它们都是<code>内核页表的虚拟地址</code>。</p><p><code>内核页表地址（kernel_satp）</code>：这是一个要写入<code>satp</code>注册的值，虽然satp最终指向物理内存，但在代码逻辑层面，我们把它当作内核地址空间的“根”。</p><p><code>内核栈指针（kernel_sp）</code>：这是<code>内核栈</code>在<code>内核页表中</code>的虚拟地址。</p><p><code>usertrap指针</code>：这是<code>usertrap函数(trap.c)</code>在内核页表中的虚拟地址。</p><p>为什么必须是虚拟地址？ 因为在 <code>uservec</code> 执行过程中，一旦你完成了 csrw satp, a1（切换页表）这一行指令，CPU 的 MMU 就会立即按照新页表（<code>内核页表</code>）来解析地址。<code>如果此时 sp 或跳转地址是物理地址</code>，而内核页表没做等值映射（Identity Mapping），程序就会立刻崩溃</p><h3 id="关于什么时候创建的trapframe中的内核状态？"><a href="#关于什么时候创建的trapframe中的内核状态？" class="headerlink" title="关于什么时候创建的trapframe中的内核状态？"></a>关于什么时候创建的trapframe中的内核状态？</h3><p><strong>1. 第一个进程 (initproc) 的“无中生有”</strong></p><p>init 进程不是被 fork 出来的，而是由内核手动“捏”出来的。</p><p>内核启动：在 <code>main.c</code> 中调用 <code>userinit()</code>。</p><p>手动搭建：userinit <code>调用 allocproc</code> 分配 <code>trapframe</code> 和 <code>kstack</code>。</p><p>伪造现场：内核手动把初始的用户指令（即 <code>initcode.S</code> 编译后的二进制）<code>加载到用户内存起始位置</code>。</p><p>设置“返程票”：</p><p>它手动设置 p-&gt;trapframe-&gt;epc &#x3D; 0（这样返回用户态后从第 0 行开始执行）。</p><p>它手动设置 p-&gt;trapframe-&gt;sp &#x3D; PGSIZE（用户栈顶）。</p><p>第一次“返回”：虽然它从来没去过用户态，但内核通过 scheduler 调度它，走 forkret -&gt; <code>usertrapret</code>。</p><p>关键点：就在这里，执行了你之前搜到的那行代码，把 kernel_sp、kernel_satp 等信息填进了 trapframe。</p><p>着陆：执行 userret，跳入用户态执行 init。</p><p>此时，第一个进程的 trapframe 已经完美初始化了。</p><p><strong>2. 后续进程的“克隆”</strong></p><p>一旦有了第一个进程，剩下的确实如你所说，大多是通过 fork() 产生的。</p><p>fork() 的逻辑：<br>完全拷贝：fork 会调用 uvmcopy 拷贝父进程的物理内存，也会拷贝父进程的 trapframe 内容。</p><p><code>子进程的微调</code>：</p><p>fork 会把子进程 trapframe 里的 a0 寄存器强制设为 0（这就是为什么 if(fork() &#x3D;&#x3D; 0) 能判断出子进程）。</p><p>继承“路标”：因为父进程的 trapframe 里已经写好了正确的 kernel_sp、kernel_satp 等内核路标，子进程拷贝过去后，下次发生 Trap 时，子进程也能顺利找到内核的路。</p><p><strong>3. 修正一个小细节：kernel_sp 真的能完全拷贝吗？</strong></p><p>这里有一个非常细微但重要的点：每个进程的内核栈（kstack）是独立的。</p><p>虽然 fork 拷贝了父进程 trapframe 的大部分内容，但子进程必须拥有自己独立的内核栈指针。</p><p>在 fork() 调用 allocproc() 时，allocproc 会为子进程分配一个新的 kstack。</p><p>随后在 <code>usertrapret 返回用户态之前</code>，那行 <code>p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE</code>; 会再次执行。</p><p>这意味着：<code>即使是从父进程拷贝过来的旧 kernel_sp，也会在返回用户态前的最后一刻，被修正为子进程自己的内核栈地址</code>。</p><p><strong>总结你的疑问</strong></p><ul><li><p><strong>第一个进程</strong>：通过 userinit 手动创建，在第一次通过 usertrapret “返回”用户态时填满 trapframe。</p></li><li><p><strong>后续进程</strong>：通过 fork 拷贝。虽然拷贝了父进程的 trapframe，但每个进程在每次离开内核前，都会通过 usertrapret 重新刷新一遍 trapframe 里的内核信息，确保万无一失。</p></li></ul><p><code>stvec寄存器</code>: 告诉CPU，当异常或中断（Trap）发生时，该跳到哪行代码去执行。</p><h2 id="页面错误异常的应用"><a href="#页面错误异常的应用" class="headerlink" title="页面错误异常的应用"></a>页面错误异常的应用</h2><p>可以利用页面错误异常+页表，来实现：</p><ol><li><p>COW fork（写时复制）</p><p>一开始父子进程共享一片物理内存，当开始写时，发生访问异常，进行复制，一般用在fork+exec处，因为父进程的内容是没什么用的。</p></li><li><p>惰性sbrk</p><p>不是一次性的直接拓展完成，而是随着时间推移，当访问到了再开辟。</p></li><li><p>demand paging</p><p> 由于应用程序可能很大并且从磁盘读取数据的成本很高，因此这种启动成本可能会引起用户的注意：当用户从 shell 启动大型应用程序时，用户可能需要很长时间才能看到响应。<strong>为了缩短响应时间</strong>，现代内核为用户地址空间创建页表，但将页面的 PTE 标记为无效。发生页面错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。</p></li><li><p>paging to disk</p><p> 只将一部分用户页面存储在 RAM 中，并将其余部</p></li></ol><p>分存储在磁盘上 paging area，不在 RAM 中的内存相对<br>应的 PTE 标记为无效</p><h2 id="关于内核栈的结构"><a href="#关于内核栈的结构" class="headerlink" title="关于内核栈的结构"></a>关于内核栈的结构</h2><p>在 RISC-V 中，<code>栈帧的结构并不是由 C 语言的 struct 定义的</code>，而是由 编译器（<code>GCC</code>）的<code>调用约定</code>（Calling Convention） 决定的。</p><p>根据讲义和提示，RISC-V 的栈<code>向下增长</code>（从高地址往低地址），而 <code>s0</code> 寄存器（即<code>帧指针 fp</code>）指向<code>当前栈帧的顶部</code>（<code>高地址端</code>）。</p><p>内核栈中的最小单元是一个帧，里面的结构如下：<br><img src="/../images/19.1.png" alt="alt text"></p><p>当前帧指针fp指向的是每一帧的最高地址。<br>但是读取每一个内容还是从低地址到高地址来读取，</p><p>所以fp-8是<code>该帧的返回地址</code> 的起始低地址，表示<code>调用当前函数后的下一条指令</code></p><p>fp-16就是<code>上一帧的最高地址</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">地址偏移        存储内容                    说明</span><br><span class="line">fp - <span class="number">8</span>        返回地址 (Return Address)指向调用当前函数后的下一条指令。</span><br><span class="line">fp - <span class="number">16</span>        前一个 fp (Previous Frame Pointer)指向调用者（Caller）的栈帧起始位置。</span><br><span class="line">&lt;fp - <span class="number">16</span>    局部变量/被保存的寄存器    函数内部使用的其他数据。</span><br></pre></td></tr></table></figure><blockquote><p><strong>那这个s0读出来的fp内核栈的栈帧指针，和sp指针有什么区别呢？</strong></p><p>sp 是为了让程序跑下去，而 s0 是为了让程序能“回头”。 不管是 s0 还是 sp，在开启虚拟内存的 xv6 内核中，它们<code>指向的都是内核虚拟地址</code>。</p></blockquote><p>虽然它们都指向内核栈，但分工完全不同</p><ul><li><p><code>sp (栈指针)</code></p><p>动态变化： 它是“最前线”的指针。每当函数内部定义局部变量、压栈寄存器时，sp 就会不断地向下移动（向低地址增长）。</p></li></ul><blockquote><p>用途： 它是 CPU 寻找当前栈顶的唯一依据。</p></blockquote><ul><li><p><code>s0 / fp (帧指针)</code>：</p><p>  静态快照： 当一个函数刚开始运行（函数序言阶段）时，它会将当前的 sp 记录在 s0 中。</p></li></ul><blockquote><p>用途： 在整个函数执行期间，<code>s0 的值保持不变。它就像是一个锚点</code>，无论 sp 怎么折腾，函数都可以通过 s0 加上固定的偏移量来找到函数的局部变量、返回地址和调用者的 fp。</p></blockquote><p><strong>如何理解“当前帧（Current Frame）?</strong></p><p>当 Function A 调用 Function B 时：</p><ul><li><p>栈上会开辟一块新的领地（Frame）。</p></li><li><p>这块领地的“大门”地址就存放在 s0 (fp) 里。</p></li><li><p>在这块领地内，<code>Function B </code>存放着它的局部变量。</p></li><li><p>由于 <code>s0 指向当前帧的“起点”（高地址端）</code>，而 xv6 的布局规定：</p></li><li><p>s0 - 8 固定存放当前函数的返回地址 (ra)。</p></li><li><p>s0 - 16 固定存放上一个函数的帧指针 (previous fp)。</p></li></ul><p>这就形成了一条链表。backtrace 实验其实就是在遍历这个以 s0 为头节点的单向链表。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">内核栈页面 (Kernel Stack Page)</span><br><span class="line">+---------------------------+ &lt;--- PGROUNDUP(fp) (栈底，起始地址)</span><br><span class="line">|      ... 上一帧 ...        |</span><br><span class="line">+---------------------------+</span><br><span class="line">|  Saved Return Address     | &lt;--- 当前 s0 - <span class="number">8</span> (这就是你要打印的地址)</span><br><span class="line">+---------------------------+</span><br><span class="line">|  Saved Previous fp  ------+-----&gt; 指向上一帧的 s0</span><br><span class="line">+---------------------------+ &lt;--- 当前 s0 (fp) 的位置</span><br><span class="line">|      局部变量              |</span><br><span class="line">|      ...                  |</span><br><span class="line">|      临时数据              |</span><br><span class="line">+---------------------------+ &lt;--- 当前 sp (指向最底部的动态位置)</span><br><span class="line">|                           |</span><br><span class="line">+---------------------------+ &lt;--- PGROUNDDOWN(fp) (栈顶边界，循环终止处)</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么不用 sp 做 backtrace？</strong> </p><p>因为 sp 是不固定的。编译器在不同的优化等级下，局部变量占用的空间可能不同，导致返回地址相对于 sp 的距离不固定。而返回地址相对于 s0 的偏移总是固定的（-8 和 -16）</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>该backtrace，其实就是把内核栈的东西溯源，打印出来，上面已经分析了内核栈的结构，当在sys_sleep中测试完成后，即可合并到panic中，这样，当出现panic之前，cpu会把当前的内核栈的函数调用全部打印出来。这样就可以知道是什么原因导致内核死掉了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From <span class="number">81</span>a2d27242d2d285b7ac70d7b733297f6b161685 Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Sat, <span class="number">31</span> Jan <span class="number">2026</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">42</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH <span class="number">1</span>/<span class="number">2</span>] feat: support <span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> kernel/defs.h    |  1 +</span><br><span class="line"> kernel/<span class="built_in">printf</span>.c  | 25 +++++++++++++++++++++++++</span><br><span class="line"> kernel/riscv.h   |  9 +++++++++</span><br><span class="line"> kernel/sysproc.c |  1 +</span><br><span class="line"> 4 files changed, 36 <span class="title function_">insertions</span><span class="params">(+)</span></span><br><span class="line"></span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index 3564db4..9224b0f 100644</span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ -80,6 +80,7 @@ <span class="type">int</span>             <span class="title function_">pipewrite</span><span class="params">(<span class="keyword">struct</span> pipe*, uint64, <span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*, ...)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">panic</span><span class="params">(<span class="type">char</span>*)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// proc.c</span></span><br><span class="line"> <span class="type">int</span>             <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/kernel/<span class="built_in">printf</span>.c b/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">index e1347de..ec8d335 <span class="number">100644</span></span><br><span class="line">--- a/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">+++ b/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">@@ <span class="number">-114</span>,<span class="number">6</span> +<span class="number">114</span>,<span class="number">30</span> @@ <span class="built_in">printf</span>(<span class="type">char</span> *fmt, ...)</span><br><span class="line">     release(&amp;pr.lock);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">// seu liangji add</span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">backtrace</span><span class="params">()</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="comment">//<span class="doctag">TODO:</span> trace the function call on the stack above the point </span></span><br><span class="line">+    <span class="comment">//at which the error occurred.</span></span><br><span class="line">+    uint64 fp = r_fp();</span><br><span class="line">+    uint64 kernel_stack_top = PGROUNDUP(fp);</span><br><span class="line">+    uint64 kernel_stack_bottom = PGROUNDDOWN(fp);</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">+    <span class="keyword">while</span>(fp &gt;= kernel_stack_bottom &amp;&amp; fp &lt; kernel_stack_top)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="comment">// get the return address</span></span><br><span class="line">+        uint64 ret_addr = *(uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">+</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ret_addr);</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// set fp = last stack frame point</span></span><br><span class="line">+        fp = *(uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> <span class="title function_">panic</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line"> &#123;</span><br><span class="line">@@ <span class="number">-122</span>,<span class="number">6</span> +<span class="number">146</span>,<span class="number">7</span> @@ panic(<span class="type">char</span> *s)</span><br><span class="line">   <span class="built_in">printf</span>(s);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   panicked = <span class="number">1</span>; <span class="comment">// freeze uart output from other CPUs</span></span><br><span class="line">+  backtrace();</span><br><span class="line">   <span class="keyword">for</span>(;;)</span><br><span class="line">     ;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/kernel/riscv.h b/kernel/riscv.h</span><br><span class="line">index <span class="number">1691f</span>af..<span class="number">7</span>de406b <span class="number">100644</span></span><br><span class="line">--- a/kernel/riscv.h</span><br><span class="line">+++ b/kernel/riscv.h</span><br><span class="line">@@ <span class="number">-364</span>,<span class="number">3</span> +<span class="number">364</span>,<span class="number">12</span> @@ sfence_vma()</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br><span class="line"> <span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br><span class="line">+</span><br><span class="line">+<span class="comment">// gcc will put fp-&gt;now function into s0 register</span></span><br><span class="line">+<span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line">+r_fp()</span><br><span class="line">+&#123;</span><br><span class="line">+  uint64 x;</span><br><span class="line">+  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">+  <span class="keyword">return</span> x;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index e8bcda9..<span class="number">5f</span>0d204 <span class="number">100644</span></span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ <span class="number">-57</span>,<span class="number">6</span> +<span class="number">57</span>,<span class="number">7</span> @@ sys_sleep(<span class="type">void</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   uint ticks0;</span><br><span class="line">+  backtrace();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h1><p><strong>实验要求解析</strong>：<br>按他的实验要求，就是要求用户进程先调用系统调用sigalarm，标记上该进程的tick阈值，以及用户进程中的回调函数。然后用户进程持续运行。</p><p>之后每当内核的计时器中断（1个tick一次中断，进入usertrap），对该进程的tick计数开始增加，当增加到tick阈值后，触发一次中断回调函数。</p><p>该<strong>实验的核心</strong>就在于，<strong>如何在内核态的中断事件中，执行用户态的函数</strong>。</p><blockquote><p><strong>Unix 信号机制（Signal）</strong> 工作原理：</p><p><code>注册</code>：用户程序告诉内核“如果发生某事，请运行函数 X”。</p><p><code>触发</code>：内核在处理中断&#x2F;异常时发现满足条件。</p><p><code>传递</code>：内核在返回用户态前，强行修改用户的 PC 指针和栈。</p><p><code>执行</code>：用户执行函数 X。</p><p><code>恢复</code>：执行完后通过系统调用回到原始状态。</p></blockquote><p>所以要实现这个signal机制，需要先对xv6的整个用户态和内核态的切换做一个系统的理解</p><h2 id="用户态内核态切换分析"><a href="#用户态内核态切换分析" class="headerlink" title="用户态内核态切换分析"></a>用户态内核态切换分析</h2><p>下面总结以下，risc v xv6 从用户态-内核态-用户态的一个过程：</p><p><strong>1. cpu的核心控制状态寄存器（CSR）</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────┬────────────────────────────────────────────┐</span><br><span class="line">│   寄存器     │                    作用                    │</span><br><span class="line">├─────────────┼────────────────────────────────────────────┤</span><br><span class="line">│   stvec     │ Trap入口地址 (指向 uservec)                 │</span><br><span class="line">│   sepc      │ 保存触发Trap时的用户PC                      │</span><br><span class="line">│   scause    │ Trap原因 (syscall=<span class="number">8</span>, 中断, 异常等)          │</span><br><span class="line">│   sscratch  │ 中转站: 用户态时存trapframe地址             │</span><br><span class="line">│   sstatus   │ 状态寄存器 (SPP位记录之前的特权级)           │</span><br><span class="line">│   satp      │ 页表基址寄存器                              │</span><br><span class="line">│   x0-x31,sp │ cpu的通用寄存器                              │</span><br><span class="line">└─────────────┴────────────────────────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 完整流程图</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">用户态 (U-Mode)                        内核态 (S-Mode)</span><br><span class="line">══════════════                        ═══════════════</span><br><span class="line">      │</span><br><span class="line">      │  用户程序执行 write() 等系统调用</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────┐</span><br><span class="line"> │  ecall  │  ←── 用户代码触发陷入</span><br><span class="line"> └────┬────┘</span><br><span class="line">      │</span><br><span class="line">      │ ┌──────────────────────────────────┐</span><br><span class="line">      │ │  ★ 硬件自动完成 (瞬间)            │</span><br><span class="line">      │ │  <span class="number">1.</span> sepc ← PC (保存用户PC)        │</span><br><span class="line">      │ │  <span class="number">2.</span> 切换到 S-Mode                 │</span><br><span class="line">      │ │  <span class="number">3.</span> PC ← stvec (跳转到uservec)    │</span><br><span class="line">      │ │  <span class="number">4.</span> scause ← <span class="number">8</span> (syscall)         │</span><br><span class="line">      │ └──────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────────────────────────────────────────────────┐</span><br><span class="line"> │              uservec (trampoline.S)                 │</span><br><span class="line"> │  ─────────────────────────────────────────────────  │</span><br><span class="line"> │  此时: S-Mode + 用户页表 + 用户寄存器                │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">1.</span> <span class="comment">//a0指向trapframe                                  │</span></span><br><span class="line"> │     csrrw a0, sscratch, a0                          │</span><br><span class="line"> │     (a0 ↔ sscratch, 现在a0指向trapframe)            │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">2.</span> sd ra, <span class="number">40</span>(a0)   <span class="comment">// 保存用户态所有通用寄存器，包括sp到trapframe  │</span></span><br><span class="line"> │     sd sp, <span class="number">48</span>(a0)                                   │</span><br><span class="line"> │     sd t0, <span class="number">56</span>(a0)                                   │</span><br><span class="line"> │     ...                                             │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">3.</span> ld sp, <span class="number">8</span>(a0)    <span class="comment">// 切换内核态 栈指针                 │</span></span><br><span class="line"> │     ld tp, <span class="number">32</span>(a0)   <span class="comment">// 加载 hartid                   │</span></span><br><span class="line"> │     ld t0, <span class="number">16</span>(a0)   <span class="comment">// 加载 下一个跳转指令usertrap 地址到寄存器            │</span></span><br><span class="line"> │     ld t1, <span class="number">0</span>(a0)    <span class="comment">// 加载 内核页表 到寄存器                  │</span></span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">4.</span> csrw satp, t1   <span class="comment">// 切换到内核页表                 │</span></span><br><span class="line"> │     sfence.vma      <span class="comment">// 刷新 TLB                      │</span></span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">5.</span> jr t0           <span class="comment">// 跳转到 usertrap()             │</span></span><br><span class="line"> └─────────────────────────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────────────────────────────────────────────────┐</span><br><span class="line"> │              usertrap() (trap.c)                    │</span><br><span class="line"> │  ─────────────────────────────────────────────────  │</span><br><span class="line"> │  此时: S-Mode + 内核页表 + 内核栈                    │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">1.</span> 修改 stvec 指向 kernelvec (防止嵌套trap)        │</span><br><span class="line"> │  <span class="number">2.</span> 保存 sepc 到 p-&gt;trapframe-&gt;epc                  │</span><br><span class="line"> │  <span class="number">3.</span> 判断 scause:                                    │</span><br><span class="line"> │     - syscall → syscall()                          │</span><br><span class="line"> │     - 中断    → devintr()                          │</span><br><span class="line"> │     - 异常    → kill process                       │</span><br><span class="line"> │  <span class="number">4.</span> 调用 usertrapret() 准备返回                     │</span><br><span class="line"> └─────────────────────────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────────────────────────────────────────────────┐</span><br><span class="line"> │           usertrapret() (trap.c)                    │</span><br><span class="line"> │  ─────────────────────────────────────────────────  │</span><br><span class="line"> │  <span class="number">1.</span> 关中断                                          │</span><br><span class="line"> │  <span class="number">2.</span> 设置 stvec 指回 uservec                         │</span><br><span class="line"> │  <span class="number">3.</span> 准备 trapframe:                                 │</span><br><span class="line"> │     - kernel_satp, kernel_sp, usertrap地址          │</span><br><span class="line"> │  <span class="number">4.</span> 设置 sstatus (SPP=<span class="number">0</span>, SPIE=<span class="number">1</span>)                    │</span><br><span class="line"> │  <span class="number">5.</span> 设置 sepc = p-&gt;trapframe-&gt;epc                   │</span><br><span class="line"> │  <span class="number">6.</span> 计算用户页表 satp 值                             │</span><br><span class="line"> │  <span class="number">7.</span> 跳转到 userret (在trampoline中)                 │</span><br><span class="line"> └─────────────────────────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────────────────────────────────────────────────┐</span><br><span class="line"> │              userret (trampoline.S)                 │</span><br><span class="line"> │  ─────────────────────────────────────────────────  │</span><br><span class="line"> │  参数: a0=trapframe地址, a1=用户satp                │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">1.</span> csrw satp, a1   <span class="comment">// 切换回用户页表                 │</span></span><br><span class="line"> │     sfence.vma      <span class="comment">// 刷新 TLB                      │</span></span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">2.</span> ld ra, <span class="number">40</span>(a0)   <span class="comment">// 从trapframe恢复用户态      │</span></span><br><span class="line"> │     ld sp, <span class="number">48</span>(a0)                                   │</span><br><span class="line"> │     ld t0, <span class="number">56</span>(a0)                                   │</span><br><span class="line"> │     ...                                             │</span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">3.</span> csrw sscratch, a0  <span class="comment">// 把trapframe地址存回sscratch│</span></span><br><span class="line"> │     ld a0, <span class="number">112</span>(a0)     <span class="comment">// 恢复用户态的a0               │</span></span><br><span class="line"> │                                                     │</span><br><span class="line"> │  <span class="number">4.</span> sret            <span class="comment">// 返回用户态!                   │</span></span><br><span class="line"> └─────────────────────────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      │ ┌──────────────────────────────────┐</span><br><span class="line">      │ │  ★ sret 硬件自动完成             │</span><br><span class="line">      │ │  <span class="number">1.</span> PC ← sepc (恢复用户PC)       │</span><br><span class="line">      │ │  <span class="number">2.</span> 切换到 U-Mode (根据SPP)      │</span><br><span class="line">      │ │  <span class="number">3.</span> 开启中断 (根据SPIE)          │</span><br><span class="line">      │ └──────────────────────────────────┘</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line"> ┌─────────┐</span><br><span class="line"> │ 用户代码 │  ←── ecall 的下一条指令继续执行</span><br><span class="line"> └─────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. sscratch的用法总结</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">时间线 ─────────────────────────────────────────────────────────►</span><br><span class="line"></span><br><span class="line">用户态运行时:</span><br><span class="line">┌──────────┐     ┌───────────┐</span><br><span class="line">│ sscratch │ ──► │ trapframe │  (存着trapframe地址，备用)</span><br><span class="line">└──────────┘     └───────────┘</span><br><span class="line">      │</span><br><span class="line">      │  csrrw a0, sscratch, a0 (进入uservec时交换)</span><br><span class="line">      ▼</span><br><span class="line">内核态运行时:</span><br><span class="line">┌──────────┐     </span><br><span class="line">│ sscratch │ ──► 用户的 a0 值  (暂存用户a0)</span><br><span class="line">└──────────┘     </span><br><span class="line">┌──────────┐     ┌───────────┐</span><br><span class="line">│    a0    │ ──► │ trapframe │  (现在用a0访问trapframe)</span><br><span class="line">└──────────┘     └───────────┘</span><br><span class="line">      │</span><br><span class="line">      │  返回前再次交换</span><br><span class="line">      ▼</span><br><span class="line">用户态恢复:</span><br><span class="line">┌──────────┐     ┌───────────┐</span><br><span class="line">│ sscratch │ ──► │ trapframe │  (恢复原状，等待下次trap)</span><br><span class="line">└──────────┘     └───────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4. 页表切换时机</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">          用户页表                    内核页表</span><br><span class="line">         ┌────────┐                  ┌────────┐</span><br><span class="line">         │ 用户代码 │                  │ 内核代码 │</span><br><span class="line">         │ 用户数据 │                  │ 内核数据 │</span><br><span class="line">         │ 用户栈   │                  │ 内核栈   │</span><br><span class="line">         ├────────┤                  ├────────┤</span><br><span class="line"> 相同 ──►│trampoline│◄── 映射到同一物理地址 ──►│trampoline│◄── 相同</span><br><span class="line">         │ (顶部)   │                  │ (顶部)   │</span><br><span class="line">         └────────┘                  └────────┘</span><br><span class="line"></span><br><span class="line">为什么 trampoline 必须在两个页表中映射到相同虚拟地址？</span><br><span class="line">因为切换 satp 的那一刻，PC 还在执行 trampoline 中的代码！</span><br><span class="line">如果地址不同，切换后 PC 就会跳到错误的地方。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>5. trapframe结构布局</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span>    <span class="comment">// 偏移量</span></span><br><span class="line">  uint64 kernel_satp;   <span class="comment">//   0  内核页表</span></span><br><span class="line">  uint64 kernel_sp;     <span class="comment">//   8  内核栈指针</span></span><br><span class="line">  uint64 kernel_trap;   <span class="comment">//  16  usertrap() 地址</span></span><br><span class="line">  uint64 epc;           <span class="comment">//  24  用户 PC (来自sepc)</span></span><br><span class="line">  uint64 kernel_hartid; <span class="comment">//  32  CPU 核心号</span></span><br><span class="line">  uint64 ra;            <span class="comment">//  40  ─┐</span></span><br><span class="line">  uint64 sp;            <span class="comment">//  48   │</span></span><br><span class="line">  uint64 gp;            <span class="comment">//  56   │</span></span><br><span class="line">  uint64 tp;            <span class="comment">//  64   │</span></span><br><span class="line">  uint64 t0-t6;         <span class="comment">//  ...  ├─ 31个通用寄存器</span></span><br><span class="line">  uint64 s0-s11;        <span class="comment">//  ...  │</span></span><br><span class="line">  uint64 a0-a7;         <span class="comment">//  ...  │</span></span><br><span class="line">  ...                   <span class="comment">//      ─┘</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="c语言变量在虚拟内存空间分布"><a href="#c语言变量在虚拟内存空间分布" class="headerlink" title="c语言变量在虚拟内存空间分布"></a>c语言变量在虚拟内存空间分布</h2><p><strong>1. 进程虚拟地址空间布局</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">高地址</span><br><span class="line">┌─────────────────────────────────────┐ <span class="number">0xFFFFFFFF</span> (<span class="number">32</span>位) 或更高</span><br><span class="line">│           内核空间                   │ ← 用户不可访问</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│             栈 (Stack)              │ ← 向下增长 ↓</span><br><span class="line">│         局部变量、函数参数            │</span><br><span class="line">│                 ↓                   │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│                                     │</span><br><span class="line">│           (未分配区域)               │</span><br><span class="line">│                                     │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│                 ↑                   │</span><br><span class="line">│             堆 (Heap)               │ ← 向上增长 ↑</span><br><span class="line">│         <span class="built_in">malloc</span>/new 分配              │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│             BSS 段                   │ ← 未初始化的全局/静态变量</span><br><span class="line">│         (Block Started by Symbol)    │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│            Data 段                   │ ← 已初始化的全局/静态变量</span><br><span class="line">│           (数据段)                   │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│           rodata 段                  │ ← 只读数据 (字符串常量等)</span><br><span class="line">│          (只读数据段)                 │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│           Text 段                    │ ← 代码/指令</span><br><span class="line">│           (代码段)                   │</span><br><span class="line">└─────────────────────────────────────┘ <span class="number">0x00000000</span></span><br><span class="line">低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2. 各变量存储位置</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌────────────────────┬─────────────┬──────────────────────────────┐</span><br><span class="line">│      变量类型       │   存储位置   │            示例              │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ 局部变量            │    栈       │ <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="type">int</span> x = <span class="number">1</span>; &#125;      │</span><br><span class="line">│ 函数参数            │    栈       │ <span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>         │</span><br><span class="line">│ 局部数组            │    栈       │ <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="type">int</span> arr[<span class="number">10</span>]; &#125;    │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ <span class="built_in">malloc</span>/<span class="built_in">calloc</span>/new  │    堆       │ <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">100</span>);        │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ 全局变量(已初始化)   │   Data段    │ <span class="type">int</span> g = <span class="number">100</span>;                 │</span><br><span class="line">│ 静态变量(已初始化)   │   Data段    │ <span class="type">static</span> <span class="type">int</span> s = <span class="number">100</span>;          │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ 全局变量(未初始化)   │   BSS段     │ <span class="type">int</span> g;                       │</span><br><span class="line">│ 静态变量(未初始化)   │   BSS段     │ <span class="type">static</span> <span class="type">int</span> s;                │</span><br><span class="line">│ 初始化为<span class="number">0</span>的全局/静态 │   BSS段     │ <span class="type">int</span> g = <span class="number">0</span>; <span class="type">static</span> <span class="type">int</span> s = <span class="number">0</span>; │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ 字符串常量          │  rodata段   │ <span class="type">char</span> *s = <span class="string">&quot;hello&quot;</span>;           │</span><br><span class="line">│ <span class="type">const</span>全局变量       │  rodata段   │ <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;         │</span><br><span class="line">├────────────────────┼─────────────┼──────────────────────────────┤</span><br><span class="line">│ 函数代码            │   Text段    │ <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123; ... &#125;           │</span><br><span class="line">└────────────────────┴─────────────┴──────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的特殊情况</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;           <span class="type">char</span> s[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">                             </span><br><span class="line">   栈                            栈</span><br><span class="line">┌──────┐                     ┌──────────────┐</span><br><span class="line">│  p   │──────┐              │ h e l l o \<span class="number">0</span> │  ← 数据直接在栈上</span><br><span class="line">└──────┘      │              └──────────────┘</span><br><span class="line">              │              </span><br><span class="line">              ▼              </span><br><span class="line">   rodata段                  </span><br><span class="line">┌──────────────┐             </span><br><span class="line">│ h e l l o \<span class="number">0</span> │  ← 只读！    </span><br><span class="line">└──────────────┘             </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3. static变量的特点</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Data段（或BSS段）里的值直接被修改。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 程序启动时在 BSS段 分配</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    count = <span class="number">5</span>;  <span class="comment">// 直接修改 BSS段 中那个固定地址的值</span></span><br><span class="line">    count++;    <span class="comment">// BSS段 中的值变为 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="alarm解法"><a href="#alarm解法" class="headerlink" title="alarm解法"></a>alarm解法</h2><p>所以<strong>关于如何在内核态执行用户态的回调函数</strong>，<code>不能直接执行</code>，必须通过<code>重返用户态执行</code>，但是重返用户态，又只能重返陷入内核之前的trapframe，也就是继续执行<code>旧的用户态</code>。</p><p>所以<strong>关键</strong>就在于<code>sigreturn()</code>, 这个又是一个系统调用，</p><p>说明<code>如果切换回用户态执行回调函数后，又会执行系统调用陷入内核态</code>, 相当于截断了用户态的执行。</p><p>所以：<strong>解决方案</strong>就是：</p><ul><li>自己<code>新增一个中间的用户态</code>（trapframe）,备份旧的用户态,<code>一个用户态状态就是一个trapframe</code></li></ul><p>   也就是说，我们<code>如果有一个新的用户态，直接飞过去执行用户态回调函数，然后由sigreturn系统调用结束这个用户态</code>。<strong>再次进入内核态</strong>后，才恢复原来的用户态。</p><blockquote><p>这样就相当于可以<code>在原来用户态继续执行前，插入一个用户态的函数执行</code>。</p></blockquote><blockquote><p>并且由于，该回调函数里面只涉及虚拟空间的<strong>代码段</strong>和<strong>data段</strong>，不涉及栈，所以两个用户态可以相互交换信息。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From dd29a06e07bfa92c225fe4434579a2ba2ed1dee3 Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Sat, <span class="number">31</span> Jan <span class="number">2026</span> <span class="number">21</span>:<span class="number">37</span>:<span class="number">21</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH] feat: support signal</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">From <span class="number">642</span>dcb9609338240accf1ff4a0493065414bb16e Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Sat, <span class="number">31</span> Jan <span class="number">2026</span> <span class="number">21</span>:<span class="number">37</span>:<span class="number">21</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH] feat: support signal</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> Makefile         |  <span class="number">1</span> +</span><br><span class="line"> kernel/proc.c    |  <span class="number">6</span> ++++++</span><br><span class="line"> kernel/proc.h    | <span class="number">10</span> ++++++++++</span><br><span class="line"> kernel/syscall.c |  <span class="number">4</span> ++++</span><br><span class="line"> kernel/syscall.h |  <span class="number">2</span> ++</span><br><span class="line"> kernel/sysproc.c | <span class="number">30</span> ++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/trap.c    | <span class="number">31</span> +++++++++++++++++++++++++++++++</span><br><span class="line"> user/user.h      |  <span class="number">4</span> ++++</span><br><span class="line"> user/usys.pl     |  <span class="number">2</span> ++</span><br><span class="line"> <span class="number">9</span> files changed, <span class="number">90</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index <span class="number">7</span>a7e380..<span class="number">8</span>de30a0 <span class="number">100644</span></span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ <span class="number">-183</span>,<span class="number">6</span> +<span class="number">183</span>,<span class="number">7</span> @@ UPROGS=\</span><br><span class="line"> $U/_mkdir\</span><br><span class="line"> $U/_rm\</span><br><span class="line"> $U/_sh\</span><br><span class="line">+$U/_alarmtest\</span><br><span class="line"> $U/_stressfs\</span><br><span class="line"> $U/_usertests\</span><br><span class="line"> $U/_grind\</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index <span class="number">22e7</span>ce4..<span class="number">6</span>c0300b <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ <span class="number">-141</span>,<span class="number">6</span> +<span class="number">141</span>,<span class="number">12</span> @@ found:</span><br><span class="line">   p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">   p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line"> </span><br><span class="line">+  <span class="comment">// init ticks and alarm;</span></span><br><span class="line">+  p-&gt;ticks_cnt = <span class="number">0</span>;</span><br><span class="line">+  p-&gt;ticks_inv = <span class="number">0</span>;</span><br><span class="line">+  p-&gt;func_cb = <span class="number">0</span>;</span><br><span class="line">+  p-&gt;ticks_lock = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index f6ca8b7..<span class="number">4913318</span> <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ <span class="number">-47</span>,<span class="number">6</span> +<span class="number">47</span>,<span class="number">9</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">   <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">   <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">   <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// save common register</span></span><br><span class="line">   <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">   <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">   <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">@@ <span class="number">-105</span>,<span class="number">4</span> +<span class="number">108</span>,<span class="number">11</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">   <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">int</span> ticks_cnt;</span><br><span class="line">+  <span class="type">int</span> ticks_inv;</span><br><span class="line">+  uint64 func_cb;</span><br><span class="line">+  <span class="type">int</span> ticks_lock;</span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe_signal_backup</span>;</span></span><br><span class="line">+</span><br><span class="line"> &#125;;</span><br><span class="line">diff --git a/kernel/syscall.c b/kernel/syscall.c</span><br><span class="line">index c1b3670..a74be20 <span class="number">100644</span></span><br><span class="line">--- a/kernel/syscall.c</span><br><span class="line">+++ b/kernel/syscall.c</span><br><span class="line">@@ <span class="number">-104</span>,<span class="number">6</span> +<span class="number">104</span>,<span class="number">8</span> @@ <span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">6</span> +<span class="number">129</span>,<span class="number">8</span> @@ <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line">+[SYS_sigalarm]   sys_sigalarm,</span><br><span class="line">+[SYS_sigreturn]   sys_sigreturn,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span></span><br><span class="line">diff --git a/kernel/syscall.h b/kernel/syscall.h</span><br><span class="line">index bc5f356..<span class="number">7b</span>88b81 <span class="number">100644</span></span><br><span class="line">--- a/kernel/syscall.h</span><br><span class="line">+++ b/kernel/syscall.h</span><br><span class="line">@@ <span class="number">-20</span>,<span class="number">3</span> +<span class="number">20</span>,<span class="number">5</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SYS_sigalarm  22</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SYS_sigreturn  23</span></span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index <span class="number">5f</span>0d204..<span class="number">79b</span>d1a2 <span class="number">100644</span></span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ <span class="number">-96</span>,<span class="number">3</span> +<span class="number">96</span>,<span class="number">33</span> @@ sys_uptime(<span class="type">void</span>)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   <span class="keyword">return</span> xticks;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">+    <span class="type">int</span> ticks_interval;</span><br><span class="line">+    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks_interval) &lt; <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    uint64 function_callback;</span><br><span class="line">+    <span class="keyword">if</span>(argaddr(<span class="number">1</span>, &amp;function_callback) &lt; <span class="number">0</span>)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+    p-&gt;ticks_inv = ticks_interval;</span><br><span class="line">+    p-&gt;func_cb = function_callback;</span><br><span class="line">+    <span class="comment">//printf(&quot;sys_sigalarm, set p-&gt;ticks_inv = %d, func_cb va = %p\n&quot;, p-&gt;ticks_inv, p-&gt;func_cb);</span></span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">+    memmove(p-&gt;trapframe, p-&gt;trapframe_signal_backup, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">+    p-&gt;ticks_lock = <span class="number">0</span>;</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">diff --git a/kernel/trap.c b/kernel/trap.c</span><br><span class="line">index a63249e..<span class="number">0</span>c62033 <span class="number">100644</span></span><br><span class="line">--- a/kernel/trap.c</span><br><span class="line">+++ b/kernel/trap.c</span><br><span class="line">@@ <span class="number">-49</span>,<span class="number">6</span> +<span class="number">49</span>,<span class="number">37</span> @@ usertrap(<span class="type">void</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// save user program counter.</span></span><br><span class="line">   p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// seu liangji add, to use timer intr</span></span><br><span class="line">+  <span class="keyword">if</span>(devintr() == <span class="number">2</span> &amp;&amp; ((p-&gt;func_cb !=<span class="number">0</span>) || (p-&gt;ticks_inv !=<span class="number">0</span>)))&#123;</span><br><span class="line">+</span><br><span class="line">+      p-&gt;ticks_cnt++;</span><br><span class="line">+</span><br><span class="line">+      <span class="comment">//printf(&quot;p-&gt;ticks_cnt = %d\n&quot;, p-&gt;ticks_cnt);</span></span><br><span class="line">+      <span class="keyword">if</span>( p-&gt;ticks_inv != <span class="number">0</span> &amp;&amp; p-&gt;ticks_cnt &gt;= p-&gt;ticks_inv &amp;&amp; p-&gt;ticks_lock == <span class="number">0</span>)&#123;</span><br><span class="line">+          <span class="comment">//printf(&quot;hint!, cnt = %d\n&quot;, p-&gt;ticks_cnt);</span></span><br><span class="line">+          p-&gt;ticks_cnt = <span class="number">0</span>;</span><br><span class="line">+          <span class="comment">//get lock</span></span><br><span class="line">+          p-&gt;ticks_lock = <span class="number">1</span>;</span><br><span class="line">+          <span class="comment">// need to run signal callback function, first should copy trapframe, and then use sigreturn to return trapframe</span></span><br><span class="line">+          <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">+          acquire(&amp;p-&gt;lock);</span><br><span class="line">+          <span class="keyword">if</span>((p-&gt;trapframe_signal_backup = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">+              panic(<span class="string">&quot;fail to kalloc trapframe_signal_backup&quot;</span>);</span><br><span class="line">+          &#125;</span><br><span class="line">+          release(&amp;p-&gt;lock);</span><br><span class="line">+          <span class="comment">// copy trapframe , old user space</span></span><br><span class="line">+          memmove(p-&gt;trapframe_signal_backup, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">// change user space</span></span><br><span class="line">+          <span class="comment">// because func_cb is just involve static var(BSS), not use stack, so just jump pc to func_cb</span></span><br><span class="line">+          p-&gt;trapframe-&gt;epc = p-&gt;func_cb;</span><br><span class="line">+</span><br><span class="line">+          <span class="comment">//not unlock until sigreturn, callback is ok</span></span><br><span class="line">+          <span class="comment">//p-&gt;ticks_lock = 0;</span></span><br><span class="line">+      &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">     <span class="comment">// system call</span></span><br><span class="line">diff --git a/user/user.h b/user/user.h</span><br><span class="line">index b71ecda..fd97ee2 <span class="number">100644</span></span><br><span class="line">--- a/user/user.h</span><br><span class="line">+++ b/user/user.h</span><br><span class="line">@@ <span class="number">-40</span>,<span class="number">3</span> +<span class="number">40</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *, uint)</span>;</span><br><span class="line"> <span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *, uint)</span>;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">//alarm</span></span><br><span class="line">+<span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line">+<span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/user/usys.pl b/user/usys.pl</span><br><span class="line">index <span class="number">01e426</span>e..fa548b0 <span class="number">100755</span></span><br><span class="line">--- a/user/usys.pl</span><br><span class="line">+++ b/user/usys.pl</span><br><span class="line">@@ <span class="number">-36</span>,<span class="number">3</span> +<span class="number">36</span>,<span class="number">5</span> @@ entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h2><p><strong>1. 必须写sigreturn()系统调用来终止吗？</strong></p><p>在计算机科学中，这被称为信号处理的收尾（Signal Cleanup）。</p><p>虽然看起来麻烦，但<strong>所有的异步信号机制都需要类似的收尾逻辑</strong>。原因是：</p><ul><li><strong>栈和寄存器的隔离</strong>：当信号（或中断）发生时，它是异步的。用户程序可能运行在任何指令处。如果没有一个机制（如系统调用）告诉内核“我已经处理完了，请把刚才偷走的寄存器还给我”，CPU 根本无法自动找回之前的执行状态。</li></ul><p><code>主流系统的做法</code>：</p><blockquote><p><strong>Linux&#x2F;Unix</strong>：实际上也是这么做的。内核会在<code>用户栈上放置一段微型的代码（称为 Signal Trampoline）</code>，这段代码的唯一作用就是执行 sigreturn 系统调用。</p></blockquote><p><code>封装</code>：在标准库（如 Glibc）中，这些细节都被封装好了。程序员只需要写 handler，而库函数会自动帮你处理跳转和收尾。</p><p><strong>2. 对回调函数（Handler）的要求</strong></p><p>你提到的“对栈的要求”切中了要害。</p><p><strong>栈的破坏问题</strong></p><p>目前的实验版本中，<code>handler回调函数</code> 直接运行在原程序的<code>用户栈</code>上。如果：</p><ul><li>handler 函数定义了巨大的局部变量。</li></ul><p>原程序本来就已经快把栈用完了（Stack Overflow）。 那么执行 handler 就会彻底破坏原程序的栈数据，导致 sigreturn 之后原程序依然崩溃。</p><p><strong>解决方案</strong>：<code>信号栈（Signal Stack）</code></p><p>为了解决这个问题，高级系统（如 Linux）允许进程通过 sigaltstack 系统调用<strong>注册一个独立的信号栈</strong>。当信号发生时，内核不但修改 <code>epc</code>，还会修改 trapframe-&gt;<code>sp</code> 指向这个<code>独立的栈空间</code>。</p><p><strong>数据段的影响</strong></p><p>正如你所观察到的，<strong>handler 和原程序共享数据段</strong>：</p><p><code>副作用</code>：如果 handler 修改了全局变量，原程序确实会感知到。</p><p><code>重入性限制</code>：这要求 handler 尽量是“<code>可重入</code>”的。<br>如果在 handler 里调用了像 printf 或 malloc 这样使用了全局锁的函数，而原程序恰好在被中断时也持有这些锁，就会发生死锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;backtrace&quot;&gt;&lt;a href=&quot;#backtrace&quot; class=&quot;headerlink&quot; title=&quot;backtrace&quot;&gt;&lt;/a&gt;backtrace&lt;/h1&gt;&lt;h2 id=&quot;理解trampoline-trap-trampoline&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="XV6" scheme="http://example.com/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab3</title>
    <link href="http://example.com/2026/01/27/xv6-lab3/"/>
    <id>http://example.com/2026/01/27/xv6-lab3/</id>
    <published>2026-01-27T06:56:47.000Z</published>
    <updated>2026-02-20T13:51:20.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h1><p>本节主要学习页表，包括内核的地址空间，物理内存的分配，用户进程的地址空间，页表的作用和实现逻辑等。</p><h2 id="usyscall"><a href="#usyscall" class="headerlink" title="usyscall"></a>usyscall</h2><p>这个实验的目的是希望通过在用户态和内核态之间创建一个只读的共享内存，来加快系统调用。</p><p>正常系统调用，需要系统调用保存参数到cpu寄存器，保存现场到trapframe中，然后ecall，进行内核态的切换，这一系列操作很花时间，主要是内核态的切换比较耗时。</p><p>所以这个实验想要通过共享只读内存的方式，来代替内核态的切换。</p><p>通过观察kernel&#x2F;memlayout.h，可以看出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line"><span class="comment">// for use by the kernel and user pages</span></span><br><span class="line"><span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到，<code>KERNBASE，PHYSTOP</code>，这两个是物理地址。<br>后面的TRAMPOLINE，KSTACK，TRAPFRAME都是指的虚拟内存的一个划分。<br>从这个布局，可以看出，他希望在TRAPFRAME向下，安排一个<strong>新的虚拟内存的区域</strong>，USYSCALL。</p><p>这样也就是要在页表里面，增加这一项的映射关系。</p><p>所以主要的实现，是在进程创建页表的逻辑里面。</p><p>具体实现逻辑如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From b49d8707169474d9c12af12f970f345fb1eab1be Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Thu, <span class="number">29</span> Jan <span class="number">2026</span> <span class="number">21</span>:<span class="number">53</span>:<span class="number">28</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH <span class="number">1</span>/<span class="number">2</span>] support speed up syscall using share user space mem</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> kernel/proc.c | <span class="number">27</span> +++++++++++++++++++++++++++</span><br><span class="line"> kernel/proc.h |  <span class="number">1</span> +</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">28</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index <span class="number">22e7</span>ce4..a09de1b <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">6</span> +<span class="number">127</span>,<span class="number">15</span> @@ found:</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  <span class="comment">// Allocate a usyscall page by liangji</span></span><br><span class="line">+  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">+    freeproc(p);</span><br><span class="line">+    release(&amp;p-&gt;lock);</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+    p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   <span class="comment">// An empty user page table.</span></span><br><span class="line">   p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">@@ <span class="number">-153</span>,<span class="number">6</span> +<span class="number">162</span>,<span class="number">15</span> @@ freeproc(<span class="keyword">struct</span> proc *p)</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">     kfree((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">   p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// liangji free usyscall</span></span><br><span class="line">+  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">+  &#123;</span><br><span class="line">+      kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">+  &#125;</span><br><span class="line">+  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">   p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">@@ <span class="number">-164</span>,<span class="number">6</span> +<span class="number">182</span>,<span class="number">7</span> @@ freeproc(<span class="keyword">struct</span> proc *p)</span><br><span class="line">   p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">   p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">   p-&gt;state = UNUSED;</span><br><span class="line">+</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Create a user page table for a given process,</span></span><br><span class="line">@@ <span class="number">-196</span>,<span class="number">6</span> +<span class="number">215</span>,<span class="number">13</span> @@ proc_pagetable(<span class="keyword">struct</span> proc *p)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  <span class="comment">// map the usyscall just below TRAPFRAME by seu liangji</span></span><br><span class="line">+  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">+              (uint64)(p-&gt;usyscall), PTE_U | PTE_R) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">+    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> pagetable;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-206</span>,<span class="number">6</span> +<span class="number">232</span>,<span class="number">7</span> @@ proc_freepagetable(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span><br><span class="line"> &#123;</span><br><span class="line">   uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">+  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   uvmfree(pagetable, sz);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index f6ca8b7..cb4ba0e <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ <span class="number">-101</span>,<span class="number">6</span> +<span class="number">101</span>,<span class="number">7</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">   uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">   <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vmprint"><a href="#vmprint" class="headerlink" title="vmprint"></a>vmprint</h2><p>这个实验比较简单，就是考察对用户进程的页表创建过程的理解。</p><p>xv6 使用sv39，有3级页表机制来进行从虚拟内存-物理内存的映射。</p><p>根据你提供的 xv6 源代码（<code>vm.c</code>, <code>proc.c</code>, <code>kalloc.c</code>）和参考图片，我为你总结了内核页表创建与进程页表操作的流程笔记。</p><hr><h3 id="1-内核页表创建流程-Kernel-Page-Table-Initialization"><a href="#1-内核页表创建流程-Kernel-Page-Table-Initialization" class="headerlink" title="1. 内核页表创建流程 (Kernel Page Table Initialization)"></a>1. 内核页表创建流程 (Kernel Page Table Initialization)</h3><p>当系统启动进入 <code>main()</code> 函数后，首先会通过 <code>kvminit()</code> 初始化全局内核页表。这一过程建立了内核运行所需的物理地址到虚拟地址的<strong>直接映射</strong>。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">硬件上电 → ... → main() </span><br><span class="line">                   ↓</span><br><span class="line">            kvminit() : 创建全局内核页表 kernel_pagetable</span><br><span class="line">                   ↓</span><br><span class="line">            kvmmake() : 核心映射逻辑</span><br><span class="line">                   ↓</span><br><span class="line">    +-------------------------------------------------------+</span><br><span class="line">    | 1. kalloc()        : 申请一个 4KB 页面作为页表根目录      |</span><br><span class="line">    | 2. memset()        : 清零该页面                          |</span><br><span class="line">    | 3. kvmmap(...)     : 建立如下关键映射 (Direct Map)       |</span><br><span class="line">    |    - UART0         : 串口设备 I/O 地址                  |</span><br><span class="line">    |    - VIRTIO0       : 磁盘接口 I/O 地址                  |</span><br><span class="line">    |    - PLIC          : 中断控制器地址                      |</span><br><span class="line">    |    - KERNBASE      : 内核代码段 (etext 以前, RX 权限)      |</span><br><span class="line">    |    - etext         : 内核数据段 &amp; RAM (etext 以后, RW 权限)|</span><br><span class="line">    |    - TRAMPOLINE    : 映射最高虚拟地址处的跳板代码          |</span><br><span class="line">    | 4. proc_mapstacks(): 为每个进程的内核栈分配物理内存并映射   |</span><br><span class="line">    +-------------------------------------------------------+</span><br><span class="line">                   ↓</span><br><span class="line">            kvminithart() : 激活分页机制</span><br><span class="line">                   ↓</span><br><span class="line">    +-------------------------------------------------------+</span><br><span class="line">    | 1. w_satp()        : 将 kernel_pagetable 地址写入 satp 寄存器</span><br><span class="line">    | 2. sfence_vma()    : 刷新 TLB 快照，确保映射立即生效        |</span><br><span class="line">    +-------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="2-进程创建中的页表操作-Process-Page-Table-Operations"><a href="#2-进程创建中的页表操作-Process-Page-Table-Operations" class="headerlink" title="2. 进程创建中的页表操作 (Process Page Table Operations)"></a>2. 进程创建中的页表操作 (Process Page Table Operations)</h3><p>在 xv6 中，每个进程都有独立的页表。在 <code>allocproc()</code> 和 <code>fork()</code> 过程中，页表的操作是确保进程隔离的核心。</p><h4 id="A-初始创建流程-allocproc-proc-pagetable"><a href="#A-初始创建流程-allocproc-proc-pagetable" class="headerlink" title="A. 初始创建流程 (allocproc &amp; proc_pagetable)"></a>A. 初始创建流程 (<code>allocproc</code> &amp; <code>proc_pagetable</code>)</h4><p>当你创建一个新进程（如第一个进程 <code>userinit</code>）时：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">allocproc() : 基础资源分配</span><br><span class="line">      ↓</span><br><span class="line">kalloc() -&gt; p-&gt;trapframe : 分配物理页存放中断帧</span><br><span class="line">      ↓</span><br><span class="line">kalloc() -&gt; p-&gt;usyscall  : 分配物理页存放用户系统调用数据 (由你的代码定制)</span><br><span class="line">      ↓</span><br><span class="line">p-&gt;pagetable = proc_pagetable(p) : 构造页表</span><br><span class="line">      ↓</span><br><span class="line">      +----------------------------------------------------------+</span><br><span class="line">      | 1. uvmcreate()    : 申请一页物理内存作为用户页表根目录       |</span><br><span class="line">      | 2. mappages(...)  : 映射 TRAMPOLINE (最高虚拟地址)         |</span><br><span class="line">      | 3. mappages(...)  : 映射 TRAPFRAME (跳板下方, 指向 p-&gt;trapframe)</span><br><span class="line">      | 4. mappages(...)  : 映射 USYSCALL (指向 p-&gt;usyscall, PTE_U) |</span><br><span class="line">      +----------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="B-复制进程流程-fork"><a href="#B-复制进程流程-fork" class="headerlink" title="B. 复制进程流程 (fork)"></a>B. 复制进程流程 (<code>fork</code>)</h4><p>当父进程产生子进程时，涉及内存内容的完全拷贝：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fork() : 进程复制</span><br><span class="line">  ↓</span><br><span class="line">allocproc()        : 获取新进程结构及空页表</span><br><span class="line">  ↓</span><br><span class="line">uvmcopy(old, new)  : 物理内存深拷贝核心</span><br><span class="line">  ↓</span><br><span class="line">  +--------------------------------------------------------------+</span><br><span class="line">  | loop (i = 0 to parent-&gt;sz)                                   |</span><br><span class="line">  |  1. walk(old_pgtbl) : 找到父进程物理页地址 (pa)                |</span><br><span class="line">  |  2. kalloc()        : 为子进程申请一个新的物理页 (mem)         |</span><br><span class="line">  |  3. memmove()       : 将父进程页内容复制到新页                 |</span><br><span class="line">  |  4. mappages(new)   : 在子进程页表中建立该虚拟地址到新物理页的映射 |</span><br><span class="line">  +--------------------------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="3-关键函数逻辑摘要-Note-Summary"><a href="#3-关键函数逻辑摘要-Note-Summary" class="headerlink" title="3. 关键函数逻辑摘要 (Note Summary)"></a>3. 关键函数逻辑摘要 (Note Summary)</h3><table><thead><tr><th>函数名</th><th>作用</th><th>核心代码细节</th></tr></thead><tbody><tr><td><strong><code>walk()</code></strong></td><td>页表查找&#x2F;建立</td><td>模拟 RISC-V 三级页表查找，若 <code>alloc</code> 为真且中间页表缺失，则调用 <code>kalloc</code> 补齐。</td></tr><tr><td><strong><code>mappages()</code></strong></td><td>建立映射</td><td>将一段虚拟地址区间映射到物理地址区间，并在 PTE 中设置权限位（<code>PTE_R/W/X/U</code>）。</td></tr><tr><td><strong><code>uvmunmap()</code></strong></td><td>撤销映射</td><td>解除映射，若 <code>do_free</code> 为真，则通过 <code>kfree</code> 释放物理内存。</td></tr><tr><td><strong><code>kalloc/kfree</code></strong></td><td>物理页管理</td><td>管理空闲链表 <code>kmem.freelist</code>，分配和回收 4096 字节的物理页面。</td></tr></tbody></table><h3 id="vmprint实现"><a href="#vmprint实现" class="headerlink" title="vmprint实现"></a>vmprint实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From <span class="number">71</span>a9a91a6eecbcbc8bf9b8347becadb65ddea61d Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Fri, <span class="number">30</span> Jan <span class="number">2026</span> <span class="number">13</span>:<span class="number">27</span>:<span class="number">37</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH <span class="number">2</span>/<span class="number">2</span>] feat: support vmprint</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> kernel/defs.h |  <span class="number">1</span> +</span><br><span class="line"> kernel/exec.c |  <span class="number">7</span> +++++++</span><br><span class="line"> kernel/vm.c   | <span class="number">26</span> ++++++++++++++++++++++++++</span><br><span class="line"> <span class="number">3</span> files changed, <span class="number">34</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index <span class="number">3564</span>db4..<span class="number">38</span>ad8dd <span class="number">100644</span></span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ <span class="number">-170</span>,<span class="number">6</span> +<span class="number">170</span>,<span class="number">7</span> @@ uint64          <span class="title function_">walkaddr</span><span class="params">(<span class="type">pagetable_t</span>, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">char</span> *, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// plic.c</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/kernel/exec.c b/kernel/exec.c</span><br><span class="line">index d62d29d..bc3466f <span class="number">100644</span></span><br><span class="line">--- a/kernel/exec.c</span><br><span class="line">+++ b/kernel/exec.c</span><br><span class="line">@@ <span class="number">-116</span>,<span class="number">6</span> +<span class="number">116</span>,<span class="number">13</span> @@ exec(<span class="type">char</span> *path, <span class="type">char</span> **argv)</span><br><span class="line">   p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">   proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"> </span><br><span class="line">+  <span class="comment">// liangji add, to test vmprint pagetable</span></span><br><span class="line">+  <span class="keyword">if</span>(p-&gt;pid == <span class="number">1</span>)</span><br><span class="line">+  &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, p-&gt;pagetable);</span><br><span class="line">+      vmprint(p-&gt;pagetable, <span class="number">2</span>);</span><br><span class="line">+</span><br><span class="line">+  &#125;</span><br><span class="line">   <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line"> </span><br><span class="line">  bad:</span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index d5a12a0..a135d6c <span class="number">100644</span></span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ <span class="number">-432</span>,<span class="number">3</span> +<span class="number">432</span>,<span class="number">29</span> @@ copyinstr(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 max)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// print user process pagetable</span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="type">int</span> l = level;</span><br><span class="line">+    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">+        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">+</span><br><span class="line">+        <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; l == <span class="number">2</span>)&#123;</span><br><span class="line">+            <span class="comment">// pte is valid, and is not final pagetable pte</span></span><br><span class="line">+            uint64 child = PTE2PA(pte);</span><br><span class="line">+            <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">+            vmprint((<span class="type">pagetable_t</span>)child, l<span class="number">-1</span>);</span><br><span class="line">+</span><br><span class="line">+        &#125;<span class="keyword">else</span> <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; l == <span class="number">1</span>)&#123;</span><br><span class="line">+            uint64 child = PTE2PA(pte);</span><br><span class="line">+            <span class="built_in">printf</span>(<span class="string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">+            vmprint((<span class="type">pagetable_t</span>)child, l<span class="number">-1</span>);</span><br><span class="line">+</span><br><span class="line">+        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; l == <span class="number">0</span>)&#123;</span><br><span class="line">+            <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+</span><br><span class="line">+&#125;</span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pgaccess"><a href="#pgaccess" class="headerlink" title="pgaccess"></a>pgaccess</h2><p>这个实验的目的是为了利用系统调用来查看数据页是否被人访问。</p><p>简单来说，就是该系统调用，传入参数：用户空间malloc出32个数据页，得到这个的虚拟地址，传入页数量，最终结果放到一个unsigned int 里面。</p><p>在这里我犯了以下几个错误：</p><ol><li><p><strong>页表和数据页的区分：</strong><br>页表是每个进程用来记录用户空间的虚拟地址到物理地址映射的。所以，页表，顾名思义，是一个关于页的映射的表。pagetable里面每一项（pte）表示的是从va（一页）映射到pa（一页，4096KB），所以，正确的做法是，malloc出来的32*PAGESIZE大小的内存在堆中，返回的指针（就是一个地址，实际上就是uint64，用argaddr得到）。这个就是虚拟地址va（第一页的地址），所以需要做的就是已知va，想到知道这一页是否被访问（即想要得到va的pte，因为只有pte才有符号位，不需要知道pa），所以就需要walk</p></li><li><p><strong>指针位移和地址数据位移的区别：</strong><br>uint64 addr和 uint64* p, 如果都指向的是32<em>page的开头，如何后移指向第二个页的开头地址呢？<br>因为uint64是数值，里面的数值表示地址，指向第一个页的第一个字节，所以直接+字节数即可。（所以它可以表示的地址最小间隔是一个字节）<br>如果是uint64</em>， 是指针，指针内容才是地址。所以一次后移，必须是指针类型大小的整数倍，指针变量的“步进”</p></li></ol><blockquote><p>那一个地址里面的数值代表多少？比如告诉你一个uint64 的地址，地址和地址里面的值，我有点混淆，他们都有多少位？</p></blockquote><blockquote><ol><li>位数对比：地址 vs. 数值<br>在 xv6 (RISC-V 64-bit) 架构下：</li></ol></blockquote><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">对象        位数 (Bits)  存储内容                形象比喻</span><br><span class="line">地址 (Address)<span class="number">64</span> 位      指向内存中某个字节的位置。门牌号（比如：长安街 <span class="number">100</span> 号）</span><br><span class="line">数值 (Value)<span class="number">64</span> 位 (常见)  该内存位置存储的具体二进制数据。房间里的住户（比如：住了 <span class="number">8</span> 个人）</span><br><span class="line"></span><br><span class="line">地址的位数：决定了 CPU 理论上能管理的内存有多大。<span class="number">64</span> 位地址意味着可以寻址 <span class="number">2</span> </span><br><span class="line"><span class="number">64</span></span><br><span class="line">  字节的空间。</span><br></pre></td></tr></table></figure><blockquote><p>数值的位数：取决于你如何“解读”内存。虽然物理上内存是按字节（8 位）排列的，但我们通常一次读 64 位（即一个 uint64）。</p></blockquote><pre><code>     1. 深度剖析：它们是如何对应的？</code></pre><p>当你声明 uint64 *p 时，变量 p 本身占 64 位，它存的是一个地址。当你执行 uint64 v &#x3D; *p（解引用）时，你是在告诉 CPU：</p><p>“去 p 存的那个门牌号，把里面住的 64 位数据取出来传给 v。”</p><pre><code>     1. 在 xv6 页表实验中的具体应用</code></pre><p>在你的 pgaccess 实验中，这种混淆通常发生在处理 PTE（页表项） 时：</p><p>PTE 的地址：这是一个 64 位的 uint64 数值，代表这个条目在内存中的位置。</p><p>PTE 的值：这也是一个 64 位的数值，但它的内部被拆分了：</p><p>低 10 位：是标志位（Flags），比如 PTE_V, PTE_R, PTE_A。</p><p>高 44 位：是物理页号（PPN）。</p><pre><code>     1. 常见误区：为什么你之前的代码会“跑飞”？</code></pre><p>如果你有一个地址 0x80001000：</p><p>数值运算：0x80001000 + 1 &#x3D; 0x80001001（移动了 1 个字节）。</p><p>指针运算：(uint64*)0x80001000 + 1 &#x3D; 0x80001008（移动了 8 个字节，因为一个 uint64 占 8 字节）。</p><p>在 pgaccess 中：</p><p>如果你要找下一个页面，你应该在地址数值上加 4096 (PGSIZE)。</p><p>如果你要找同一个页表里的下一个条目，你应该在 pte_t * 指针上加 1。</p><blockquote><p>所以<strong>最小访问的数据单元就是一个字节</strong>？</p></blockquote><p><strong>是的</strong>，在绝大多数现代计算机架构（包括 xv6 使用的 RISC-V）中，内存寻址的最小单位就是 1 个字节（1 Byte &#x3D; 8 Bits）。</p><p>这意味着每一个唯一的内存地址都对应着内存中的 1 个字节。</p><ol><li>“字节寻址”是什么意思？<br>如果一个内存地址是 0x80001000，它指向的是内存中某一个特定的 8 位（1 字节）数据。</li></ol><p>地址 0x80001000：存着第 1 个字节。</p><p>地址 0x80001001：存着第 2 个字节。</p><p>地址 0x80001002：存着第 3 个字节。</p><ol start="2"><li>为什么我们常说 64 位（8 字节）？<br>虽然最小单元是字节，但为了效率，CPU 通常会“成块”地读写数据。</li></ol><p>寄存器大小：RISC-V 的 uint64 变量占 8 个字节（64 位）。</p><p>内存访问：当你让 CPU 读取一个 uint64 时，它会一次性从内存中抓取连续的 8 个地址单元。</p><p>你的实验案例：<br>在 xv6 的页表（Pagetable）中，一个页面是 4096 字节。</p><p>它包含了 4096÷8&#x3D;512 个页表项（PTE）。</p><p>每个 PTE 是一个 uint64，也就是 8 个字节。</p><ol start="3"><li>PTE_A 是标志位的第6位，是固定的，是由riscv标准决定的，不是自己决定的，这个有硬件定义，所以必须是6</li><li>关于置位：</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i位置0</span></span><br><span class="line">&amp;~(<span class="number">1</span>&lt;&lt;i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//i位置1</span></span><br><span class="line">| (<span class="number">1</span>&lt;&lt;i)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">From e0c7e67170c56a90d1228cde82f47f01ef4ee6be Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Fri, <span class="number">30</span> Jan <span class="number">2026</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">24</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH] feat: support pgaccess</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> kernel/defs.h    |  <span class="number">4</span> +++</span><br><span class="line"> kernel/riscv.h   |  <span class="number">1</span> +</span><br><span class="line"> kernel/<span class="built_in">string</span>.c  |  <span class="number">2</span> ++</span><br><span class="line"> kernel/sysproc.c | <span class="number">77</span> ++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/vm.c      |  <span class="number">2</span> ++</span><br><span class="line"> <span class="number">5</span> files changed, <span class="number">86</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index <span class="number">38</span>ad8dd..<span class="number">7398</span>a96 <span class="number">100644</span></span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ <span class="number">-130</span>,<span class="number">6</span> +<span class="number">130</span>,<span class="number">7</span> @@ <span class="type">char</span>*           <span class="title function_">safestrcpy</span><span class="params">(<span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*, uint)</span>;</span><br><span class="line"> <span class="type">char</span>*           <span class="title function_">strncpy</span><span class="params">(<span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">print_last_10_bits</span><span class="params">(uint64)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// syscall.c</span></span><br><span class="line"> <span class="type">int</span>             <span class="title function_">argint</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>*)</span>;</span><br><span class="line">@@ <span class="number">-171</span>,<span class="number">6</span> +<span class="number">172</span>,<span class="number">9</span> @@ <span class="type">int</span>             <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">char</span> *, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">copyinstr</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">char</span> *, uint64, uint64)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>, <span class="type">int</span>)</span>;</span><br><span class="line">+<span class="type">pte_t</span> *         <span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span>, uint64, <span class="type">int</span>)</span>;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// plic.c</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">plicinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/kernel/riscv.h b/kernel/riscv.h</span><br><span class="line">index <span class="number">1691f</span>af..<span class="number">8</span>d8c34f <span class="number">100644</span></span><br><span class="line">--- a/kernel/riscv.h</span><br><span class="line">+++ b/kernel/riscv.h</span><br><span class="line">@@ <span class="number">-343</span>,<span class="number">6</span> +<span class="number">343</span>,<span class="number">7</span> @@ sfence_vma()</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> PTE_A (1L <span class="string">&lt;&lt; 6) // 1 -&gt;</span> PTE has been accessed</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line">diff --git a/kernel/<span class="built_in">string</span>.c b/kernel/<span class="built_in">string</span>.c</span><br><span class="line">index <span class="number">153536f</span>..a9f5134 <span class="number">100644</span></span><br><span class="line">--- a/kernel/<span class="built_in">string</span>.c</span><br><span class="line">+++ b/kernel/<span class="built_in">string</span>.c</span><br><span class="line">@@ <span class="number">-105</span>,<span class="number">3</span> +<span class="number">105</span>,<span class="number">5</span> @@ <span class="built_in">strlen</span>(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">   <span class="keyword">return</span> n;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index <span class="number">3b</span>d0007..<span class="number">7</span>a9b924 <span class="number">100644</span></span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ <span class="number">-77</span>,<span class="number">10</span> +<span class="number">77</span>,<span class="number">87</span> @@ sys_sleep(<span class="type">void</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line">+<span class="type">void</span></span><br><span class="line">+clear_access(<span class="type">pagetable_t</span> pagetable)&#123;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; <span class="number">512</span>; i++)</span><br><span class="line">+    &#123;</span><br><span class="line">+        <span class="type">pte_t</span> *pte = &amp;(pagetable[i]);</span><br><span class="line">+        *pte = *pte &amp; ~(PTE_A);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">void</span> <span class="title function_">print_last_10_bits</span><span class="params">(uint64 num)</span> &#123;</span><br><span class="line">+    <span class="comment">// 步骤1：用掩码 0x3FF（二进制 10 个 1）提取最后 10 位</span></span><br><span class="line">+    uint64 last_10 = num &amp; <span class="number">0x3FF</span>;  <span class="comment">// 0x3FF = 2^10 - 1 = 1023</span></span><br><span class="line">+</span><br><span class="line">+    <span class="comment">// 步骤2：逐位打印最后 10 位（从第9位到第0位，保证补全前导0）</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">+        <span class="comment">// 按位判断：1 则打印 1，0 则打印 0</span></span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (last_10 &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="type">int</span></span><br><span class="line"> <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">+  uint64 base_addr;</span><br><span class="line">+  <span class="type">int</span> page_num;</span><br><span class="line">+  uint64 dst_addr;</span><br><span class="line">+  <span class="type">unsigned</span> <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">+  </span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">//get arg1 = addr</span></span><br><span class="line">+  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;base_addr) != <span class="number">0</span> )&#123;</span><br><span class="line">+      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">//get arg2 = len</span></span><br><span class="line">+  <span class="keyword">if</span>(argint(<span class="number">1</span>, &amp;page_num) !=<span class="number">0</span> )&#123;</span><br><span class="line">+      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">//get arg1 = addr</span></span><br><span class="line">+  <span class="keyword">if</span>(argaddr(<span class="number">2</span>, &amp;dst_addr) != <span class="number">0</span> )&#123;</span><br><span class="line">+      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;pgaccess: %p %d %p\n&quot;</span>, base_addr, page_num, dst_addr);</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// for each page</span></span><br><span class="line">+  <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;page_num; i++)&#123;</span><br><span class="line">+      <span class="comment">// get va of each page</span></span><br><span class="line">+</span><br><span class="line">+      <span class="comment">//uint64 va = ((pagetable_t)base_addr)[i];</span></span><br><span class="line">+      uint64 va = base_addr + i*(<span class="number">4096</span>);</span><br><span class="line">+</span><br><span class="line">+      <span class="comment">//printf(&quot;get va = %p of this page\n&quot;, va);</span></span><br><span class="line">+      <span class="comment">// search in user process pagetable  va -&gt; pa</span></span><br><span class="line">+      <span class="comment">// get pa of each page from proc pagetable</span></span><br><span class="line">+</span><br><span class="line">+      <span class="type">pte_t</span> *pte;</span><br><span class="line">+      pte = walk(myproc()-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">+      <span class="keyword">if</span>(pte == <span class="number">0</span>)&#123;</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;fail to find pte of page %d\n&quot;</span>, i);</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">+        <span class="comment">// if find one pte is accessed</span></span><br><span class="line">+        <span class="keyword">if</span>((*pte &amp; PTE_V) &amp;&amp; (*pte &amp; PTE_A))&#123;</span><br><span class="line">+            *pte = *pte &amp; ~(PTE_A);</span><br><span class="line">+            result = result | (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">//copy result to user space</span></span><br><span class="line">+  <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, dst_addr, (<span class="type">char</span>*)&amp;result, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;fail to copyout\n&quot;</span>);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">diff --git a/kernel/vm.c b/kernel/vm.c</span><br><span class="line">index a135d6c..<span class="number">3</span>d61968 <span class="number">100644</span></span><br><span class="line">--- a/kernel/vm.c</span><br><span class="line">+++ b/kernel/vm.c</span><br><span class="line">@@ <span class="number">-87</span>,<span class="number">6</span> +<span class="number">87</span>,<span class="number">7</span> @@ walk(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span><br><span class="line">     <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">     <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">       pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">+</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">@@ <span class="number">-94</span>,<span class="number">6</span> +<span class="number">95</span>,<span class="number">7</span> @@ walk(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span><br><span class="line">       *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">   <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;页表&quot;&gt;&lt;a href=&quot;#页表&quot; class=&quot;headerlink&quot; title=&quot;页表&quot;&gt;&lt;/a&gt;页表&lt;/h1&gt;&lt;p&gt;本节主要学习页表，包括内核的地址空间，物理内存的分配，用户进程的地址空间，页表的作用和实现逻辑等。&lt;/p&gt;
&lt;h2 id=&quot;usyscall</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="XV6" scheme="http://example.com/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab2</title>
    <link href="http://example.com/2026/01/23/xv6-lab2/"/>
    <id>http://example.com/2026/01/23/xv6-lab2/</id>
    <published>2026-01-23T01:58:17.000Z</published>
    <updated>2026-02-20T13:51:20.755Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#xv6-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0">XV6 启动过程概述</a><ul><li><a href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AD%94%E7%96%91">启动过程的一些答疑</a><ul><li><a href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88-c-%E8%AF%AD%E8%A8%80%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%A0%88%E6%9C%BA%E5%99%A8%E5%88%86%E5%BE%97%E6%B8%85%E5%90%97">1. 为什么 C 语言必须要有栈？机器分得清吗？</a></li><li><a href="#2-_entrys-%E9%87%8C%E7%9A%84%E6%A0%88%E7%94%B3%E8%AF%B7%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%88%86%E5%B8%83">2. _entry.S 里的栈：申请、大小与分布</a></li><li><a href="#3-mret-%E7%89%B9%E6%80%A7%E4%B8%8E-satp-%E7%9A%84%E7%90%86%E8%A7%A3">3. mret 特性与 satp 的理解</a></li><li><a href="#4-%E4%B8%AD%E6%96%AD%E5%A7%94%E6%B4%BEdelegation%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0">4. 中断委派（Delegation）：如何做到？</a></li><li><a href="#5-userinit-%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E8%BF%98%E6%98%AF%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4">5. userinit 创建的进程：内核还是用户空间？</a></li><li><a href="#6-%E4%BB%8E%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8Fs%E5%88%87%E6%8D%A2%E5%88%B0%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8Fu%E7%9A%84%E6%97%B6%E6%9C%BA">6. 从管理模式（S）切换到用户模式（U）的时机</a></li><li><a href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-page%E9%A1%B5">7. 什么是 Page（页）？</a></li><li><a href="#8-initcodes%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%B8%AAexec%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84">8. initcode.S是如何实现第一个exec系统调用的</a><ul><li><a href="#1-%E8%A7%A6%E5%8F%91%E8%80%85%E7%94%A8%E6%88%B7%E6%80%81%E6%89%A7%E8%A1%8C-ecall-%E6%8C%87%E4%BB%A4">1. 触发者：用户态执行 ecall 指令</a></li><li><a href="#2-%E7%AC%AC%E4%B8%80%E7%AB%99kerneltrampolines-%E6%B1%87%E7%BC%96%E5%85%A5%E5%8F%A3">2. 第一站：kernel&#x2F;trampoline.S (汇编入口)</a></li><li><a href="#3-%E7%AC%AC%E4%BA%8C%E7%AB%99kerneltrapc-c-%E8%AF%AD%E8%A8%80%E9%80%BB%E8%BE%91">3. 第二站：kernel&#x2F;trap.c (C 语言逻辑)</a></li><li><a href="#4-%E7%BB%88%E7%82%B9%E7%AB%99kernelsyscallc-%E6%9F%A5%E8%A1%A8%E6%89%A7%E8%A1%8C">4. 终点站：kernel&#x2F;syscall.c (查表执行)</a></li></ul></li></ul></li></ul></li><li><a href="#%E6%9C%BA%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%AE%A1%E7%90%86%E5%91%98%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%90%97">机器模式和管理员模式有什么区别吗</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%A1%B5%E8%A1%A8%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%86%85%E6%A0%B8%E6%A0%88%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%96%E4%BB%AC%E5%9C%A8%E5%AE%9E%E9%99%85%E7%9A%84ddr-ram%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%8E%92%E5%B8%83%E7%9A%84">进程的页表，每个进程的内存结构，内核栈又是什么，他们在实际的ddr ram中是如何排布的</a><ul><li><a href="#%E4%B8%80%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98ddr-ram%E7%9A%84%E6%95%B4%E4%BD%93%E5%B8%83%E5%B1%80">一、物理内存(DDR RAM)的整体布局</a></li><li><a href="#%E4%BA%8C%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">二、内核的虚拟地址空间</a><ul><li><a href="#%E4%B8%89%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">三、用户进程的虚拟地址空间</a></li></ul></li><li><a href="#%E5%9B%9B%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84-%E4%B8%89%E7%BA%A7%E9%A1%B5%E8%A1%A8">四、页表结构 (三级页表)</a></li><li><a href="#%E4%BA%94%E5%86%85%E6%A0%B8%E6%A0%88%E8%AF%A6%E8%A7%A3">五、内核栈详解</a></li><li><a href="#%E5%85%AD%E5%AE%8C%E6%95%B4%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%8E%92%E5%B8%83%E7%A4%BA%E4%BE%8B">六、完整的物理内存排布示例</a></li><li><a href="#%E4%B8%83%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">七、关键数据结构</a></li><li><a href="#%E5%85%AB%E5%9B%BE%E8%A7%A3%E4%B8%80%E6%AC%A1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8">八、图解：一次系统调用的内存使用</a></li></ul></li><li><a href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">关于文件系统</a><ul><li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%A4%E5%B1%82%E5%90%AB%E4%B9%89">文件系统的两层含义</a></li><li><a href="#%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%AD%A3%E7%A1%AE">你理解的流程基本正确</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%AF%94">一个类比</a></li><li><a href="#%E8%A1%A5%E5%85%85%E5%85%B3%E4%BA%8E%E7%BC%93%E5%AD%98">补充：关于缓存</a></li><li><a href="#lab2%E5%AE%9E%E9%AA%8C">lab2实验</a><ul><li><a href="#trace">trace</a></li><li><a href="#sysinfo">sysinfo</a></li></ul></li></ul></li></ul><h1 id="XV6-启动过程概述"><a href="#XV6-启动过程概述" class="headerlink" title="XV6 启动过程概述"></a>XV6 启动过程概述</h1><p>XV6是MIT开发的一个教学用操作系统，基于Unix V6重新实现，运行在RISC-V架构上。其启动过程如下：</p><p><strong>1. 硬件初始化阶段</strong></p><p>机器上电后，RISC-V硬件首先执行ROM中的引导程序引导程序将<strong>XV6内核</strong>加载到内存地址 0x80000000，所有CPU的硬件寄存器被初始化</p><p><strong>2. entry.S - 内核入口</strong></p><p>位于 <code>kernel/entry.S</code></p><p>这是<strong>内核的第一段代码</strong>，运行在机器模式(M-mode)</p><p><strong>主要工作</strong>：</p><ul><li>为每个CPU设置栈指针(sp)</li><li>跳转到 start() 函数</li></ul><p><strong>3. start.c - 早期初始化</strong></p><p>位于 <code>kernel/start.c</code></p><p>在机器模式下执行一些初始化：</p><ol><li>设置 mstatus 寄存器，准备<strong>切换到监管模式(S-mode)</strong></li><li>将 main 函数地址写入 mepc</li><li>禁用分页（将 satp 设为0）</li><li>配置中断和异常委托给S-mode</li><li>初始化定时器中断</li><li>调用 mret 指令切换到S-mode并跳转到 main()</li></ol><p><strong>4. main.c - 内核主函数</strong></p><p>位于 <code>kernel/main.c</code></p><p>只有CPU 0（引导CPU）执行完整初始化：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">consoleinit() - 初始化控制台</span><br><span class="line">printfinit() - 初始化<span class="built_in">printf</span>锁</span><br><span class="line">kinit() - 初始化物理内存分配器</span><br><span class="line">kvminit() - 创建内核页表</span><br><span class="line">kvminithart() - 开启分页</span><br><span class="line">procinit() - 初始化进程表</span><br><span class="line">trapinit() - 初始化中断向量</span><br><span class="line">trapinithart() - 安装内核中断处理器</span><br><span class="line">plicinit() - 初始化PLIC中断控制器</span><br><span class="line">plicinithart() - 为当前CPU配置PLIC</span><br><span class="line">binit() - 初始化缓冲区缓存</span><br><span class="line">iinit() - 初始化inode缓存</span><br><span class="line">fileinit() - 初始化文件表</span><br><span class="line">virtio_disk_init() - 初始化磁盘</span><br><span class="line">userinit() - 创建第一个用户进程</span><br><span class="line">scheduler() - 启动调度器</span><br></pre></td></tr></table></figure><p><strong>5. 第一个用户进程</strong></p><p>userinit() 创建 init 进程</p><p>init 进程执行 <code>initcode.S</code>，调用 <code>exec(&quot;/init&quot;)</code></p><p>&#x2F;init 程序打开控制台，fork出shell<br>系统启动完成，等待用户输入</p><p><strong>启动流程图</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">硬件上电 → ROM引导 → entry.S → start() → main() → scheduler()</span><br><span class="line">                                              ↓</span><br><span class="line">                                         userinit()</span><br><span class="line">                                              ↓</span><br><span class="line">                                         init进程</span><br><span class="line">                                              ↓</span><br><span class="line">                                           shell</span><br></pre></td></tr></table></figure><h2 id="启动过程的一些答疑"><a href="#启动过程的一些答疑" class="headerlink" title="启动过程的一些答疑"></a>启动过程的一些答疑</h2><h3 id="1-为什么-C-语言必须要有栈？机器分得清吗？"><a href="#1-为什么-C-语言必须要有栈？机器分得清吗？" class="headerlink" title="1. 为什么 C 语言必须要有栈？机器分得清吗？"></a>1. 为什么 C 语言必须要有栈？机器分得清吗？</h3><p><strong>机器确实分不清</strong>。</p><p>你说的没错，无论是 C 还是汇编，最后都是二进制指令。<br><strong>机器只负责执行 add、ld（加载）、st（存储）等指令</strong>。</p><p><strong>汇编不需要栈吗？</strong>：并非绝对。</p><p>汇编可以完全不用栈（如果你只用寄存器完成所有逻辑），但<strong>一旦你需要函数调用（保存返回地址）或局部变量过多</strong>寄存器放不下，汇编也得手动操作栈。</p><p>C 语言为什么必须有？：<strong>C 语言的执行模型是基于堆栈的</strong>。</p><p><strong>函数嵌套</strong>与递归：当你调用 funcA 时，机器<strong>需要记住从哪里跳回来的</strong>。这个返回地址必须存起来，<strong>最方便的地方就是栈</strong>。</p><p><strong>局部变量</strong>：每个函数内部定义的变量，其生命周期仅在函数内。C 编译器（如 <strong>GCC）会将这些变量分配在 sp（栈指针）寄存器所指向的内存空间</strong>。</p><blockquote><p>结论：如果 _entry.S 不给 sp 寄存器赋值一个有效的内存地址，C 代码里的第一行函数调用或变量声明就会导致程序往一个随机的地址写数据，直接导致系统崩溃。</p></blockquote><h3 id="2-entry-S-里的栈：申请、大小与分布"><a href="#2-entry-S-里的栈：申请、大小与分布" class="headerlink" title="2. _entry.S 里的栈：申请、大小与分布"></a>2. _entry.S 里的栈：申请、大小与分布</h3><ul><li><p><strong>申请标准与大小</strong>：在 kernel&#x2F;start.c 中，xv6 声明了 char stack0[4096 * NCPU]。</p><ul><li><p>大小：<strong>每个 CPU 核心（Hart）分配 4096 字节（4KB）</strong>。这在内核启动初期完全够用，因为此时没有复杂的深度递归。</p></li><li><p>位置：它是<strong>内核数据段的一部分</strong>。当引导加载程序将 kernel 固件拷贝到 0x80000000 时，这个 stack0 数组也就随之存在于内存中了。</p></li></ul></li><li><p><strong>内存分布</strong>： 由于 <strong>RISC-V 的栈是向下增长</strong>的（从高地址向低地址跑），_entry.S 的逻辑如下：</p><ul><li><p>获取当前 CPU 的编号（0, 1, 2…）。</p></li><li><p>计算地址：sp &#x3D; stack0 + (hartid + 1) * 4096。</p></li></ul></li><li><p><strong>存在多久</strong>？：这个 stack0 在内核生命周期内一直存在。但要注意：一旦系统进入多进程调度阶段，每个用户进程都会有自己独立的 内核栈（kstack），stack0 主要用于系统启动和某些特定的中断处理。</p></li></ul><h3 id="3-mret-特性与-satp-的理解"><a href="#3-mret-特性与-satp-的理解" class="headerlink" title="3. mret 特性与 satp 的理解"></a>3. mret 特性与 satp 的理解</h3><p>你的理解基本完全正确，补充几个技术细节：</p><ul><li><p><strong>mret指令</strong>：它是一个<strong>硬件指令</strong>，操作是：</p><ul><li><p>将特权级切换为 mstatus 中记录的模式（xv6 设置为 S 模式）。</p></li><li><p>将 PC 指针跳转到 mepc 寄存器的值。</p></li></ul></li><li><p><strong>satp寄存器</strong> (Supervisor Address Translation and Protection)：</p><ul><li><p>它就是 MMU 的开关和控制中心。</p></li><li><p>当 satp &#x3D; 0 时，禁用页表&#x2F;MMU，此时 CPU 使用的是物理地址。</p></li><li><p>xv6 在 start 函数里关闭它是为了确保进入 main 时，内存访问是简单直接的，直到 main 后期手动初始化页表并再次开启它</p></li></ul></li></ul><h3 id="4-中断委派（Delegation）：如何做到？"><a href="#4-中断委派（Delegation）：如何做到？" class="headerlink" title="4. 中断委派（Delegation）：如何做到？"></a>4. 中断委派（Delegation）：如何做到？</h3><p>在 RISC-V 中，<strong>默认情况下，所有异常和中断</strong>都会跳转到<strong>机器模式</strong>（M-Mode）处理。但内核通常运行在 管理模式（S-Mode），<strong>如果每次时钟中断都要先跳进 M 模式再转手给 S 模式，太慢了</strong>。</p><ul><li><p><strong>怎么做到</strong>？：通过设置两个寄存器：<strong>medeleg</strong> (Machine Exception Delegation) 和 <strong>mideleg</strong> (Machine Interrupt Delegation)。</p></li><li><p><strong>原理</strong>：你只需要往这些寄存器的特定位<strong>写 1</strong>。</p><ul><li>比如，将“时钟中断”对应的位置 1，硬件就会在发生中断时，直接修改 S 模式的状态寄存器并跳转到 S 模式的中断向量表，完全绕过 M 模式。</li></ul></li></ul><h3 id="5-userinit-创建的进程：内核还是用户空间？"><a href="#5-userinit-创建的进程：内核还是用户空间？" class="headerlink" title="5. userinit 创建的进程：内核还是用户空间？"></a>5. userinit 创建的进程：内核还是用户空间？</h3><p>这是一个很好的哲学问题。此时该进程处于 “胚胎期”：</p><ul><li><p><strong>内存空间</strong>：它占用的物理内存在内核初始化时划拨，但其内部存放的是用户代码（initcode）。所以从内容上看，它属于用户空间。</p></li><li><p><strong>当前特权级</strong>：此时 CPU 正在执行 userinit() 函数，依然处于 管理模式（S-Mode）。内核正在“通过上帝视角”为第一个进程配置环境。</p></li></ul><blockquote><p>结论：它是一个拥有用户空间内容、但尚未被剥离内核控制权的实体。</p></blockquote><h3 id="6-从管理模式（S）切换到用户模式（U）的时机"><a href="#6-从管理模式（S）切换到用户模式（U）的时机" class="headerlink" title="6. 从管理模式（S）切换到用户模式（U）的时机"></a>6. 从管理模式（S）切换到用户模式（U）的时机</h3><p>在 <strong>main.c 的最后</strong>，你会看到 scheduler()（<strong>调度器</strong>）被调用。</p><ul><li><p><strong>调度</strong>：调度器选中 userinit 创建的这个进程。</p></li><li><p><strong>恢复上下文</strong>：调度器会调用 swtch 进入该进程的内核态。</p></li><li><p><strong>关键指令 sret</strong>：在 kernel&#x2F;trampoline.S 中，内核会执行 <strong>sret 指令</strong>。</p><ul><li>sret 与 mret 类似：它会把特权级<strong>从 S 模式降级到 用户模式（U-Mode）</strong>，并根据 <strong>sepc 寄存器</strong>的值跳转到用户代码的第一行（即 initcode 的起点）。</li></ul></li></ul><p>总结：切换时机就在调度器第一次“恢复”该进程执行的那一刻。</p><h3 id="7-什么是-Page（页）？"><a href="#7-什么是-Page（页）？" class="headerlink" title="7. 什么是 Page（页）？"></a>7. 什么是 Page（页）？</h3><p>在操作系统中，Page（页） 是<strong>内存管理的最小物理单位</strong>。</p><ul><li><p><strong>大小</strong>：在 RISC-V 架构（以及大多数现代系统）中，一个页的标准大小是 <strong>4096 字节</strong> (4KB)。</p></li><li><p><strong>作用</strong>：内核不会按“字节”来给进程分配内存，而是按“页”来分配。</p></li><li><p><strong>联系</strong>：你在代码中看到的 PGSIZE 宏就代表 4096。p-&gt;sz &#x3D; PGSIZE 意味着第一个进程目前只占用了一个页的虚拟内存空间。</p></li></ul><h3 id="8-initcode-S是如何实现第一个exec系统调用的"><a href="#8-initcode-S是如何实现第一个exec系统调用的" class="headerlink" title="8. initcode.S是如何实现第一个exec系统调用的"></a>8. initcode.S是如何实现第一个exec系统调用的</h3><p><code>initcode.S</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec(init, argv)</span></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        la a0, init</span><br><span class="line">        la a1, argv</span><br><span class="line">        li a7, SYS_exec</span><br><span class="line">        ecall</span><br></pre></td></tr></table></figure><blockquote><p>ecall 根本不是一个软件实现的函数，而是一条 RISC-V 硬件指令</p></blockquote><p>我们可以把这个过程拆解为<strong>四个关键步骤</strong>：</p><h4 id="1-触发者：用户态执行-ecall-指令"><a href="#1-触发者：用户态执行-ecall-指令" class="headerlink" title="1. 触发者：用户态执行 ecall 指令"></a>1. 触发者：用户态执行 ecall 指令</h4><p>当用户程序（比如 initcode.S 或你写的 C 程序）需要系统服务时，它会将系统调用号（如 SYS_exec）放入 a7 寄存器，然后执行 ecall。</p><ul><li><p>硬件反应：一旦 CPU 执行了 ecall 指令，硬件会自动完成以下动作：</p><ul><li><p>将当前特权级从 用户模式 (U-mode) 提升到 <strong>管理模式</strong> (S-mode)。</p></li><li><p>把当前的程序计数器（PC）保存在 <strong>sepc</strong> 寄存器中（为了以后能跳回来）。</p></li><li><p>跳转到 <strong>stvec</strong> (Supervisor Trap Vector Base Address Register) 寄存器所<strong>指向的地址</strong>。</p></li></ul></li></ul><h4 id="2-第一站：kernel-trampoline-S-汇编入口"><a href="#2-第一站：kernel-trampoline-S-汇编入口" class="headerlink" title="2. 第一站：kernel&#x2F;trampoline.S (汇编入口)"></a>2. 第一站：kernel&#x2F;trampoline.S (汇编入口)</h4><p>内核在启动时，已经预先把 stvec 寄存器的值设置好了，它指向内核中一段叫 uservec 的汇编代码。</p><ul><li><p><strong>代码位置</strong>：kernel&#x2F;trampoline.S 里的 uservec 标号处。</p></li><li><p><strong>作用</strong>：因为刚从用户态跳进来，寄存器里全是用户的数据。这段汇编代码负责<strong>把用户的所有寄存器保存到该进程的 trapframe 页面中</strong>，并<strong>切换到内核栈</strong>，然后调用 C 函数 usertrap()。</p></li></ul><h4 id="3-第二站：kernel-trap-c-C-语言逻辑"><a href="#3-第二站：kernel-trap-c-C-语言逻辑" class="headerlink" title="3. 第二站：kernel&#x2F;trap.c (C 语言逻辑)"></a>3. 第二站：kernel&#x2F;trap.c (C 语言逻辑)</h4><p>现在，我们终于从汇编进入了 C 语言的世界。</p><ul><li><p>代码位置：<code>kernel/trap.c</code> 里的 <code>usertrap(void)</code> 函数。</p></li><li><p>关键逻辑：</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123; <span class="comment">// 8 代表这是来自 U-mode 的 ecall</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  p-&gt;trapframe-&gt;epc += <span class="number">4</span>; <span class="comment">// 将返回地址加4，跳过ecall指令本身，否则回来又执行一遍ecall</span></span><br><span class="line">  intr_on();</span><br><span class="line">  syscall(); <span class="comment">// 真正的系统调用分发函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核通过读取 <code>scause</code> 寄存器发现：哦！是因为执行了 ecall 才进来的。</p><h4 id="4-终点站：kernel-syscall-c-查表执行"><a href="#4-终点站：kernel-syscall-c-查表执行" class="headerlink" title="4. 终点站：kernel&#x2F;syscall.c (查表执行)"></a>4. 终点站：kernel&#x2F;syscall.c (查表执行)</h4><p><code>usertrap</code> 会调用 <code>syscall()</code> 函数。</p><ul><li><p><strong>代码位置</strong>：<code>kernel/syscall.c</code> 里的 <code>syscall(void)</code> 函数。</p></li><li><p><strong>逻辑</strong>：</p><ul><li><p>它从该进程的 <code>trapframe-&gt;a7</code> 中取出刚才用户放进去的系统调用号。</p></li><li><p>它把这个数字作为索引，去查一个叫 <code>syscalls</code> 的函数指针数组。</p></li><li><p><strong>如果数字有效</strong>，就调用对应的<strong>内核函数</strong>（比如 sys_exec）。</p></li></ul></li></ul><h1 id="机器模式和管理员模式有什么区别吗"><a href="#机器模式和管理员模式有什么区别吗" class="headerlink" title="机器模式和管理员模式有什么区别吗"></a>机器模式和管理员模式有什么区别吗</h1><p>这是RISC-V架构中的<strong>特权级别设计</strong>，两者有明显区别：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RISC-V 三种特权模式</span><br><span class="line">模式  缩写特权级别用途</span><br><span class="line">机器模式M-mode最高 (<span class="number">3</span>)固件/引导程序</span><br><span class="line">监管模式S-mode中等 (<span class="number">1</span>)操作系统内核</span><br><span class="line">用户模式U-mode最低 (<span class="number">0</span>)用户程序</span><br></pre></td></tr></table></figure><p><strong>主要区别</strong></p><ol><li><strong>权限范围</strong></li></ol><p>M-mode: 拥有对硬件的完全控制权，可以访问所有内存和寄存器，没有任何限制</p><p>S-mode: 权限受限，某些操作需要通过M-mode代理完成（如关机、设置定时器）</p><ol start="2"><li><strong>可访问的CSR寄存器</strong></li></ol><p><strong>M-mode专用</strong>:  mstatus, mtvec, mepc, mcause, medeleg, mideleg…</p><p><strong>S-mode专用</strong>:  sstatus, stvec, sepc, scause, satp…</p><p>S-mode无法直接访问 m 开头的寄存器。</p><ol start="3"><li><strong>中断和异常处理</strong></li></ol><p>M-mode: 默认接收所有中断和异常<br>S-mode: 只能处理M-mode委托(delegate)给它的中断和异常</p><p>&#x2F;&#x2F; start.c 中的委托设置<br>w_medeleg(0xffff);  &#x2F;&#x2F; 委托异常<br>w_mideleg(0xffff);  &#x2F;&#x2F; 委托中断</p><ol start="4"><li><strong>内存保护</strong></li></ol><p>M-mode: 不受分页机制约束，可以访问任意物理地址<br>S-mode: 受 satp 寄存器控制的页表约束，通过虚拟地址访问内存</p><p><strong>实际用途</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">┌─────────────────────────────────────┐</span><br><span class="line">│  用户程序 (U-mode)                   │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  操作系统内核 (S-mode) - XV6运行在这里 │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  固件/SBI (M-mode) - OpenSBI/BBL    │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  硬件                                │</span><br><span class="line">└─────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>XV6中的体现<br>XV6启动时</strong>：</p><p>entry.S 和 start() 在 M-mode 运行，完成最基本的硬件配置</p><p>通过 mret 指令切换到 S-mode，然后 main() 及之后的内核代码都在S-mode运行</p><p>用户程序在 U-mode 运行，通过系统调用(ecall)进入S-mode</p><p>这种<strong>分层设计的好处</strong>是：即使操作系统内核被攻破，M-mode的固件仍然安全，可以提供最基本的硬件保护。</p><h1 id="进程的页表，每个进程的内存结构，内核栈又是什么，他们在实际的ddr-ram中是如何排布的"><a href="#进程的页表，每个进程的内存结构，内核栈又是什么，他们在实际的ddr-ram中是如何排布的" class="headerlink" title="进程的页表，每个进程的内存结构，内核栈又是什么，他们在实际的ddr ram中是如何排布的"></a>进程的页表，每个进程的内存结构，内核栈又是什么，他们在实际的ddr ram中是如何排布的</h1><h2 id="一、物理内存-DDR-RAM-的整体布局"><a href="#一、物理内存-DDR-RAM-的整体布局" class="headerlink" title="一、物理内存(DDR RAM)的整体布局"></a>一、物理内存(DDR RAM)的整体布局</h2><p>XV6运行在QEMU模拟的RISC-V机器上，<strong>物理内存从 0x80000000</strong> 开始：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">物理地址空间 (实际的DDR RAM)</span><br><span class="line">┌────────────────────────┐ <span class="number">0x88000000</span> (PHYSTOP, <span class="number">128</span>MB处)</span><br><span class="line">│                        │</span><br><span class="line">│   空闲物理页框          │  ← 由 kinit() 管理的空闲页</span><br><span class="line">│   (被内核和用户进程     │    每个页 <span class="number">4</span>KB</span><br><span class="line">│    动态分配使用)        │</span><br><span class="line">│                        │</span><br><span class="line">├────────────────────────┤ end (内核代码结束处)</span><br><span class="line">│   内核 BSS 段           │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   内核 数据段           │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   内核 代码段 (text)    │</span><br><span class="line">├────────────────────────┤ <span class="number">0x80000000</span> (KERNBASE)</span><br><span class="line">│                        │</span><br><span class="line">│   I/O 设备映射区        │  UART, PLIC, VIRTIO 等</span><br><span class="line">│                        │</span><br><span class="line">└────────────────────────┘ <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><h2 id="二、内核的虚拟地址空间"><a href="#二、内核的虚拟地址空间" class="headerlink" title="二、内核的虚拟地址空间"></a>二、内核的虚拟地址空间</h2><p>内核使用直接映射：<strong>虚拟地址 &#x3D; 物理地址</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/memlayout.h 中定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP  (KERNBASE + 128*1024*1024)  <span class="comment">// 128MB</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">内核虚拟地址空间</span><br><span class="line">┌────────────────────────┐ MAXVA (最高虚拟地址)</span><br><span class="line">│   Trampoline (跳板页)   │  ← 映射到物理的 trampoline 代码</span><br><span class="line">├────────────────────────┤ MAXVA - PGSIZE</span><br><span class="line">│   Kstack <span class="keyword">for</span> proc N    │  ← 进程N的内核栈</span><br><span class="line">│   Guard <span class="title function_">page</span> <span class="params">(无映射)</span>   │  ← 栈溢出保护，访问会触发异常</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   ...                  │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   Kstack <span class="keyword">for</span> proc 1    │</span><br><span class="line">│   Guard page           │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   Kstack <span class="keyword">for</span> proc 0    │</span><br><span class="line">│   Guard page           │</span><br><span class="line">├────────────────────────┤ </span><br><span class="line">│                        │</span><br><span class="line">│   直接映射区            │  虚拟地址 == 物理地址</span><br><span class="line">│   (内核代码、数据、     │</span><br><span class="line">│    空闲内存)            │</span><br><span class="line">│                        │</span><br><span class="line">├────────────────────────┤ <span class="number">0x80000000</span></span><br><span class="line">│   设备 I/O 映射         │</span><br><span class="line">└────────────────────────┘ <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><h3 id="三、用户进程的虚拟地址空间"><a href="#三、用户进程的虚拟地址空间" class="headerlink" title="三、用户进程的虚拟地址空间"></a>三、用户进程的虚拟地址空间</h3><p>每个进程有自己<strong>独立</strong>的虚拟地址空间：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">用户进程虚拟地址空间 (每个进程看到的)</span><br><span class="line">┌────────────────────────┐ MAXVA</span><br><span class="line">│   Trampoline           │  ← 与内核共享同一物理页</span><br><span class="line">├────────────────────────┤ MAXVA - PGSIZE</span><br><span class="line">│   Trapframe            │  ← 保存寄存器，陷入时使用</span><br><span class="line">├────────────────────────┤ MAXVA - <span class="number">2</span>*PGSIZE</span><br><span class="line">│                        │</span><br><span class="line">│   (未使用)              │</span><br><span class="line">│                        │</span><br><span class="line">├────────────────────────┤ </span><br><span class="line">│   用户栈 (Stack)        │  ← 向下增长</span><br><span class="line">│         ↓              │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   Guard page           │  ← 栈溢出保护</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│         ↑              │</span><br><span class="line">│   堆 (Heap)            │  ← 向上增长 (sbrk)</span><br><span class="line">├────────────────────────┤ p-&gt;sz (进程大小)</span><br><span class="line">│   数据段 (Data/BSS)     │</span><br><span class="line">├────────────────────────┤</span><br><span class="line">│   代码段 (Text)         │</span><br><span class="line">└────────────────────────┘ <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><h2 id="四、页表结构-三级页表"><a href="#四、页表结构-三级页表" class="headerlink" title="四、页表结构 (三级页表)"></a>四、页表结构 (三级页表)</h2><p>RISC-V Sv39 使用<strong>三级页表</strong>，<strong>虚拟地址39位</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">虚拟地址 (<span class="number">39</span>位):</span><br><span class="line">┌─────────┬─────────┬─────────┬──────────────┐</span><br><span class="line">│ L2 (<span class="number">9</span>位)│ L1 (<span class="number">9</span>位)│ L0 (<span class="number">9</span>位)│ Offset (<span class="number">12</span>位)│</span><br><span class="line">└─────────┴─────────┴─────────┴──────────────┘</span><br><span class="line">    │          │          │</span><br><span class="line">    ▼          ▼          ▼</span><br><span class="line">┌────────┐ ┌────────┐ ┌────────┐</span><br><span class="line">│ 页目录<span class="number">2</span> │→│ 页目录<span class="number">1</span> │→│ 页目录<span class="number">0</span> │→ 物理页框</span><br><span class="line">│ <span class="number">512</span>项  │ │ <span class="number">512</span>项  │ │ <span class="number">512</span>项  │</span><br><span class="line">└────────┘ └────────┘ └────────┘</span><br><span class="line">   <span class="number">4</span>KB        <span class="number">4</span>KB        <span class="number">4</span>KB</span><br><span class="line">每个页表项(PTE) <span class="number">64</span>位：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────┬─────────────┐</span><br><span class="line">│           PPN (物理页号, <span class="number">44</span>位)                      │ Flags (<span class="number">10</span>位)│</span><br><span class="line">└────────────────────────────────────────────────────┴─────────────┘</span><br><span class="line">                                                      V R W X U G A D</span><br></pre></td></tr></table></figure><h2 id="五、内核栈详解"><a href="#五、内核栈详解" class="headerlink" title="五、内核栈详解"></a>五、内核栈详解</h2><p>什么是<strong>内核栈</strong>？<br><strong>每个进程有两个栈</strong>：</p><ul><li>用户栈: 在用户空间，运行用户代码时使用</li><li>内核栈: 在内核空间，进程陷入内核(系统调用&#x2F;中断)时使用</li></ul><p><strong>为什么需要内核栈？</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">用户程序调用 read() 系统调用:</span><br><span class="line"></span><br><span class="line">用户态 (U-mode)          内核态 (S-mode)</span><br><span class="line">┌──────────────┐         ┌──────────────┐</span><br><span class="line">│  用户代码     │         │  sys_read()  │</span><br><span class="line">│  调用 read() │ ──ecall──→│  使用内核栈  │</span><br><span class="line">│  用户栈      │         │  执行内核代码 │</span><br><span class="line">└──────────────┘         └──────────────┘</span><br></pre></td></tr></table></figure><blockquote><p>如果内核代码使用用户栈，恶意用户程序可以破坏内核数据。</p></blockquote><p><strong>内核栈在物理内存中的位置</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c - procinit()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="comment">// 为每个进程分配一个物理页作为内核栈</span></span><br><span class="line">    <span class="type">char</span> *pa = kalloc();  <span class="comment">// 从空闲页分配 4KB</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 映射到内核虚拟地址空间的高地址处</span></span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>)(p - proc));</span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">    </span><br><span class="line">    p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、完整的物理内存排布示例"><a href="#六、完整的物理内存排布示例" class="headerlink" title="六、完整的物理内存排布示例"></a>六、完整的物理内存排布示例</h2><p>假设系统有<strong>3个进程运行</strong>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">物理 DDR RAM 实际排布 (地址从低到高)</span><br><span class="line">┌─────────────────────────────────────┐ <span class="number">0x88000000</span></span><br><span class="line">│                                     │</span><br><span class="line">│  空闲页框池 (由 freelist 管理)       │</span><br><span class="line">│                                     │</span><br><span class="line">├─────────────────────────────────────┤ </span><br><span class="line">│  进程<span class="number">2</span>的用户页 (代码+数据+栈+堆)     │ ← 分散在各处</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">2</span>的页表 (<span class="number">3</span>个或更多<span class="number">4</span>KB页)        │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">2</span>的内核栈 (<span class="number">1</span>个<span class="number">4</span>KB页)            │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">1</span>的用户页                       │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">1</span>的页表                         │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">1</span>的内核栈                       │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">0</span> (init) 的用户页               │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">0</span>的页表                         │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  进程<span class="number">0</span>的内核栈                       │</span><br><span class="line">├─────────────────────────────────────┤</span><br><span class="line">│  内核页表                            │</span><br><span class="line">├─────────────────────────────────────┤ end</span><br><span class="line">│  内核 BSS                            │</span><br><span class="line">│  内核 Data                           │</span><br><span class="line">│  内核 Text (包含 trampoline)         │</span><br><span class="line">└─────────────────────────────────────┘ <span class="number">0x80000000</span></span><br></pre></td></tr></table></figure><h2 id="七、关键数据结构"><a href="#七、关键数据结构" class="headerlink" title="七、关键数据结构"></a>七、关键数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>      <span class="comment">// 进程状态</span></span><br><span class="line">  <span class="type">int</span> pid;                   <span class="comment">// 进程ID</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;     <span class="comment">// 用户页表的物理地址</span></span><br><span class="line">  uint64 kstack;             <span class="comment">// 内核栈的虚拟地址</span></span><br><span class="line">  uint64 sz;                 <span class="comment">// 进程内存大小</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// 陷入帧，保存寄存器</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>    <span class="comment">// 上下文，用于切换</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八、图解：一次系统调用的内存使用"><a href="#八、图解：一次系统调用的内存使用" class="headerlink" title="八、图解：一次系统调用的内存使用"></a>八、图解：一次系统调用的内存使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 用户程序在用户空间运行</span><br><span class="line">   ┌─────────────────┐</span><br><span class="line">   │ 用户虚拟地址空间  │</span><br><span class="line">   │ 使用用户栈       │  ← sp 指向用户栈</span><br><span class="line">   └─────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 执行 ecall，陷入内核</span><br><span class="line">   ┌─────────────────┐</span><br><span class="line">   │ trampoline 代码  │  ← 保存寄存器到 trapframe</span><br><span class="line">   │ 切换到内核页表   │</span><br><span class="line">   │ 切换到内核栈     │  ← sp 改为指向内核栈</span><br><span class="line">   └─────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 在内核中执行</span><br><span class="line">   ┌─────────────────┐</span><br><span class="line">   │ 内核虚拟地址空间  │</span><br><span class="line">   │ 使用内核栈       │  ← 内核函数调用使用内核栈</span><br><span class="line">   └─────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 返回用户空间</span><br><span class="line">   ┌─────────────────┐</span><br><span class="line">   │ 恢复用户页表     │</span><br><span class="line">   │ 恢复用户寄存器   │</span><br><span class="line">   │ sret 返回       │  ← sp 恢复为用户栈</span><br><span class="line">   └─────────────────┘</span><br></pre></td></tr></table></figure><p>这样设计的<strong>核心思想是隔离</strong>：</p><ul><li>每个进程有独立的虚拟地址空间，互不干扰；</li><li>用户态和内核态使用不同的栈，保证安全。</li></ul><h1 id="关于文件系统"><a href="#关于文件系统" class="headerlink" title="关于文件系统"></a>关于文件系统</h1><h2 id="文件系统的两层含义"><a href="#文件系统的两层含义" class="headerlink" title="文件系统的两层含义"></a>文件系统的两层含义</h2><p><strong>1. 文件系统代码（在内核中）</strong></p><p>文件系统的实现代码确实在内核代码段里。在 xv6 中主要是这些文件：</p><ul><li><code>fs.c</code> - 文件系统核心逻辑</li><li><code>bio.c</code> - 块缓存层</li><li><code>log.c</code> - 日志层</li></ul><p>这些代码在<strong>内核启动后就加载到 RAM 中</strong>，作为<strong>内核的一部分</strong>运行。</p><p><strong>2. 文件系统结构（在磁盘上）</strong><br>磁盘上按特定格式组织的数据结构：</p><p><code>磁盘布局</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+-------+-------+-------+--------+--------+--------+</span><br><span class="line">| boot  | super | <span class="built_in">log</span>   | inode  | bitmap | data   |</span><br><span class="line">| block | block | blocks| blocks | blocks | blocks |</span><br><span class="line">+-------+-------+-------+--------+--------+--------+</span><br></pre></td></tr></table></figure><p>这是持久化存储的数据，不是代码。</p><h2 id="你理解的流程基本正确"><a href="#你理解的流程基本正确" class="headerlink" title="你理解的流程基本正确"></a>你理解的流程基本正确</h2><p>当执行 <code>ls</code> 程序时：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> shell 调用 exec(<span class="string">&quot;ls&quot;</span>, ...)</span><br><span class="line">          ↓</span><br><span class="line"><span class="number">2.</span> 内核的文件系统代码（在RAM中）解析路径 <span class="string">&quot;/bin/ls&quot;</span></span><br><span class="line">          ↓</span><br><span class="line"><span class="number">3.</span> 查找 inode，获取文件在磁盘上的位置</span><br><span class="line">          ↓</span><br><span class="line"><span class="number">4.</span> 通过磁盘驱动读取 ls 的二进制到 RAM</span><br><span class="line">          ↓</span><br><span class="line"><span class="number">5.</span> 创建新进程，设置页表，跳转执行</span><br></pre></td></tr></table></figure><h2 id="一个类比"><a href="#一个类比" class="headerlink" title="一个类比"></a>一个类比</h2><p>可以这样理解：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">概念类比</span><br><span class="line">文件系统代码图书管理员（知道如何查找书籍）</span><br><span class="line">磁盘上的文件系统结构图书馆的索引卡片系统</span><br><span class="line">磁盘上的文件数据实际的书籍</span><br></pre></td></tr></table></figure><p>图书管理员（代码）使用索引系统（磁盘结构）来定位和取出书籍（文件数据）。</p><h2 id="补充：关于缓存"><a href="#补充：关于缓存" class="headerlink" title="补充：关于缓存"></a>补充：关于缓存</h2><p>你提到”先到 RAM 中找”——xv6 确实有 buffer cache（<code>bio.c</code>），会缓存最近访问的磁盘块。但这是块级别的缓存，不是文件级别的。流程是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">读文件 → 检查 buffer cache → 命中则直接返回</span><br><span class="line">                          → 未命中则从磁盘读取并缓存</span><br></pre></td></tr></table></figure><p>所以你的理解方向是对的，只是缓存的粒度是磁盘块而不是整个文件。</p><h2 id="lab2实验"><a href="#lab2实验" class="headerlink" title="lab2实验"></a>lab2实验</h2><p><img src="/../images/18.5.png" alt="alt text"></p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From <span class="number">566b</span>f1c4d43572f19676aaf6ffd9e4d3df77007b Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Mon, <span class="number">26</span> Jan <span class="number">2026</span> <span class="number">15</span>:<span class="number">48</span>:<span class="number">13</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH <span class="number">1</span>/<span class="number">2</span>] feat: support syscall trace</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> Makefile         |  <span class="number">1</span> +</span><br><span class="line"> kernel/defs.h    |  <span class="number">3</span> +++</span><br><span class="line"> kernel/<span class="built_in">printf</span>.c  | <span class="number">57</span> ++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/proc.c    |  <span class="number">3</span> +++</span><br><span class="line"> kernel/proc.h    |  <span class="number">4</span> +++</span><br><span class="line"> kernel/syscall.c | <span class="number">64</span> ++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> kernel/syscall.h |  <span class="number">1</span> +</span><br><span class="line"> kernel/sysproc.c | <span class="number">16</span> ++++++++++++</span><br><span class="line"> user/user.h      |  <span class="number">1</span> +</span><br><span class="line"> user/usys.pl     |  <span class="number">1</span> +</span><br><span class="line"> <span class="number">10</span> files changed, <span class="number">151</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index c926b7e..<span class="number">6647</span>da5 <span class="number">100644</span></span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ <span class="number">-193</span>,<span class="number">6</span> +<span class="number">193</span>,<span class="number">7</span> @@ UPROGS=\</span><br><span class="line"> $U/_grind\</span><br><span class="line"> $U/_wc\</span><br><span class="line"> $U/_zombie\</span><br><span class="line">+$U/_trace\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index <span class="number">3564</span>db4..b8a90bf <span class="number">100644</span></span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ <span class="number">-80</span>,<span class="number">6</span> +<span class="number">80</span>,<span class="number">9</span> @@ <span class="type">int</span>             pipewrite(<span class="keyword">struct</span> pipe*, uint64, <span class="type">int</span>);</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">printf</span><span class="params">(<span class="type">char</span>*, ...)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">panic</span><span class="params">(<span class="type">char</span>*)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">printfinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">print_binary</span><span class="params">(uint64, <span class="type">int</span>)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">print_binary64</span><span class="params">(uint64)</span>;</span><br><span class="line">+<span class="type">void</span>            <span class="title function_">print_binary32</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// proc.c</span></span><br><span class="line"> <span class="type">int</span>             <span class="title function_">cpuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">diff --git a/kernel/<span class="built_in">printf</span>.c b/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">index e1347de..ecc8165 <span class="number">100644</span></span><br><span class="line">--- a/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">+++ b/kernel/<span class="built_in">printf</span>.c</span><br><span class="line">@@ <span class="number">-132</span>,<span class="number">3</span> +<span class="number">132</span>,<span class="number">60</span> @@ printfinit(<span class="type">void</span>)</span><br><span class="line">   initlock(&amp;pr.lock, <span class="string">&quot;pr&quot;</span>);</span><br><span class="line">   pr.locking = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// 打印 uint64 类型数值的二进制形式</span></span><br><span class="line">+<span class="comment">// num: 要打印的数值</span></span><br><span class="line">+<span class="comment">// bits: 要显示的二进制位数（如32表示显示低32位，64表示显示全部）</span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(uint64 num, <span class="type">int</span> bits)</span> &#123;</span><br><span class="line">+  <span class="comment">// 边界检查：bits 范围 1~64</span></span><br><span class="line">+  <span class="keyword">if</span> (bits &lt; <span class="number">1</span>) bits = <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (bits &gt; <span class="number">64</span>) bits = <span class="number">64</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// 从最高位开始逐位检查</span></span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">int</span> i = bits - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">+    <span class="comment">// 按位与操作：检查第i位是否为1</span></span><br><span class="line">+    uint64 mask = <span class="number">1UL</span> &lt;&lt; i;</span><br><span class="line">+    <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="comment">// 每8位加一个空格，提升可读性（可选）</span></span><br><span class="line">+    <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="comment">// 换行（可选，根据需要调整）</span></span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// 简化版：默认打印64位二进制</span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">print_binary64</span><span class="params">(uint64 num)</span> &#123;</span><br><span class="line">+  print_binary(num, <span class="number">64</span>);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// 专门打印int类型的32位二进制形式</span></span><br><span class="line">+<span class="comment">// num: 要打印的int型数值（xv6中int为32位）</span></span><br><span class="line">+<span class="comment">// 输出格式：每8位加空格分隔，提升可读性</span></span><br><span class="line">+<span class="type">void</span> <span class="title function_">print_binary32</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">+  <span class="comment">// 转换为uint32_t避免负数符号位干扰（保证按位打印的准确性）</span></span><br><span class="line">+  uint32 val = (uint32)num;</span><br><span class="line">+  </span><br><span class="line">+  <span class="comment">// 从第31位（最高位）到第0位（最低位）逐位打印</span></span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">+    <span class="comment">// 生成对应位的掩码（1左移i位）</span></span><br><span class="line">+    uint32 mask = <span class="number">1U</span> &lt;&lt; i;</span><br><span class="line">+    <span class="comment">// 按位与判断该位是1还是0</span></span><br><span class="line">+    <span class="keyword">if</span> (val &amp; mask) &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="comment">// 每8位添加一个空格，方便阅读（如 10000000 00000000 00000000 00100000）</span></span><br><span class="line">+    <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span> &amp;&amp; i != <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+  <span class="comment">// 打印换行，使输出更整洁</span></span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index <span class="number">22e7</span>ce4..<span class="number">83</span>a84e7 <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ <span class="number">-305</span>,<span class="number">6</span> +<span class="number">305</span>,<span class="number">9</span> @@ fork(<span class="type">void</span>)</span><br><span class="line"> </span><br><span class="line">   pid = np-&gt;pid;</span><br><span class="line"> </span><br><span class="line">+  <span class="comment">// seu liangji add, copy trace_mask from parent to child process</span></span><br><span class="line">+  np-&gt;trace_mask = p-&gt;trace_mask;</span><br><span class="line">+</span><br><span class="line">   release(&amp;np-&gt;lock);</span><br><span class="line"> </span><br><span class="line">   acquire(&amp;wait_lock);</span><br><span class="line">diff --git a/kernel/proc.h b/kernel/proc.h</span><br><span class="line">index f6ca8b7..b91b487 <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.h</span><br><span class="line">+++ b/kernel/proc.h</span><br><span class="line">@@ <span class="number">-105</span>,<span class="number">4</span> +<span class="number">105</span>,<span class="number">8</span> @@ <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">   <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// seu liangji add start</span></span><br><span class="line">+  <span class="type">int</span> trace_mask;</span><br><span class="line">+  <span class="comment">// seu liangji add end</span></span><br><span class="line"> &#125;;</span><br><span class="line">diff --git a/kernel/syscall.c b/kernel/syscall.c</span><br><span class="line">index c1b3670..<span class="number">6</span>ac8910 <span class="number">100644</span></span><br><span class="line">--- a/kernel/syscall.c</span><br><span class="line">+++ b/kernel/syscall.c</span><br><span class="line">@@ <span class="number">-104</span>,<span class="number">6</span> +<span class="number">104</span>,<span class="number">7</span> @@ <span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">13</span> +<span class="number">128</span>,<span class="number">55</span> @@ <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_link]    sys_link,</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line">+[SYS_trace]   sys_trace,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">// 系统调用名称数组（索引对应系统调用编号）</span></span><br><span class="line">+<span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* syscall_names[] = &#123;</span><br><span class="line">+    <span class="string">&quot;&quot;</span>,          <span class="comment">// 0: 无对应系统调用</span></span><br><span class="line">+    <span class="string">&quot;fork&quot;</span>,      <span class="comment">// 1</span></span><br><span class="line">+    <span class="string">&quot;exit&quot;</span>,      <span class="comment">// 2</span></span><br><span class="line">+    <span class="string">&quot;wait&quot;</span>,      <span class="comment">// 3</span></span><br><span class="line">+    <span class="string">&quot;pipe&quot;</span>,      <span class="comment">// 4</span></span><br><span class="line">+    <span class="string">&quot;read&quot;</span>,      <span class="comment">// 5</span></span><br><span class="line">+    <span class="string">&quot;kill&quot;</span>,      <span class="comment">// 6</span></span><br><span class="line">+    <span class="string">&quot;exec&quot;</span>,      <span class="comment">// 7</span></span><br><span class="line">+    <span class="string">&quot;fstat&quot;</span>,     <span class="comment">// 8</span></span><br><span class="line">+    <span class="string">&quot;chdir&quot;</span>,     <span class="comment">// 9</span></span><br><span class="line">+    <span class="string">&quot;dup&quot;</span>,       <span class="comment">// 10</span></span><br><span class="line">+    <span class="string">&quot;getpid&quot;</span>,    <span class="comment">// 11</span></span><br><span class="line">+    <span class="string">&quot;sbrk&quot;</span>,      <span class="comment">// 12</span></span><br><span class="line">+    <span class="string">&quot;sleep&quot;</span>,     <span class="comment">// 13</span></span><br><span class="line">+    <span class="string">&quot;uptime&quot;</span>,    <span class="comment">// 14</span></span><br><span class="line">+    <span class="string">&quot;open&quot;</span>,      <span class="comment">// 15</span></span><br><span class="line">+    <span class="string">&quot;write&quot;</span>,     <span class="comment">// 16</span></span><br><span class="line">+    <span class="string">&quot;mknod&quot;</span>,     <span class="comment">// 17</span></span><br><span class="line">+    <span class="string">&quot;unlink&quot;</span>,    <span class="comment">// 18</span></span><br><span class="line">+    <span class="string">&quot;link&quot;</span>,      <span class="comment">// 19</span></span><br><span class="line">+    <span class="string">&quot;mkdir&quot;</span>,     <span class="comment">// 20</span></span><br><span class="line">+    <span class="string">&quot;close&quot;</span>,     <span class="comment">// 21</span></span><br><span class="line">+    <span class="string">&quot;trace&quot;</span>      <span class="comment">// 22</span></span><br><span class="line">+&#125;;</span><br><span class="line">+</span><br><span class="line">+<span class="type">void</span> <span class="title function_">get_syscall_name</span><span class="params">(<span class="type">int</span> id, <span class="type">char</span>* buf)</span></span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="comment">// 清空缓冲区</span></span><br><span class="line">+    *buf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">+    </span><br><span class="line">+    <span class="comment">// 边界检查：确保id在有效范围内</span></span><br><span class="line">+    <span class="keyword">if</span> (id &gt;= <span class="number">1</span> &amp;&amp; id &lt; <span class="keyword">sizeof</span>(syscall_names)/<span class="keyword">sizeof</span>(syscall_names[<span class="number">0</span>])) &#123;</span><br><span class="line">+        <span class="built_in">strncpy</span>(buf, syscall_names[id], <span class="built_in">strlen</span>(syscall_names[id]));</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+        <span class="built_in">strncpy</span>(buf, <span class="string">&quot;unknown&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;unknown&quot;</span>));</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="type">void</span></span><br><span class="line"> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="type">int</span> num;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">+  <span class="comment">//printf(&quot;%d: syscall\n&quot;, p-&gt;pid);</span></span><br><span class="line"> </span><br><span class="line">   num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">   <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">@@ <span class="number">-143</span>,<span class="number">4</span> +<span class="number">186</span>,<span class="number">25</span> @@ syscall(<span class="type">void</span>)</span><br><span class="line">             p-&gt;pid, p-&gt;name, num);</span><br><span class="line">     p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// seu liangji add, trace info print</span></span><br><span class="line">+  <span class="type">int</span> temp = p-&gt;trace_mask;</span><br><span class="line">+  <span class="type">char</span> syscall_name[<span class="number">32</span>];</span><br><span class="line">+  <span class="built_in">memset</span>(syscall_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(syscall_name));</span><br><span class="line">+  get_syscall_name(num, syscall_name);</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  if(temp != 0)</span></span><br><span class="line"><span class="comment">+  &#123;</span></span><br><span class="line"><span class="comment">+      printf(&quot;temp = %d,    num = %d\n&quot;, temp, num);</span></span><br><span class="line"><span class="comment">+      print_binary32(temp);</span></span><br><span class="line"><span class="comment">+      print_binary32(1&lt;&lt;num);</span></span><br><span class="line"><span class="comment">+      printf(&quot;%d\n&quot;, (temp &amp; (1&lt;&lt;num)));</span></span><br><span class="line"><span class="comment">+  &#125;</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span>((temp &amp; (<span class="number">1</span>&lt;&lt;num))!=<span class="number">0</span>)</span><br><span class="line">+  &#123;</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_name, p-&gt;trapframe-&gt;a0);</span><br><span class="line">+  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/kernel/syscall.h b/kernel/syscall.h</span><br><span class="line">index bc5f356..cc112b9 <span class="number">100644</span></span><br><span class="line">--- a/kernel/syscall.h</span><br><span class="line">+++ b/kernel/syscall.h</span><br><span class="line">@@ <span class="number">-20</span>,<span class="number">3</span> +<span class="number">20</span>,<span class="number">4</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index e8bcda9..<span class="number">095982f</span> <span class="number">100644</span></span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ <span class="number">-95</span>,<span class="number">3</span> +<span class="number">95</span>,<span class="number">19</span> @@ sys_uptime(<span class="type">void</span>)</span><br><span class="line">   release(&amp;tickslock);</span><br><span class="line">   <span class="keyword">return</span> xticks;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// trace</span></span><br><span class="line">+uint64</span><br><span class="line">+sys_trace(<span class="type">void</span>)</span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="comment">//get trace(int) int to p</span></span><br><span class="line">+    <span class="type">int</span> p;</span><br><span class="line">+    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">+        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+</span><br><span class="line">+    myproc()-&gt;trace_mask = p;</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+</span><br><span class="line">diff --git a/user/user.h b/user/user.h</span><br><span class="line">index b71ecda..fdeeefc <span class="number">100644</span></span><br><span class="line">--- a/user/user.h</span><br><span class="line">+++ b/user/user.h</span><br><span class="line">@@ <span class="number">-23</span>,<span class="number">6</span> +<span class="number">23</span>,<span class="number">7</span> @@ <span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// ulib.c</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line">diff --git a/user/usys.pl b/user/usys.pl</span><br><span class="line">index <span class="number">01e426</span>e..<span class="number">9</span>c97b05 <span class="number">100755</span></span><br><span class="line">--- a/user/usys.pl</span><br><span class="line">+++ b/user/usys.pl</span><br><span class="line">@@ <span class="number">-36</span>,<span class="number">3</span> +<span class="number">36</span>,<span class="number">4</span> @@ entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="sysinfo"><a href="#sysinfo" class="headerlink" title="sysinfo"></a>sysinfo</h3><blockquote><p>xv6 的kalloc.c中，空闲内存是通过链表（kmem.freelist） 管理的，而非连续的物理地址区间</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">From <span class="number">42f</span>4a5077d04d76130213378209d504169c9c853 Mon Sep <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2001</span></span><br><span class="line">From: liangji-seu &lt;<span class="number">15262272286</span>@<span class="number">163.</span>com&gt;</span><br><span class="line">Date: Mon, <span class="number">26</span> Jan <span class="number">2026</span> <span class="number">18</span>:<span class="number">34</span>:<span class="number">18</span> +<span class="number">0800</span></span><br><span class="line">Subject: [PATCH <span class="number">2</span>/<span class="number">2</span>] feat: support sysinfo</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"> Makefile         |  <span class="number">1</span> +</span><br><span class="line"> kernel/defs.h    |  <span class="number">3</span> +++</span><br><span class="line"> kernel/kalloc.c  | <span class="number">13</span> +++++++++++</span><br><span class="line"> kernel/proc.c    | <span class="number">15</span> +++++++++++++</span><br><span class="line"> kernel/syscall.c |  <span class="number">3</span> +++</span><br><span class="line"> kernel/syscall.h |  <span class="number">1</span> +</span><br><span class="line"> kernel/sysproc.c | <span class="number">57</span> ++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> user/user.h      |  <span class="number">2</span> ++</span><br><span class="line"> user/usys.pl     |  <span class="number">1</span> +</span><br><span class="line"> <span class="number">9</span> files changed, <span class="number">96</span> insertions(+)</span><br><span class="line"></span><br><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index <span class="number">6647</span>da5..cfb5119 <span class="number">100644</span></span><br><span class="line">--- a/Makefile</span><br><span class="line">+++ b/Makefile</span><br><span class="line">@@ <span class="number">-194</span>,<span class="number">6</span> +<span class="number">194</span>,<span class="number">7</span> @@ UPROGS=\</span><br><span class="line"> $U/_wc\</span><br><span class="line"> $U/_zombie\</span><br><span class="line"> $U/_trace\</span><br><span class="line">+$U/_sysinfotest\</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">diff --git a/kernel/defs.h b/kernel/defs.h</span><br><span class="line">index b8a90bf..<span class="number">0</span>a6f5c1 <span class="number">100644</span></span><br><span class="line">--- a/kernel/defs.h</span><br><span class="line">+++ b/kernel/defs.h</span><br><span class="line">@@ <span class="number">-63</span>,<span class="number">6</span> +<span class="number">63</span>,<span class="number">7</span> @@ <span class="type">void</span>            ramdiskrw(<span class="keyword">struct</span> buf*);</span><br><span class="line"> <span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">int</span>             <span class="title function_">get_leave_mem</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// log.c</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">initlog</span><span class="params">(<span class="type">int</span>, <span class="keyword">struct</span> superblock*)</span>;</span><br><span class="line">@@ <span class="number">-107</span>,<span class="number">6</span> +<span class="number">108</span>,<span class="number">8</span> @@ <span class="type">void</span>            <span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">either_copyout</span><span class="params">(<span class="type">int</span> user_dst, uint64 dst, <span class="type">void</span> *src, uint64 len)</span>;</span><br><span class="line"> <span class="type">int</span>             <span class="title function_">either_copyin</span><span class="params">(<span class="type">void</span> *dst, <span class="type">int</span> user_src, uint64 src, uint64 len)</span>;</span><br><span class="line"> <span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="type">int</span>             <span class="title function_">get_not_unused_proc_num</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// swtch.S</span></span><br><span class="line"> <span class="type">void</span>            <span class="title function_">swtch</span><span class="params">(<span class="keyword">struct</span> context*, <span class="keyword">struct</span> context*)</span>;</span><br><span class="line">diff --git a/kernel/kalloc.c b/kernel/kalloc.c</span><br><span class="line">index fa6a0ac..<span class="number">8</span>ac4961 <span class="number">100644</span></span><br><span class="line">--- a/kernel/kalloc.c</span><br><span class="line">+++ b/kernel/kalloc.c</span><br><span class="line">@@ <span class="number">-80</span>,<span class="number">3</span> +<span class="number">80</span>,<span class="number">16</span> @@ kalloc(<span class="type">void</span>)</span><br><span class="line">     <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">int</span></span><br><span class="line">+get_leave_mem()</span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">+    acquire(&amp;kmem.lock);</span><br><span class="line">+    <span class="type">int</span> count= <span class="number">0</span>;</span><br><span class="line">+    r = kmem.freelist;</span><br><span class="line">+    <span class="keyword">for</span>(r = kmem.freelist; r; r = r-&gt;next)&#123;</span><br><span class="line">+        count++;</span><br><span class="line">+    &#125;</span><br><span class="line">+    release(&amp;kmem.lock);</span><br><span class="line">+    <span class="comment">//return bytes</span></span><br><span class="line">+    <span class="keyword">return</span> count * <span class="number">4096</span>;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/proc.c b/kernel/proc.c</span><br><span class="line">index <span class="number">83</span>a84e7..<span class="number">68</span>a8c29 <span class="number">100644</span></span><br><span class="line">--- a/kernel/proc.c</span><br><span class="line">+++ b/kernel/proc.c</span><br><span class="line">@@ <span class="number">-657</span>,<span class="number">3</span> +<span class="number">657</span>,<span class="number">18</span> @@ procdump(<span class="type">void</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">+</span><br><span class="line">+<span class="type">int</span></span><br><span class="line">+get_not_unused_proc_num()</span><br><span class="line">+&#123;</span><br><span class="line">+    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">+    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">+        <span class="keyword">if</span>(p-&gt;state != UNUSED)</span><br><span class="line">+        &#123;</span><br><span class="line">+            num++;</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">return</span> num;</span><br><span class="line">+&#125;</span><br><span class="line">diff --git a/kernel/syscall.c b/kernel/syscall.c</span><br><span class="line">index <span class="number">6</span>ac8910..<span class="number">041f</span>72a <span class="number">100644</span></span><br><span class="line">--- a/kernel/syscall.c</span><br><span class="line">+++ b/kernel/syscall.c</span><br><span class="line">@@ <span class="number">-105</span>,<span class="number">6</span> +<span class="number">105</span>,<span class="number">7</span> @@ <span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">+<span class="keyword">extern</span> uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_fork]    sys_fork,</span><br><span class="line">@@ <span class="number">-129</span>,<span class="number">6</span> +<span class="number">130</span>,<span class="number">7</span> @@ <span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line"> [SYS_mkdir]   sys_mkdir,</span><br><span class="line"> [SYS_close]   sys_close,</span><br><span class="line"> [SYS_trace]   sys_trace,</span><br><span class="line">+[SYS_sysinfo]   sys_sysinfo,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 系统调用名称数组（索引对应系统调用编号）</span></span><br><span class="line">@@ <span class="number">-156</span>,<span class="number">6</span> +<span class="number">158</span>,<span class="number">7</span> @@ <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* syscall_names[] = &#123;</span><br><span class="line">     <span class="string">&quot;mkdir&quot;</span>,     <span class="comment">// 20</span></span><br><span class="line">     <span class="string">&quot;close&quot;</span>,     <span class="comment">// 21</span></span><br><span class="line">     <span class="string">&quot;trace&quot;</span>      <span class="comment">// 22</span></span><br><span class="line">+    <span class="string">&quot;sysinfo&quot;</span>    <span class="comment">// 23</span></span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> <span class="title function_">get_syscall_name</span><span class="params">(<span class="type">int</span> id, <span class="type">char</span>* buf)</span></span><br><span class="line">diff --git a/kernel/syscall.h b/kernel/syscall.h</span><br><span class="line">index cc112b9..0dfedc7 100644</span><br><span class="line">--- a/kernel/syscall.h</span><br><span class="line">+++ b/kernel/syscall.h</span><br><span class="line">@@ -21,3 +21,4 @@</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line">+<span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br><span class="line">diff --git a/kernel/sysproc.c b/kernel/sysproc.c</span><br><span class="line">index 095982f..fedc89c 100644</span><br><span class="line">--- a/kernel/sysproc.c</span><br><span class="line">+++ b/kernel/sysproc.c</span><br><span class="line">@@ -6,6 +6,7 @@</span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line">+<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysinfo.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"> uint64</span><br><span class="line"> <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">@@ -110,4 +111,60 @@ <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">//sysinfo</span></span><br><span class="line">+uint64</span><br><span class="line">+<span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">+&#123;</span><br><span class="line">+  uint64 i; <span class="comment">// user pointer to user space sysinfo</span></span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;i) &lt; <span class="number">0</span>)</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">temp</span>;</span></span><br><span class="line">+  temp.freemem = get_leave_mem();</span><br><span class="line">+  temp.nproc = get_not_unused_proc_num();</span><br><span class="line">+</span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">+  <span class="keyword">if</span>(copyout(p-&gt;pagetable, i, (<span class="type">char</span> *)&amp;temp, <span class="keyword">sizeof</span>(temp)) &lt; <span class="number">0</span>)</span><br><span class="line">+    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">//</span></span><br><span class="line">+  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br><span class="line"> </span><br><span class="line">diff --git a/user/user.h b/user/user.h</span><br><span class="line">index fdeeefc..<span class="number">6b</span>a24e6 <span class="number">100644</span></span><br><span class="line">--- a/user/user.h</span><br><span class="line">+++ b/user/user.h</span><br><span class="line">@@ <span class="number">-1</span>,<span class="number">5</span> +<span class="number">1</span>,<span class="number">6</span> @@</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span>;</span></span><br><span class="line">+<span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// system calls</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">@@ <span class="number">-24</span>,<span class="number">6</span> +<span class="number">25</span>,<span class="number">7</span> @@ <span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">+<span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// ulib.c</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line">diff --git a/user/usys.pl b/user/usys.pl</span><br><span class="line">index <span class="number">9</span>c97b05..bc109fd <span class="number">100755</span></span><br><span class="line">--- a/user/usys.pl</span><br><span class="line">+++ b/user/usys.pl</span><br><span class="line">@@ <span class="number">-37</span>,<span class="number">3</span> +<span class="number">37</span>,<span class="number">4</span> @@ entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line"> entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">+entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br><span class="line">-- </span><br><span class="line"><span class="number">2.25</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#xv6-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0&quot;&gt;XV6 启动过程概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%90%AF%E5%8A%A8%E8%BF%87%</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="XV6" scheme="http://example.com/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>xv6 lab1</title>
    <link href="http://example.com/2026/01/21/xv6-lab1/"/>
    <id>http://example.com/2026/01/21/xv6-lab1/</id>
    <published>2026-01-21T09:27:07.000Z</published>
    <updated>2026-02-20T13:51:20.754Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li><li><a href="#%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0">文档学习</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98">进程和内存</a></li><li><a href="#io%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">IO和文件描述符</a></li><li><a href="#%E7%AE%A1%E9%81%93">管道</a></li><li><a href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a><ul><li><a href="#%E6%88%91%E7%9A%84%E6%8F%90%E9%97%AE">我的提问</a></li><li><a href="#gemini%E5%9B%9E%E7%AD%94">gemini回答</a></li></ul></li><li><a href="#%E6%9C%80%E5%90%8E">最后</a></li></ul></li><li><a href="#%E4%BD%9C%E4%B8%9A%E9%99%84%E4%BB%B6">作业附件</a></li></ul><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>本实验，主要了解内核，系统调用的关系，硬件主要基于risc v 架构（使用qemu代替），操作系统使用xv6教学操作系统。<br>xv6资源汇总链接：<a href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/#_4">https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/#_4</a><br>课程网站：<br><a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></p><p>本实验是在WSL上安装的ubuntu20.04（2021版本的xv6操作系统实验要求是用的20.04，后面2025换成22.04了好像），以下是针对文档的学习，还有lab1 内每个习题的理解与记录。</p><h1 id="文档学习"><a href="#文档学习" class="headerlink" title="文档学习"></a>文档学习</h1><p>第一章节，主要了解了操作系统的接口，内核和系统调用的关系，学习如何使用系统调用。操作系统分为内核空间和用户空间，<br><img src="/../images/17.1.png" alt="alt text"></p><p>我的理解就是，内核空间是真正的裸机，他能访问所有的硬件资源，并把底层的各种资源，封装成系统调用，供给用户空间使用，这样实现了软件和硬件的隔离。</p><h2 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h2><p>xv6的进程是由用户空间内存（指令，数据，堆栈）和内核私有的每个进程状态组成。</p><p>一些与进程相关的系统调用：<br><strong>fork</strong>()创建子进程，实际使用时需要注意</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//fork()后,父进程的内存完整的拷贝过来，</span></span><br><span class="line"><span class="comment">// 父进程的fork返回子进程的pid,子进程的fork返回0</span></span><br><span class="line"><span class="keyword">if</span>(fork()==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//child</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//子进程一定要退出，不然子进程会执行下面的父进程内容</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    wait(<span class="number">0</span>); <span class="comment">//父进程要等待子进程退出，不关心正常是否</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//parent</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>getpid</strong>()获取当前进程的pid（进程描述符）</p><p><strong>exit</strong>()结束进程执行，并释放内存和打开的文件资源。0表示成功，1表示失败。</p><p>进程结束需要记得退出，不然会报错。</p><p><strong>wait</strong>()返回当前进程已退出的子进程的PID，若子进程没有退出，一直等待。没有子进程则直接返回-1，如果父进程不关心子进程的退出状态，直接wait(0),表示仅等待。</p><p>常用系统调用：<br><img src="/../images/17.2.png" alt="alt text"></p><p><strong>exec()</strong> 采用两个参数，包含：可执行文件的文件名， 字符串参数数组。会把当前调用exec的程序替换成参数列表里面的程序，实际上就是跳转执行了。<br>实际使用时，需注意：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* arg[MAXLEN];</span><br><span class="line">arg[<span class="number">0</span>] = cmd; <span class="comment">// &quot;grep&quot;//参数列表的第一个是指令</span></span><br><span class="line">arg[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">arg[<span class="number">2</span>] = argv[<span class="number">2</span>];</span><br><span class="line">...</span><br><span class="line">arg[argc] = <span class="number">0</span>;   <span class="comment">//参数列表的最后一个一定要是0，这样exec才知道参数列表结束</span></span><br><span class="line"></span><br><span class="line">exec(arg[<span class="number">0</span>], arg)</span><br></pre></td></tr></table></figure><p>Xv6 隐式分配大部分用户空间内存：fork分配父内存的子副本所需内存。并且exec分配足够的内存来保存可执行文件。运行时需要更多的内存的进程，可以调用sbrk(n)来将内存增长n字节。</p><h2 id="IO和文件描述符"><a href="#IO和文件描述符" class="headerlink" title="IO和文件描述符"></a>IO和文件描述符</h2><p><strong>fd(file descriptor)： 文件描述符</strong>：<br>是一个小整数，int， 表示进程可以读&#x2F;写的 <strong>内核管理对象</strong>。</p><p>获取fd的方式：</p><ol><li>open 文件&#x2F;目录&#x2F;设备</li><li>创建管道pipe</li><li>dup,fork复制现有fd</li></ol><blockquote><p>为了简单期间，经常将文件描述符所指的对象，称为<strong>文件</strong></p></blockquote><blockquote><p>用文件描述符fd的目的，就是为了做一层封装，抽象出文件，管道，目录，设备的区别和差异。用起来都是字节流，因此读写就是输入输出 I&#x2F;O </p></blockquote><p>简单来说，<strong>进程想要输入输出，必须要通过文件描述符</strong>，他把所有输入输出对象全部抽象成<strong>抽象文件</strong>，可以更方便的专注于内部逻辑。</p><p>而想要从实际文件中<strong>创建fd</strong>，open，必须要依赖<strong>文件名</strong>（你总得知道是什么文件对吧），这个文件名就是底层索引单元的link了，详细介绍见<strong>文件系统</strong>。</p><p><img src="/../images/17.3.png" alt="alt text"></p><p>因为<strong>每个进程都有一个进程表</strong>，xv6内核通过<strong>文件描述符</strong>作为每个进程表的<strong>索引</strong> ，每个进程都有从0开始的fd的私有空间</p><p>一般来说，对于每个进程，约定</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = <span class="number">0</span> <span class="comment">// 标准输入，对于进程来说，read(0, ...), 从shell终端读</span></span><br><span class="line">fd = <span class="number">1</span> <span class="comment">// 标准输出，对于进程来说，write(1, ...)，向shell终端写</span></span><br><span class="line">fd = <span class="number">2</span> <span class="comment">// 标准错误，错误信息输出到shell.</span></span><br></pre></td></tr></table></figure><p>利用这个约定的fd，以及每个进程表私有fd空间，<strong>shell</strong>通过<strong>释放0，1，2 fd</strong>，然后重新open申请fd，可以实现<strong>输入输出重定向</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx &lt; test.txt</span><br><span class="line">xxx &gt; test.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>dup</strong>()系统调用<br>复制现有的文件描述符，返回引用同一底层I&#x2F;O对象的新文件描述符fd&#96;,两个fd共享同一个文件偏移量，和fork起到一样的复制作用。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>pipe，是一个小型内核缓冲区，作为一对读写文件描述符，向进程公开，一个用于读取，一个用于写入。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p[0] read</span></span><br><span class="line"><span class="comment">// p[1] write</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>shell中实现管道 | 可以通过close(0), 关掉从shell中read, 然后dup复制p[0],就可以重新占用0, 相当于把标准读，替换成了管道读。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>xv6的<strong>文件系统</strong>提供<strong>数据文件</strong>（包含未解释的字节数组）和<strong>目录</strong>（包含对数据文件和其他目录的命名引用）</p><p>这些目录形成一颗树，从第一个文件（目录），称为root(&#x2F;)，</p><p><img src="/../images/17.4.png" alt="alt text"></p><p><strong>chdir</strong>()系统调用：相当于cd，切换进程的当前目录<br><strong>mkdir</strong>()系统调用：创建新目录。<br><strong>open</strong>()系统调用：创建标志位 O_CREATE 表示创建一个新的数据文件。<br><strong>mknod</strong>()创建一个新的设备文件。这个文件是引用设备的特殊文件。与设备文件关联的是主设备号和次设备号。唯一标识一个内核设备。当进程稍后打开设备文件后，<strong>内核会转移read和write系统调用内核设备实现</strong>，而不是传递到文件系统做通用的读取字节。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mknod(<span class="string">&quot;/console&quot;</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>文件名和文件本身不是一个概念：<br><strong>底层文件</strong>是唯一的，称为inode,可以<strong>有多个名称&#x2F;链接</strong>，称为links</p><blockquote><p>每个链接由目录中的一个条目组成，每个条目包含文件名和对底层索引节点的引用</p></blockquote><blockquote><p>一个inode底层索引节点，保存一个metadata，里面关于文件的类型，长度，磁盘位置，链接数等。</p></blockquote><ul><li>简单说就是：无论是目录，还是数据文件，还是设备文件，这些文件，在文件系统中，都叫底层索引节点。是文件系统对ROM的抽象封装。每个底层索引节点（就是树状图的一个节点）</li><li><ol><li><strong>stat结构体，也就是metadata</strong>, 里面会描述这个底层索引节点的inod号，link链接数（也就是有多少个文件名显示在文件系统的文件树上），底层索引文件的类型（是文件，还是目录）</li></ol></li><li><ol start="2"><li>如果这个<strong>底层索引节点的类型是文件</strong>，那么就直接open，read，write。</li></ol></li><li><ol start="3"><li>如果这个<strong>底层索引节点的类型是目录</strong>，那么目录文件的内容：是一个个 struct dirent（directory entry，目录项）。里面可以获得这个子目录下的所有文件名。一次read一个目录项</li></ol></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">     <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 构造当前文件的绝对目录 temp = &quot;./&quot;   &quot;./a/&quot;</span></span><br><span class="line">     <span class="type">char</span> temp[<span class="number">512</span>];</span><br><span class="line">     <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">     <span class="built_in">strcpy</span>(temp, buf);</span><br><span class="line">     p = temp + <span class="built_in">strlen</span>(temp);</span><br><span class="line">     *p = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">     p++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// temp = &quot;./.&quot;    &quot;./..&quot;    &quot;./b&quot;    &quot;./a&quot;</span></span><br><span class="line">     memmove(p, de.name, DIRSIZ);</span><br><span class="line">     p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> _<span class="title">st</span>;</span></span><br><span class="line">     <span class="keyword">if</span>(stat(temp, &amp;_st) &lt; <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果是文件，匹配名称</span></span><br><span class="line">     <span class="keyword">if</span>(_st.type == T_FILE)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name, name))&#123;</span><br><span class="line">             <span class="comment">// 发现一致文件名的文件</span></span><br><span class="line">             <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%s/%s\n&quot;</span>, buf, de.name);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果是目录</span></span><br><span class="line">     <span class="keyword">if</span>(_st.type == T_DIR)&#123;</span><br><span class="line">         <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//fprintf(2,&quot;not check ../.\n&quot;);</span></span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//fprintf(1, &quot;next search path: %s\n&quot;, temp);</span></span><br><span class="line">         search(temp, name);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="我的提问"><a href="#我的提问" class="headerlink" title="我的提问"></a>我的提问</h3><p>我说一下我的理解，你看看对不对：</p><p>内存上的一块区域是单纯的01的存储空间，在其之上是有一个文件系统，我们的进程访问这些内存都是需要通过文件系统，才能知道如何访问这些内存里面的文件的。</p><p>文件系统把这些内存抽象成了两类，一个是数据文件，另一个是目录（里面包括数据文件和目录）。在内存中，每一个文件，或者目录，对于文件系统而言，是一个底层索引单元。</p><p>所以如果现在我给你一个&#x2F;a 这样一个字符串，我其实是不知道他是目录，还是文件的，但是这个字符串只是表示是root目录 &#x2F; 下的a文件，不知道这个a是数据文件，还是目录。</p><p>所以我就只能先open 这个&#x2F;a， 得到fd来访问它。然后通过fstat系统调用来获取这个底层索引单元的信息，直到他的类型是文件，还是目录，还是设备，可以知道这个底层索引单元的inod的索引号，知道他的link数（在文件系统上有</p><h3 id="gemini回答"><a href="#gemini回答" class="headerlink" title="gemini回答"></a>gemini回答</h3><p>你的理解非常出色，已经抓住了 Unix 文件系统的精髓！你已经从“用户视角”切换到了“系统程序员视角”。</p><p>为了让你的理解更严谨，我针对你的描述进行一些微调和深度补充，这将直接帮助你写出 find。</p><p><strong>存储介质：内存 (RAM) vs 磁盘 (Disk)</strong></p><p>你提到的“内存上的区域”在操作系统语境下，更多是指磁盘（或者说块设备）。</p><p>磁盘是持久化存储 01 信号的地方。</p><p>文件系统是磁盘上数据的组织方式。它把磁盘的扇区抽象成了我们看到的目录树。</p><p>进程通过内核提供的系统调用（open, read）来跨越这个抽象层。</p><p><strong>底层索引单元：Inode (索引节点)</strong><br>你提到的“底层索引单元”在 Unix 中被称为 Inode。</p><p>Inode 存储的是文件的元数据 (Metadata)：文件类型（文件&#x2F;目录&#x2F;设备）、大小、在磁盘上的物理位置、连接数等。</p><p>重点： Inode 里面不包含文件名。</p><p><strong>文件名与 Link 的真相</strong></p><p>这是你理解中最关键的一环。你问：“目录是由一连串的 link 字符串构成吗？” 是的，但更精确地说，目录是一个特殊的文件，它的内容是一张“映射表”。</p><p>目录文件的内容：是一个个 struct dirent（directory entry，目录项）。</p><p>每个目录项包含：</p><p>文件名 (如 “a”)。</p><p>Inode 编号 (如 12)。</p><p>所谓 Link：当你看到路径 &#x2F;a，其实是根目录 &#x2F; 这个“表”里有一行记录：名字叫 a，对应的 Inode 号是 12。</p><p><strong>Q: fstat 怎么翻译？</strong></p><p>stat 是 Status 的缩写，意为“状态”。</p><p>stat(path, &amp;st)：通过路径获取文件的状态。</p><p>fstat(fd, &amp;st)：通过文件描述符（已经打开的文件）获取状态。 它们最终拿到的都是那个 Inode 里的信息。</p><p><strong>Q: 目录是由一连串 link 构成并用 read 读取吗？</strong></p><p>完全正确！</p><p>当你对一个普通文件 read 时，你读到的是文件的内容（比如文本、代码）。</p><p>当你对一个目录文件 read 时，你读到的是 struct dirent 结构体序列。</p><p>这就是为什么 ls.c 里有一个 while(read(fd, &amp;de, sizeof(de)))。它在翻看这个目录的“档案柜”，把里面的每一条记录（文件名 + Inode号）都读出来。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><img src="/../images/17.5.png" alt="alt text"></p><h1 id="作业附件"><a href="#作业附件" class="headerlink" title="作业附件"></a>作业附件</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%B4%E6%98%8E&quot;&gt;说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0&quot;&gt;文档学习&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/OS/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="XV6" scheme="http://example.com/tags/XV6/"/>
    
  </entry>
  
  <entry>
    <title>stm32 printf实现</title>
    <link href="http://example.com/2025/12/24/stm32-printf%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2025/12/24/stm32-printf%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-12-24T15:15:12.000Z</published>
    <updated>2026-02-20T13:51:20.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-标准库-printf-原理"><a href="#1-标准库-printf-原理" class="headerlink" title="1. 标准库 printf 原理"></a>1. 标准库 printf 原理</h1><p>2.1.1 printf函数的C标准库实现原理</p><p>printf 函数是 C 语言标准库中实现输入输出功能的一个核心函数。它通过可变参数列表（variadic function）的方式，允许开发者传递不同类型和数量的参数，并将这些参数格式化输出到标准输出设备。在内部， printf 利用格式化字符串来定义输出的格式，这个字符串包含了文本内容以及转换说明符（如 %d , %f , %s 等）。</p><p>在 C 标准库中， printf 的实现通常涉及以下几个关键步骤：</p><ol><li>通过格式化字符串解析出转换说明符。</li><li>根据转换说明符确定对应参数的类型。</li><li>根据参数类型进行相应的数据解析和格式化处理。</li><li>将格式化后的数据输出到标准输出。</li></ol><p>printf 在实际输出之前，通常会使用缓冲机制暂存输出数据，以减少实际的 I&#x2F;O 操作次数，提高效率。<br>2.1.2 标准输出的缓冲机制</p><p>标准输出的缓冲机制是一种常见的优化手段，它使得数据在写入到输出设备之前可以先存储在缓冲区中。缓冲区的大小和策略会影响程序的性能，例如， printf 默认使用的是行缓冲（line buffering），这意味着当输出数据包含换行符（ \n ）或者缓冲区满时，缓冲区中的数据会被刷新（flush）到真正的输出设备。</p><p>缓冲机制的设计对程序性能有着极大的影响。对于嵌入式系统而言，正确的管理缓冲区能有效减少 CPU 的使用率和内存的开销。 </p><h1 id="2-stm32中的printf实现"><a href="#2-stm32中的printf实现" class="headerlink" title="2. stm32中的printf实现"></a>2. stm32中的printf实现</h1><p>由标准库的printf的实现原理，唯一的不同就在于，最后一步用fputc来将数据输出到标准输出，由于我们stm32里面没有标准输出。所以我们只有在main中初始化好usart，之后覆写fputc函数来将输出重定向到我们的usart串口中。</p><h1 id="3-为什么是否使用微库都能成功？"><a href="#3-为什么是否使用微库都能成功？" class="headerlink" title="3. 为什么是否使用微库都能成功？"></a>3. 为什么是否使用微库都能成功？</h1><p>在STM32中，无论是使用<strong>微库（Micro LIB）</strong> 还是<strong>标准C库（Standard C Library）</strong>，都能通过重写<code>fputc</code>函数实现<code>printf</code>到串口的输出，核心原因是两者都遵循C语言标准库的<strong>接口约定</strong>，且<code>printf</code>的底层实现逻辑对“输出设备”的依赖性较弱。具体原因如下：</p><h3 id="1-微库（Micro-LIB）与标准库的共性：依赖fputc作为输出入口"><a href="#1-微库（Micro-LIB）与标准库的共性：依赖fputc作为输出入口" class="headerlink" title="1. 微库（Micro LIB）与标准库的共性：依赖fputc作为输出入口"></a>1. 微库（Micro LIB）与标准库的共性：依赖<code>fputc</code>作为输出入口</h3><p><code>printf</code>函数的本质是“格式化字符串输出”，其核心逻辑是将格式化后的字符序列通过一个底层函数逐个输出。在C标准中，这个底层输出函数就是<code>fputc</code>（用于向指定的<code>FILE</code>流写入单个字符）。</p><p>无论是微库还是标准库，<code>printf</code>的实现都会<strong>最终调用<code>fputc</code></strong> 来完成字符的实际输出。因此，只要重写<code>fputc</code>函数，将其指向串口发送，<code>printf</code>的输出就会被“劫持”到串口，与使用哪种库无关。</p><h3 id="2-微库与标准库的差异不影响fputc的重写逻辑"><a href="#2-微库与标准库的差异不影响fputc的重写逻辑" class="headerlink" title="2. 微库与标准库的差异不影响fputc的重写逻辑"></a>2. 微库与标准库的差异不影响<code>fputc</code>的重写逻辑</h3><p>两者的主要区别体现在<strong>功能完整性、代码体积、底层实现细节</strong>上，但这些差异不影响对<code>fputc</code>的重写：</p><ul><li><p><strong>微库（Micro LIB）</strong>：<br>是为嵌入式系统优化的轻量级库，功能简化（如不支持完整的文件I&#x2F;O、多线程安全等），代码体积小，直接运行在裸机环境中。其<code>fputc</code>的默认实现可能是“空操作”或指向一个无效设备，但允许用户通过重写函数来替换默认行为。</p></li><li><p><strong>标准C库（如GNU C Library, Newlib）</strong>：<br>功能完整，支持复杂的I&#x2F;O操作（如文件、管道等），但代码体积较大。在嵌入式环境中，标准库通常需要“移植层”（如<code>syscalls.c</code>）来适配硬件，其中<code>fputc</code>的默认实现可能依赖底层的<code>write</code>系统调用，但用户仍可通过重写<code>fputc</code>（或<code>write</code>）来覆盖默认行为，将输出定向到串口。</p></li></ul><h3 id="3-重写fputc的本质：覆盖默认输出目标"><a href="#3-重写fputc的本质：覆盖默认输出目标" class="headerlink" title="3. 重写fputc的本质：覆盖默认输出目标"></a>3. 重写<code>fputc</code>的本质：覆盖默认输出目标</h3><p>无论是哪种库，<code>fputc</code>都是一个<strong>可重定义的弱函数</strong>（或通过链接优先级被用户实现覆盖）。用户重写的<code>fputc</code>会取代库中的默认实现，成为<code>printf</code>调用的实际输出函数。</p><p>例如：</p><ul><li>微库中，<code>fputc</code>的默认实现可能直接返回（无输出），用户重写后，<code>printf</code>会使用用户定义的串口发送逻辑。</li><li>标准库中，<code>fputc</code>可能默认尝试向“标准输出设备（stdout）”写入，但在嵌入式系统中“stdout”无实际硬件对应，用户重写后，输出会被强制转向串口。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>微库和标准库都能支持<code>printf</code>重定向到串口，核心原因是：<br><strong>两者都遵循<code>printf</code>依赖<code>fputc</code>输出字符的标准逻辑，而<code>fputc</code>的实现可以被用户重写，从而将输出目标从默认设备（无实际意义）改为串口</strong>。  </p><p>差异仅在于库的底层实现细节（如是否需要额外的移植层文件），但不影响重定向的核心原理。因此，无论选择哪种库，只要正确重写<code>fputc</code>，就能实现串口输出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-标准库-printf-原理&quot;&gt;&lt;a href=&quot;#1-标准库-printf-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 标准库 printf 原理&quot;&gt;&lt;/a&gt;1. 标准库 printf 原理&lt;/h1&gt;&lt;p&gt;2.1.1 printf函数的C</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 delay实现</title>
    <link href="http://example.com/2025/12/24/stm32-delay%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2025/12/24/stm32-delay%E5%AE%9E%E7%8E%B0/</id>
    <published>2025-12-24T15:15:03.000Z</published>
    <updated>2026-02-20T13:51:20.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32-计时"><a href="#stm32-计时" class="headerlink" title="stm32 计时"></a>stm32 计时</h1><ol><li>hal_init()里面HAL_InitTick（）会设置好CM3内部的systick模块的时钟源头,为sysclk的&#x2F;8，和节拍中断优先级。</li><li>stm32 在设置好时钟树之后,sysclk &#x3D; 72MHZ</li><li>delay的初始化delay_init()，也就是设置按照当前的sysclk来说，计算得出1us要多少个时钟周期计数。或运行OS，则设置好LOAD为系统节拍（之后就不会变了）</li><li>之后就可以开始使用delay_us, delay_ms这些延时函数了</li></ol><h2 id="systick模块，sysclk时钟源-和-tick节拍"><a href="#systick模块，sysclk时钟源-和-tick节拍" class="headerlink" title="systick模块，sysclk时钟源 和 tick节拍"></a>systick模块，sysclk时钟源 和 tick节拍</h2><p><img src="/../images/12.1.png" alt="alt text"></p><p>systick是一个模块，是CM3内部的固有硬件，负责给整个系统提供一个简易的定时。</p><p><img src="/../images/12.2.png" alt="alt text"></p><p>1次节拍 &#x3D; LOAD次 计数<br>1次计数 &#x3D; 1&#x2F;（9M）s 或者 1&#x2F;（72M）s<br>       &#x3D; 1&#x2F;9  us  或者  1&#x2F;72   us</p><h2 id="delay-us"><a href="#delay-us" class="headerlink" title="delay_us"></a>delay_us</h2><h3 id="无OS"><a href="#无OS" class="headerlink" title="无OS"></a>无OS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> temp;</span><br><span class="line">SysTick-&gt;LOAD = nus * g_fac_us;</span><br><span class="line"><span class="comment">/* 时间加载 */</span></span><br><span class="line">SysTick-&gt;VAL = <span class="number">0x00</span>;</span><br><span class="line"><span class="comment">/* 清空计数器 */</span></span><br><span class="line">SysTick-&gt;CTRL |= <span class="number">1</span> &lt;&lt; <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/* 开始倒数 */</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">temp = SysTick-&gt;CTRL;</span><br><span class="line">&#125; <span class="keyword">while</span> ((temp &amp; <span class="number">0x01</span>) &amp;&amp; !(temp &amp; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>)));</span><br><span class="line"><span class="comment">/* CTRL.ENABLE 位必须为 1, 并等待时间到达 */</span></span><br><span class="line">SysTick-&gt;CTRL &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>) ;</span><br><span class="line">SysTick-&gt;VAL = <span class="number">0X00</span>;</span><br><span class="line"><span class="comment">/* 关闭 SYSTICK */</span></span><br><span class="line"><span class="comment">/* 清空计数器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接设置一个节拍的LOAD计数 &#x3D;  总共的计数（根据n us * g_per_us）</p><p>通过读systick是否完成LOAD的计数来判断</p><h3 id="有OS"><a href="#有OS" class="headerlink" title="有OS"></a>有OS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> ticks;</span><br><span class="line"><span class="type">uint32_t</span> told, tnow, tcnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> reload;</span><br><span class="line">reload = SysTick-&gt;LOAD;</span><br><span class="line"><span class="comment">/* LOAD 的值 */</span></span><br><span class="line">ticks = nus * g_fac_us;</span><br><span class="line"><span class="comment">/* 需要的节拍数 */</span></span><br><span class="line">delay_osschedlock();</span><br><span class="line"><span class="comment">/* 阻止 OS 调度，防止打断 us 延时 */</span></span><br><span class="line">told = SysTick-&gt;VAL;</span><br><span class="line"><span class="comment">/* 刚进入时的计数器值 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">tnow = SysTick-&gt;VAL;</span><br><span class="line"><span class="keyword">if</span> (tnow != told)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (tnow &lt; told)</span><br><span class="line">&#123;</span><br><span class="line">tcnt += told - tnow; <span class="comment">/* 这里注意一下 SYSTICK 是一个递减的计数器就可以了 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tcnt += reload - tnow + told;</span><br><span class="line">&#125;</span><br><span class="line">told = tnow;</span><br><span class="line"><span class="keyword">if</span> (tcnt &gt;= ticks) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* 时间超过/等于要延迟的时间,则退出. */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">delay_osschedunlock();</span><br><span class="line"><span class="comment">/* 恢复 OS 调度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过数总的计数，不能修改systick的LOAD。</p><h2 id="delay-ms"><a href="#delay-ms" class="headerlink" title="delay_ms"></a>delay_ms</h2><h3 id="无OS-1"><a href="#无OS-1" class="headerlink" title="无OS"></a>无OS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> nms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*这里用 1000,是考虑到可能有超频应用,如 128Mhz 时,delay_us 最大只能延时 1048576us 左右*/</span></span><br><span class="line"><span class="type">uint32_t</span> repeat = nms / <span class="number">1000</span>;</span><br><span class="line"><span class="type">uint32_t</span> remain = nms % <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">while</span> (repeat)</span><br><span class="line">&#123;</span><br><span class="line">delay_us(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">repeat--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (remain)</span><br><span class="line">&#123;</span><br><span class="line">delay_us(remain * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 利用 delay_us 实现 1000ms 延时 */</span></span><br><span class="line"><span class="comment">/* 利用 delay_us, 把尾数延时(remain ms)给做了 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有OS-1"><a href="#有OS-1" class="headerlink" title="有OS"></a>有OS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> nms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 如果 OS 已经在跑了,并且不是在中断里面(中断里面不能任务调度) */</span></span><br><span class="line"><span class="keyword">if</span> (delay_osrunning &amp;&amp; delay_osintnesting == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nms &gt;= g_fac_ms)</span><br><span class="line"><span class="comment">/* 延时的时间大于 OS 的最少时间周期 */</span></span><br><span class="line">&#123;</span><br><span class="line">delay_ostimedly(nms / g_fac_ms);</span><br><span class="line"><span class="comment">/* OS 延时 */</span></span><br><span class="line">&#125;</span><br><span class="line">nms %= g_fac_ms;</span><br><span class="line"><span class="comment">/* OS 已经无法提供这么小的延时了,采用普通方式延时 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 普通方式延时 */</span></span><br><span class="line">delay_us((<span class="type">uint32_t</span>)(nms * <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大于OS延时的用OS内部的延时，不足的部分，用delay_us来凑。不过此时任务无法调度，因为OS的delay_us下锁调度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stm32-计时&quot;&gt;&lt;a href=&quot;#stm32-计时&quot; class=&quot;headerlink&quot; title=&quot;stm32 计时&quot;&gt;&lt;/a&gt;stm32 计时&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;hal_init()里面HAL_InitTick（）会设置好CM3内部的syst</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 中断与事件*</title>
    <link href="http://example.com/2025/12/24/stm32-%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BA%8B%E4%BB%B6/"/>
    <id>http://example.com/2025/12/24/stm32-%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BA%8B%E4%BB%B6/</id>
    <published>2025-12-24T15:14:54.000Z</published>
    <updated>2026-02-20T13:51:20.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32中断和事件"><a href="#stm32中断和事件" class="headerlink" title="stm32中断和事件"></a>stm32中断和事件</h1><h2 id="stm32的中断资源"><a href="#stm32的中断资源" class="headerlink" title="stm32的中断资源"></a>stm32的中断资源</h2><p>NVIC 即嵌套向量中断控制器， 是内核的器件，<code>M3 内核</code>都是支持 <code>256 个中断</code>,总共包括：</p><ul><li><strong>16 个系统中断</strong></li><li><strong>240 个外部中断</strong></li></ul><p>但实际上，ZET6 的<code>系统中断</code>只用了 <code>10</code> 个，<code>外部中断有 60</code> 个</p><p><img src="/../images/11.3.png" alt="alt text"></p><blockquote><p>中断向量表在 <code>STM32F103xx.h</code> 文件中被定义</p></blockquote><h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><p>NVIC 相关的寄存器定义了可以在 <code>core_cm3.h</code> 文件中找到</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> ISER[<span class="number">8U</span>];               <span class="comment">/* 中断使能寄存器 */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED0[<span class="number">24U</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> ICER[<span class="number">8U</span>];               <span class="comment">/* 中断清除使能寄存器 */</span></span><br><span class="line">        <span class="type">uint32_t</span> RSERVED1[<span class="number">24U</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> ISPR[<span class="number">8U</span>];               <span class="comment">/* 中断使能挂起寄存器 */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED2[<span class="number">24U</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> ICPR[<span class="number">8U</span>];               <span class="comment">/* 中断解挂寄存器 */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED3[<span class="number">24U</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> IABR[<span class="number">8U</span>];               <span class="comment">/* 中断有效位寄存器 */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED4[<span class="number">56U</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  IP[<span class="number">240U</span>];               <span class="comment">/* 中断优先级寄存器（8Bit 位宽） */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED5[<span class="number">644U</span>];</span><br><span class="line">  __OM  <span class="type">uint32_t</span> STIR;                   <span class="comment">/* 软件触发中断寄存器 */</span></span><br><span class="line">&#125;  NVIC_Type;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ISER</strong></p><p>上面说了 CM3 内核总共支持 <code>256 个中断</code>，这里用 <code>8 个 32 位寄存器来控制</code>，刚好一一对应，每个位控制一个中断。但是STM32<code>F103的可屏蔽中断最多只有60个</code>，所以对我们来说，<code>有用的就是两个(ISER[0]和ISER[1])</code>，总共可以表示 64 个中断</p><p>你要<code>使能某个中断</code>，必须<code>设置相应的 ISER 位为 1</code>，使该中断被使能(这里<code>仅仅是使能</code>，还要配合中断分组、屏蔽、IO 口映射等设置才算是一个完整的中断设置)</p><p><strong>ICER</strong></p><p>和ISER相反，作用是关闭中断</p><p><strong>ISPR</strong></p><p>中断使能挂起控制寄存器组，置 1，可以<code>将正在进行的中断挂起</code>，而<strong>执行同级或更高级别的中断</strong>。写 0 是无效的</p><p><strong>ICPR</strong></p><p>置 1，可以将挂起的<strong>中断解挂</strong>。写 0 无效</p><p><strong>IABR</strong></p><p>中断激活标志位寄存器组, 为 1，则表示该位所对应的<strong>中断正在被执行</strong>。这是一个只读寄存器，通过它可以<strong>知道当前在执行的中断是哪一个</strong>。在中断执行完了由<strong>硬件自动清零</strong></p><p><strong>IP[240]</strong></p><p>中断<strong>优先级</strong>控制的寄存器组。注意，这里是240个，因此这里NVIC只能管理<strong>240个外部中断</strong></p><blockquote><p>每个外部中断，一个8bit的优先级IP，实际有效位是只用了<code>高 4 位</code>, 这4位又分为，<code>抢占优先级</code>和<code>子优先级</code>。具体两种优先级如何组合，由<code>SCB-&gt;AIRCR</code> 中的中断分组设置来决定</p></blockquote><blockquote><p>考虑到和rtos的兼容，我们一般选<strong>分组4</strong>，全部用抢占优先级</p></blockquote><p><img src="/../images/11.5.png" alt="alt text"></p><blockquote><p>总结：<br>以上，发现，NVIC寄存器组，可以设置<code>总体的优先级分组</code>，<code>外部中断的使能</code>，<code>优先级</code></p></blockquote><h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><p>EXTI 即是外部中断和事件控制器, 由 20 个产生事件&#x2F;中断请求的<strong>边沿检测器</strong>组成, 说白了，就是个边缘检测器，提供触发中断的硬件信号。</p><p><strong>说白了，就是给一些没有中断功能的功能，提供中断</strong></p><h3 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h3><p><img src="/../images/11.6.png" alt="alt text"></p><p>可以看到，有两条主线，一条是<code>由输入线到 NVIC 中断控制器</code>，一条是<code>由输入线到脉冲发生器</code>。</p><p>这就恰恰是 EXTI 的<strong>两大部分功能</strong>，</p><ul><li>产生中断</li><li>产生事件</li></ul><p>两者从硬件上就存在不同</p><h3 id="产生中断"><a href="#产生中断" class="headerlink" title="产生中断"></a>产生中断</h3><ul><li>通过配置寄存器设置为任何一个 GPIO 口，或者是一些外设的事件。输入线一般都是<strong>存在电平变化的信号</strong></li><li>经过<strong>边沿检测电路</strong>，捕获上升沿下降沿</li><li>考虑判断是否<strong>软件中断</strong></li><li>判断中断屏蔽IMR</li></ul><h3 id="产生脉冲事件"><a href="#产生脉冲事件" class="headerlink" title="产生脉冲事件"></a>产生脉冲事件</h3><ul><li>事件产生，不多细说，方法差不多，核心就是，使脉冲发生器电路产生一个脉冲</li></ul><p>一般输出到如<code>定时器</code>，<code>模拟数字转换器</code>等，这样的脉冲信号一般用来触发 TIM 或者 ADC 开始转换</p><blockquote><p><code>产生中断</code>线路目的使把输入信号输入到 NVIC，进一步运行中断服务函数，实现功能。</p><p><code>产生事件</code>线路目的是传输一个脉冲信号给其他外设使用，属于硬件级功能</p></blockquote><h3 id="EXTI支持输入"><a href="#EXTI支持输入" class="headerlink" title="EXTI支持输入"></a>EXTI支持输入</h3><p>EXTI 支持 19 个外部中断&#x2F;事件请求</p><ol><li>EXTI 线 0~15：对应外部 IO 口的输入中断</li><li>EXTI 线 16：连接到 PVD 输出</li><li>EXTI 线 17：连接到 RTC 闹钟事件</li><li>EXTI 线 18：连接到 USB 唤醒事件</li><li>EXTI 线 19：连接到以太网唤醒事件</li></ol><p>IO 口使用的中断线只有 16 个,但这个不是说，EXTI只能给16个GPIO提供中断功能</p><p>STM32，一共7个GPIO组外设（ABCDEFG），每组16个</p><p>即便这样，那么<strong>每个EXTI0-15, 还要对应7个gpio</strong> （exti0 -&gt; A0,B0….G0）,具体对应哪个gpio呢？</p><blockquote><p>GPIO 和中断线映射关系是在寄存器 <code>AFIO_EXTICR1 ~ AFIO_EXTICR4</code> 中配置的</p></blockquote><p>注意：我们配置 AFIO 相关寄存器前，还需要打开 AFIO 时钟，因为AFIO也是一个外设。</p><p>总结：我们如果需要gpio输入中断，涉及的外设有：</p><ol><li>NVIC</li><li>GPIO组</li><li>EXTI</li><li>AFIO</li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>细节很简单，就不用说了</p><p>以<code>PE4</code>作为输入中断为例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Init();                            <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">    sys_stm32_clock_init(RCC_PLL_MUL9);    <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                        <span class="comment">/* 延时初始化 */</span></span><br><span class="line">    usart_init(<span class="number">115200</span>);                    <span class="comment">/* 串口初始化为115200 */</span></span><br><span class="line">    led_init();                            <span class="comment">/* 初始化LED */</span>  <span class="comment">//PB5, PE5</span></span><br><span class="line">    beep_init();                           <span class="comment">/* 初始化蜂鸣器 */</span>  <span class="comment">//PB8</span></span><br><span class="line">    extix_init();                          <span class="comment">/* 初始化外部中断输入 */</span>  <span class="comment">//PE4,PE3,PA0</span></span><br><span class="line">    LED0(<span class="number">0</span>);                               <span class="comment">/* 先点亮红灯 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OK\r\n&quot;</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在extix_init()内部：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">extix_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef gpio_init_struct;</span><br><span class="line"></span><br><span class="line">    KEY0_GPIO_CLK_ENABLE();                                  <span class="comment">/* KEY0时钟使能 */</span></span><br><span class="line">    KEY1_GPIO_CLK_ENABLE();                                  <span class="comment">/* KEY1时钟使能 */</span></span><br><span class="line">    WKUP_GPIO_CLK_ENABLE();                                  <span class="comment">/* WKUP时钟使能 */</span></span><br><span class="line"></span><br><span class="line">    gpio_init_struct.Pin = KEY0_INT_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_IT_FALLING;            <span class="comment">/* 下升沿触发 */</span></span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLUP;</span><br><span class="line">    HAL_GPIO_Init(KEY0_INT_GPIO_PORT, &amp;gpio_init_struct);    <span class="comment">/* KEY0配置为下降沿触发中断 */</span></span><br><span class="line"></span><br><span class="line">    gpio_init_struct.Pin = KEY1_INT_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_IT_FALLING;            <span class="comment">/* 下升沿触发 */</span></span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLUP;</span><br><span class="line">    HAL_GPIO_Init(KEY1_INT_GPIO_PORT, &amp;gpio_init_struct);    <span class="comment">/* KEY1配置为下降沿触发中断 */</span></span><br><span class="line">    </span><br><span class="line">    gpio_init_struct.Pin = WKUP_INT_GPIO_PIN;</span><br><span class="line">    gpio_init_struct.Mode = GPIO_MODE_IT_RISING;             <span class="comment">/* 上升沿触发 */</span></span><br><span class="line">    gpio_init_struct.Pull = GPIO_PULLDOWN;</span><br><span class="line">    HAL_GPIO_Init(WKUP_GPIO_PORT, &amp;gpio_init_struct);        <span class="comment">/* WKUP配置为下降沿触发中断 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HAL_NVIC_SetPriority(KEY0_INT_IRQn, <span class="number">0</span>, <span class="number">2</span>);               <span class="comment">/* 抢占0，子优先级2 */</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(KEY0_INT_IRQn);                       <span class="comment">/* 使能中断线4 */</span></span><br><span class="line"></span><br><span class="line">    HAL_NVIC_SetPriority(KEY1_INT_IRQn, <span class="number">1</span>, <span class="number">2</span>);               <span class="comment">/* 抢占1，子优先级2 */</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(KEY1_INT_IRQn);                       <span class="comment">/* 使能中断线3 */</span></span><br><span class="line"></span><br><span class="line">    HAL_NVIC_SetPriority(WKUP_INT_IRQn, <span class="number">2</span>, <span class="number">2</span>);               <span class="comment">/* 抢占2，子优先级2 */</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(WKUP_INT_IRQn);                       <span class="comment">/* 使能中断线0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HAL_GPIO_Init</code>()已经帮你配置exti和afio这两个外设了，看看HAL的驱动里面的实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*--------------------- EXTI Mode Configuration ------------------------*/</span></span><br><span class="line"> <span class="comment">/* Configure the External Interrupt or event for the current IO */</span></span><br><span class="line"> <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="comment">/* Enable AFIO Clock */</span></span><br><span class="line">   __HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line">   temp = AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>];</span><br><span class="line">   CLEAR_BIT(temp, (<span class="number">0x0Fu</span>) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03u</span>)));</span><br><span class="line">   SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03u</span>)));</span><br><span class="line">   AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Configure the interrupt mask */</span></span><br><span class="line">   <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT)</span><br><span class="line">   &#123;</span><br><span class="line">     SET_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     CLEAR_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Configure the event mask */</span></span><br><span class="line">   <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT)</span><br></pre></td></tr></table></figure><p>可以看到，如果你配置了GPIO的模式是用外部中断，那么会先使能AFIO外设</p><p>另外也可以看到，extix_init()里面，最后，也设置NVIC的相应中断优先级+使能中断（这个就是NVIC仅仅能做的事）。</p><p>最终，当触发中断后，会跳转到来执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DCD     EXTI4_IRQHandler           ; EXTI Line <span class="number">4</span></span><br></pre></td></tr></table></figure><p>但是要注意，这个中断处理函数，对应的EXTI4，是对应很多个GPIO的触发可能的。所以，内部还需要判断中断源头。</p><p>一般来说，为了方便管理，我们把中断向量表里面的中断处理函数重定向到HAL中，这样同意都是在驱动层进行统一处理和管理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">KEY0_INT_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_GPIO_EXTI_IRQHandler(KEY0_INT_GPIO_PIN);         <span class="comment">/* 调用中断处理公用函数 清除KEY0所在中断线 的中断标志位 */</span></span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(KEY0_INT_GPIO_PIN);         <span class="comment">/* HAL库默认先清中断再处理回调，退出时再清一次中断，避免按键抖动误触发 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00u</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Prevent unused argument(s) compilation warning */</span></span><br><span class="line">  UNUSED(GPIO_Pin);</span><br><span class="line">  <span class="comment">/* <span class="doctag">NOTE:</span> This function Should not be modified, when the callback is needed,</span></span><br><span class="line"><span class="comment">           the HAL_GPIO_EXTI_Callback could be implemented in the user file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，HAL里面，仅仅只是对中断标志位清除一下，或者判断一些信息。然后调用回调函数。而回调函数，是一个弱定义，所以你可以自己在业务层去编写自己的回调函数。</p><p>exti.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       中断服务程序中需要做的事情</span></span><br><span class="line"><span class="comment">                在HAL库中所有的外部中断服务函数都会调用此函数</span></span><br><span class="line"><span class="comment"> * @param       GPIO_Pin:中断引脚号</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    delay_ms(<span class="number">20</span>);      <span class="comment">/* 消抖 */</span></span><br><span class="line">    <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> KEY0_INT_GPIO_PIN:</span><br><span class="line">            <span class="keyword">if</span> (KEY0 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LED0_TOGGLE();  <span class="comment">/* LED0 状态取反 */</span> </span><br><span class="line">                LED1_TOGGLE();  <span class="comment">/* LED1 状态取反 */</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KEY1_INT_GPIO_PIN:</span><br><span class="line">            <span class="keyword">if</span> (KEY1 == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LED0_TOGGLE();  <span class="comment">/* LED0 状态取反 */</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WKUP_INT_GPIO_PIN:</span><br><span class="line">            <span class="keyword">if</span> (WK_UP == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                BEEP_TOGGLE();  <span class="comment">/* 蜂鸣器状态取反 */</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>旧</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中断和事件是两个东西</p><p>中断是指的，cpu的中断控制器在收到中断请求后，停止当前任务，转去处理中断事件，运行中断处理函数，根据IVT中定义的函数策略，都是WEAK定义，你可以自己覆写。</p><p>事件则指的，外部的输入信号，不输入NVIC， 直接到脉冲产生模块，从而产生一个脉冲事件，这个脉冲信号会发给你想要发给的设备。</p><p><img src="/../images/11.1.png" alt="alt text"></p><p><img src="/../images/11.2.png" alt="alt text"></p><h2 id="中断产生流程"><a href="#中断产生流程" class="headerlink" title="中断产生流程"></a>中断产生流程</h2><ol><li>外设输入端gpio产生信号（比如下降沿，上升沿）</li><li>EXTI起到路由的作用，<ol><li>既可以产生软件中断（内部设置软件中断寄存器把或门置1），</li><li>也可以产生硬件中断（判定上升沿触发，边沿检测输出1,自动把请求挂起寄存器置1,之后只要把中断屏蔽寄存器置1开中断即可让NVIC产生中断，NVIC会通知CM3内核去按照IVT执行相应的中断处理函数）</li><li>产生事件（脉冲信号，直接发给其他的设备）</li></ol></li><li>NVIC接收到中断请求，开始通知CM3产生中断</li><li>CM3保存当前堆栈，然后跳转到IVT指定的中断处理函数。</li><li>EXTI4_IRQHandler中断处理函数内，清除挂起位，表面CM3已经知道并且正在处理此中断，并调用对应的回调函数来处理中断。处理完之后，再次清中断，防止多次处理。</li><li>CM3恢复现场</li></ol><h2 id="NVIC-1"><a href="#NVIC-1" class="headerlink" title="NVIC"></a>NVIC</h2><p>CM3内核内部的模块，具体定义在ARM中。<br>帮助设置所有中断的优先级组，同时设置一个中断的抢占式优先级和子优先级。</p><h2 id="EXTI-1"><a href="#EXTI-1" class="headerlink" title="EXTI"></a>EXTI</h2><p>可以看成是一个输入信号的路由模块，把我们输入的输入信号，帮助NVIC判断是什么方式触发，是想要软件触发还是外部硬件触发，是想要触发中断还是触发事件。</p><h2 id="实现流程思路"><a href="#实现流程思路" class="headerlink" title="实现流程思路"></a>实现流程思路</h2><p>总共设置4个部分<br>输入gpio –&gt; EXTI –&gt; NVIC –&gt; 输出GPIO</p><p>NVIC部分：</p><ol><li>设置优先级组</li><li>设置抢占式优先级和子优先级</li><li>使能NVIC</li><li>找到IVT对应的想要的中断处理函数入口名称</li></ol><p>EXTI：</p><ol><li>设置下降沿触发</li><li>关闭软件中断（可有可无）</li><li>开中断（IMR）</li></ol><p>GPIO输入：</p><ol><li>设置gpio相关</li><li>与EXTI绑定</li></ol><p>（hal_gpio库中，已经将输入GPIO和EXTI合并，可以直接像设置gpio一样选择AFIO复用EXTI输入）</p><p>GPIO输出：</p><ol><li>重写回调函数，gpio中断的回调函数，hal库中已经写好了weak定义。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stm32中断和事件&quot;&gt;&lt;a href=&quot;#stm32中断和事件&quot; class=&quot;headerlink&quot; title=&quot;stm32中断和事件&quot;&gt;&lt;/a&gt;stm32中断和事件&lt;/h1&gt;&lt;h2 id=&quot;stm32的中断资源&quot;&gt;&lt;a href=&quot;#stm32的中断资源&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 时钟*</title>
    <link href="http://example.com/2025/12/24/stm32-%E6%97%B6%E9%92%9F/"/>
    <id>http://example.com/2025/12/24/stm32-%E6%97%B6%E9%92%9F/</id>
    <published>2025-12-24T15:14:45.000Z</published>
    <updated>2026-02-20T13:51:20.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stm32-时钟系统"><a href="#stm32-时钟系统" class="headerlink" title="stm32 时钟系统"></a>stm32 时钟系统</h1><p>首先肯定得有时钟系统，stm32f103的时钟系统比较复杂，不像简单的51，就一个系统时钟解决一切。</p><p>stm32主频可到<code>72Mhz</code>，但是不是所有的外设都需要这么高的时钟。有些如看门狗以及 RTC 只需要<code>几十 kHZ</code> 的时钟即可</p><p>同一个电路，<code>时钟越快功耗越大</code>，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般<br>都是采取<code>多时钟源</code>的方法来解决这些问题</p><p>所以必须得搞清楚：<code>时钟源有哪些</code>，<code>时钟树的线路匹配</code>（时钟信号的传递）</p><p>外设非常的多，为了<code>保持低功耗工作</code>，STM32 的主控<code>默认不开启这些外设功能</code>。这个<code>功能开关</code>在 STM32主控中也就是<code>各个外设的时钟</code>。</p><blockquote><p>所以<code>时钟</code>就是<code>外设的开关</code></p></blockquote><h2 id="4个时钟源"><a href="#4个时钟源" class="headerlink" title="4个时钟源"></a>4个时钟源</h2><p>STM32F1，<code>输入时钟源</code>（Input Clock）主要包括 <code>HSI</code>(内部高速)，<code>HSE</code>（外部高速），<code>LSI</code>（内部低速），<code>LSE</code>（外部低速）</p><p><code>外部时钟源</code>就是从<code>外部</code>通过<strong>接晶振</strong>的方式获取时钟源，其中 HSE 和 LSE 是外部时钟源</p><p><code>内部时钟源</code>，芯片<strong>上电即可产生</strong>，不需要借助外部电路</p><p>下面详细说一下这4个时钟源：</p><ol><li><p>HSE（外部高速）</p><ol><li>外接<code>石英</code>、陶瓷瓷谐振器，频率为 4MHz~16MHz。本开发板使用的是 <code>8MHz</code></li></ol></li><li><p>LSE (外部低速)</p><ol><li>外接 <code>32.768kHz</code> 石英晶体，主要作用于 RTC 的时钟源<blockquote><p>可见，外部时钟，全部都是石英</p></blockquote></li></ol></li><li><p>HSI（内部高速）</p><ol><li><code>内部 RC </code>振荡器产生，频率为 <code>8MHz</code></li></ol></li><li><p>LSI(内部低速)</p><ol><li><code>内部 RC</code> 振荡器产生，频率为 <code>40kHz</code>，可作为<code>独立看门狗</code>的时钟源</li></ol></li></ol><blockquote><p>芯片<strong>上电</strong>时默认由<strong>内部的 HSI 时钟启动</strong> (8Mhz)，如果用户进行了硬件和软件的配置，芯片才会根据<code>用户配置</code>调试尝试<code>切换到对应的外部时钟源</code></p></blockquote><h2 id="锁相环pll"><a href="#锁相环pll" class="headerlink" title="锁相环pll"></a>锁相环pll</h2><p>作用：<strong>输入时钟净化</strong>和<strong>倍频</strong></p><p><img src="/../images/23.2.png" alt="alt text"></p><p>所以，要实现 <code>72MHz</code> 的<code>主频率</code> <code>SYSCLK</code>，因为默认高速时钟是8Mhz, 所以pll倍频系数要为9</p><h2 id="系统时钟-sysclk"><a href="#系统时钟-sysclk" class="headerlink" title="系统时钟 sysclk"></a>系统时钟 sysclk</h2><p>以上，介绍了时钟源，倍频pll，接下来就得到了我们的<strong>系统时钟sysclk</strong></p><p><strong>系统时钟 SYSCLK 为整个芯片提供了时序信号</strong></p><p><img src="/../images/23.3.png" alt="alt text"></p><p>系统时钟为以下提供时钟信号：</p><ol><li>外设总线时钟</li><li>内核时钟</li><li>等等，均由sysclk分频得到。</li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>该实验，就是让stm32工作在系统时钟sysclk &#x3D; 72Mhz下。</p><p>之前讲到，内核上电后开始执行reset_handler, 里面有两个环节:</p><ol><li>SystemInit<ol><li>配置外部sram（没用到）</li><li>重定向ivt到内部ram（没用到）</li></ol></li><li>main</li></ol><p>所以我们主要看main干了些什么</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> key;</span><br><span class="line"></span><br><span class="line">    HAL_Init();                             <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">    sys_stm32_clock_init(RCC_PLL_MUL9);     <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">    delay_init(<span class="number">72</span>);                         <span class="comment">/* 延时初始化 */</span></span><br><span class="line">    <span class="comment">//......</span></span><br></pre></td></tr></table></figure><p>可以看到就直接在CM3用内部8M时钟的情况下，就直接跳转到main执行了。</p><p>所以我们是在main里面重新设置时钟，配置主频为72Mhz的。</p><p>先看一下<code>sys_stm32_clock_init</code>这个函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       系统时钟初始化函数</span></span><br><span class="line"><span class="comment"> * @param       plln: PLL倍频系数(PLL倍频), 取值范围: 2~16</span></span><br><span class="line"><span class="comment">                中断向量表位置在启动时已经在SystemInit()中初始化</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_stm32_clock_init</span><span class="params">(<span class="type">uint32_t</span> plln)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_StatusTypeDef ret = HAL_ERROR;</span><br><span class="line">    RCC_OscInitTypeDef rcc_osc_init = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    RCC_ClkInitTypeDef rcc_clk_init = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    rcc_osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;       <span class="comment">/* 选择要配置HSE */</span></span><br><span class="line">    rcc_osc_init.HSEState = RCC_HSE_ON;                         <span class="comment">/* 打开HSE */</span></span><br><span class="line">    rcc_osc_init.HSEPredivValue = RCC_HSE_PREDIV_DIV1;          <span class="comment">/* HSE预分频系数 */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLState = RCC_PLL_ON;                     <span class="comment">/* 打开PLL */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;             <span class="comment">/* PLL时钟源选择HSE */</span></span><br><span class="line">    rcc_osc_init.PLL.PLLMUL = plln;                             <span class="comment">/* PLL倍频系数 */</span></span><br><span class="line">    ret = HAL_RCC_OscConfig(&amp;rcc_osc_init);                     <span class="comment">/* 初始化 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);                                              <span class="comment">/* 时钟初始化失败，之后的程序将可能无法正常执行，可以在这里加入自己的处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 选中PLL作为系统时钟源并且配置HCLK,PCLK1和PCLK2*/</span></span><br><span class="line">    rcc_clk_init.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);</span><br><span class="line">    rcc_clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;        <span class="comment">/* 设置系统时钟来自PLL */</span></span><br><span class="line">    rcc_clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;               <span class="comment">/* AHB分频系数为1 */</span></span><br><span class="line">    rcc_clk_init.APB1CLKDivider = RCC_HCLK_DIV2;                <span class="comment">/* APB1分频系数为2 */</span></span><br><span class="line">    rcc_clk_init.APB2CLKDivider = RCC_HCLK_DIV1;                <span class="comment">/* APB2分频系数为1 */</span></span><br><span class="line">    ret = HAL_RCC_ClockConfig(&amp;rcc_clk_init, FLASH_LATENCY_2);  <span class="comment">/* 同时设置FLASH延时周期为2WS，也就是3个CPU周期。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);                                              <span class="comment">/* 时钟初始化失败，之后的程序将可能无法正常执行，可以在这里加入自己的处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>干了两件事：</p><ol><li>配置 <code>PLL = 9倍频</code> 相关参数确定系统时钟<code>SYSCLK = 72Mhz</code></li><li>配置了 <code>AHB</code>、<code>APB1</code> 和 <code>APB2</code> 的分频系数，也就是确定了 HCLK，PCLK1和 PCLK2 的时钟值</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCLK(系统时钟) =<span class="number">72</span>MHz</span><br><span class="line">PLL 主时钟 =<span class="number">72</span>MHz</span><br><span class="line">AHB 总线时钟（HCLK=SYSCLK/<span class="number">1</span>） =<span class="number">72</span>MHz</span><br><span class="line">APB1 总线时钟（PCLK1=HCLK/<span class="number">2</span>） =<span class="number">36</span>MHz</span><br><span class="line">APB2 总线时钟（PCLK2=HCLK/<span class="number">1</span>） =<span class="number">72</span>MHz</span><br></pre></td></tr></table></figure><p>如果要打开某个外设：</p><p>上一节我们讲解了时钟系统配置步骤。在<code>配置好时钟系统之后</code>，如果我们要<code>使用某些外设</code>，例如 GPIO，ADC 等，我们还要<code>使能这些外设时钟</code>。</p><p>这里大家必须注意，如果在使用外设之前没有使能外设时钟，这个外设是不可能正常运行的。</p><blockquote><p>STM32 的外设时钟使能是在 <code>RCC 相关寄存器中配置</code>的</p></blockquote><p><strong>HAL 库中</strong>，外设时钟使能操作都是在 RCC 相关固件库文件头文件<code>STM32F1xx_hal_rcc.h</code> 定义的. 每个<strong>外设的时钟使能</strong>，都通过<strong>宏</strong>来实现</p><p><img src="/../images/23.4.png" alt="alt text"></p><blockquote><p>我们只需要在我们的用户程序中<strong>调用宏定义标识符</strong>就可以实现 GPIOA 时钟使能。</p><p>禁止外设时钟使用方法和使能外设时钟非常类似</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;stm32-时钟系统&quot;&gt;&lt;a href=&quot;#stm32-时钟系统&quot; class=&quot;headerlink&quot; title=&quot;stm32 时钟系统&quot;&gt;&lt;/a&gt;stm32 时钟系统&lt;/h1&gt;&lt;p&gt;首先肯定得有时钟系统，stm32f103的时钟系统比较复杂，不像简单的51，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 启动流程*</title>
    <link href="http://example.com/2025/12/24/stm32-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2025/12/24/stm32-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-12-24T15:14:40.000Z</published>
    <updated>2026-02-20T13:51:20.752Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#stm32f1-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90">STM32f1 启动流程分析</a><ul><li><a href="#1-stm32f1xx-%E8%8A%AF%E7%89%87%E6%9E%B6%E6%9E%84">1. STM32F1xx 芯片架构</a></li><li><a href="#2-%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">2. 编译文件类型</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F">启动模式</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6startups">启动文件startup.s</a></li><li><a href="#%E4%B8%8A%E7%94%B5%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">上电启动流程</a></li><li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%BF%90%E8%A1%8C%E5%9F%9F%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%9F%9F">程序的结构，运行域和加载域</a></li></ul></li></ul><h1 id="STM32f1-启动流程分析"><a href="#STM32f1-启动流程分析" class="headerlink" title="STM32f1 启动流程分析"></a>STM32f1 启动流程分析</h1><h2 id="1-STM32F1xx-芯片架构"><a href="#1-STM32F1xx-芯片架构" class="headerlink" title="1. STM32F1xx 芯片架构"></a>1. STM32F1xx 芯片架构</h2><p><img src="/../images/9.1.png" alt="alt text"><br>关于启动流程，我们只需要关注</p><ol><li>CM3内核</li><li>内核通用寄存器R0-R15（尤其是SP寄存器和PC寄存器）（均为32位 4byte寄存器）</li><li>RAM（SRAM）</li><li>ROM（FLASH）<br><img src="/../images/9.2.png" alt="alt text"></li></ol><h2 id="2-编译文件类型"><a href="#2-编译文件类型" class="headerlink" title="2. 编译文件类型"></a>2. 编译文件类型</h2><p><img src="/../images/9.3.png" alt="alt text"><br>我们主要关注以下几种编译类型：</p><ol><li>.o （由编译器编译.c&#x2F;.s文件产生的可重定向文件）</li><li>.axf (由armlink链接器，将整个工程参与编译的.o链接成一个可执行文件，是不可重定向的，然后通过仿真器下载调试)</li><li>.hex （由axf转换而来的一个可执行对象文件，除了可执行代码，还有地址信息，知道烧写的地址）</li><li>.bin 正常gcc链接起来的可执行代码</li><li>.map文件（表示函数调用关系，地址关系等。方便调试）</li></ol><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p>当内核上电后，CM3第一件事就是：</p><ol><li>读取0x0的4字节地址作为MSP（存放栈顶指针）</li><li>读取0x4的4字节地址作为PC</li></ol><p>事实上，这里的地址0x0, 0x04，可以被重映射到其他的地址空间，这种<strong>重映射</strong>，就是<strong>启动模式的选择</strong></p><p><img src="/../images/22.1.png" alt="alt text"></p><p>实际的选择，可以通过<code>BOOT 引脚</code>根据<code>外部施加的电平</code>来决定芯片的<code>启动地址</code></p><blockquote><p>我们正常选择的就是第一种，内部flash启动，即把<code>0x0 -&gt; 0x08000000</code>, <code>0x04 -&gt; 0x08000004</code></p></blockquote><p>至于这个启动地址，存放的是什么指令，什么内容，这由<code>启动文件 starttup_stm32f103xe.s</code> 决定了存储什么内容</p><p>链接时，由分散加载文件(sct)决定这些内容的绝对地址，即分配到内部 FLASH 还是内部 SRAM。</p><h2 id="启动文件startup-s"><a href="#启动文件startup-s" class="headerlink" title="启动文件startup.s"></a>启动文件startup.s</h2><p>startup.S, 是上电后执行的第一个程序</p><p>主要工作如下：</p><ol><li>初始化栈指针 SP &#x3D; _initial_sp</li><li>初始化程序计数器指针 PC &#x3D; Reset_Handler</li><li>设置 堆 和 栈 的大小</li><li>初始化中断向量表(填写IVT)</li><li>配置外部 SRAM 作为数据存储器（可选）</li><li>配置系统时钟，通过调用 SystemInit 函数（可选）</li><li>调用 C 库中的 _main 函数初始化用户堆栈，最终调用 main 函数</li></ol><h2 id="上电启动流程"><a href="#上电启动流程" class="headerlink" title="上电启动流程"></a>上电启动流程</h2><ol><li><strong>上电</strong>，CM3启动，（SP，PC未初始化）</li><li>（<strong>初始化SP</strong>）CM3硬件机制读取0x0800 0000开始的32位&#x3D;4字节（0x da da da da）写入SP</li><li>（<strong>初始化PC</strong>）CM3硬件机制读取0x0800 0004开始的32位&#x3D;4byte （0x da da da da）写入PC</li><li>（CM3 联合SP， PC， 按照正常的<strong>取指令，译指令，执行指令</strong>。）<ol><li>（取指令）CM3按照PC只是的下一条指令的地址，用总线在flash中取出指令（0x da da da da）</li><li>（译指令）CM3翻译这4byte的指令为自己的ARM&#x2F;THUMB指令 按照地址最后是否是0&#x2F;1来区分arm&#x2F;thumb指令集</li><li>（执行指令）执行指令，完毕后更新PC指向下一条指令（+2&#x2F;+4）。</li></ol></li><li>CM3跳转<strong>RESET_HANDLER</strong>, 执行初始化<ol><li>CM3执行初始化内部的SystemInit函数，<strong>初始化时钟</strong>，执行完毕跳转回来。（函数名即函数段的入口地址）</li><li>CM3执行__main，<strong>初始化用户堆栈</strong>（因为我们没有用microlib，所以是标准的编译器，所以需要告知c语言的堆栈的起始地址和大小）和C语言环境，完成后不再回来，进入C的世界。</li></ol></li></ol><p>startup.S开头程序示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Stack_Size      EQU     <span class="number">0x00000400</span></span><br><span class="line"></span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=<span class="number">3</span></span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line">                                                  </span><br><span class="line">; &lt;h&gt; Heap Configuration</span><br><span class="line">;   &lt;o&gt;  Heap <span class="title function_">Size</span> <span class="params">(in Bytes)</span> &lt;0x0-0xFFFFFFFF:8&gt;</span><br><span class="line">; &lt;/h&gt;</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     <span class="number">0x00000200</span></span><br><span class="line"></span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=<span class="number">3</span></span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br><span class="line"></span><br><span class="line">                PRESERVE8</span><br><span class="line">                THUMB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address <span class="number">0</span> at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line"></span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br></pre></td></tr></table></figure><p>开头的分配，栈，堆，只是分配了内存空间大小，和指明指针的相对位置。并没有说明绝对物理地址是哪里。</p><p>当你编译工程时，链接器会读取一个配置文件（在 Keil 中通常是 <code>Project_Name.sct</code>）。这个文件描述了芯片的内存布局。(这个是真正的编译工具链里面的链接脚本，类似lds)</p><blockquote><p>在startup.S中分配栈大小和指明栈指针的相对位置，然后在编译过程中的<code>链接脚本</code>中，指定实际这些地址的位置</p></blockquote><blockquote><p>栈空间的大小，CM3自己也意识不到，仅仅只是程序这么分配在map中。</p></blockquote><blockquote><p>栈从高往低生长，堆从低到高生长</p></blockquote><h2 id="程序的结构，运行域和加载域"><a href="#程序的结构，运行域和加载域" class="headerlink" title="程序的结构，运行域和加载域"></a>程序的结构，运行域和加载域</h2><p>map 文件是你的程序的镜像内存分布图：</p><p>正常程序编译好后，放置在加载域（存储的地方，ROM）里面</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常程序在加载域中的结构</span></span><br><span class="line"></span><br><span class="line">.bss      <span class="comment">//RW   （RAM）（初值为0）</span></span><br><span class="line">.data     <span class="comment">//RW   (初值在ROM，读写在RAM)（有初值，且不为 0）</span></span><br><span class="line">.rodata   <span class="comment">//RO   (ROM)</span></span><br><span class="line">.text     <span class="comment">//RO   (ROM)</span></span><br></pre></td></tr></table></figure><blockquote><p>Section：描述映像文件的代码或数据块，我们简称程序段</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#stm32f1-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90&quot;&gt;STM32f1 启动流程分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-stm32f1xx-%E8%8A%A</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 看门狗</title>
    <link href="http://example.com/2025/12/24/stm32-%E7%9C%8B%E9%97%A8%E7%8B%97/"/>
    <id>http://example.com/2025/12/24/stm32-%E7%9C%8B%E9%97%A8%E7%8B%97/</id>
    <published>2025-12-24T15:14:32.000Z</published>
    <updated>2026-02-20T13:51:20.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32-看门狗"><a href="#STM32-看门狗" class="headerlink" title="STM32 看门狗"></a>STM32 看门狗</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>WD， 说白了就是一个递减的计数器</p><p>IWDG， 独立看门狗，倒计时结束就会触发复位重启<br>WWDG， 窗口看门狗，有一个窗口值， 高于窗口上限feed，会导致复位；到0x3f也会导致复位，只有在窗口间feed才能成功恢复看门狗计数。</p><h2 id="WWDG"><a href="#WWDG" class="headerlink" title="WWDG"></a>WWDG</h2><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>WWDG属于APB1总线的设备，所以是36M的时钟</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ol><li>WWDG_CR<ol><li>WDGA位 （启用，使能WWDG）</li><li>T[6:0]位 当前计数器</li></ol></li><li>WWDG_CFR<ol><li>EWI位 (0x40时提前唤醒中断使能)</li><li>TB[1:0] (分频系数)</li><li>W[6:0] （窗口上限）</li></ol></li><li>WWDG_SR  （记录是否有提前唤醒，0x40时 SR&#x3D;1）</li></ol><p>(注意：你既然使用中断，就要记得使能NVIC来响应中断)</p><h3 id="为什么Tr设置大于Wr"><a href="#为什么Tr设置大于Wr" class="headerlink" title="为什么Tr设置大于Wr"></a>为什么Tr设置大于Wr</h3><p>为什么 “Tr&gt; Wr” 是合理的？<br>以你的配置为例：Tr&#x3D;0x7F（127），Wr&#x3D;0x5F（95），计数器的工作过程如下：</p><pre><code>初始化后，计数器从 0x7F（127）开始向下计数：    127 → 126 → ... → 96（这些值都 &gt; Wr=95）。    此时如果喂狗（重装载 Tr），会因为 “计数器值&gt; Wr” 触发复位（这是窗口机制的保护作用，防止过早喂狗）。    但不喂狗的话，计数器会继续正常递减，不会复位（复位只在计数器到 0x3F 时发生）。当计数器减到 95（= Wr）及以下（95 → 94 → ... → 65（0x41））：    此时进入 “允许喂狗区间”（计数器值 ≤ Wr 且 &gt; 0x40），喂狗操作会被正常执行（计数器重新装载为 Tr=127，重复上述过程）。若一直不喂狗，计数器会继续减到 64（0x40）时触发 EWI 中断（如果使能），再减到 63（0x3F）时触发复位。</code></pre><p>一开始设置的Tr是一个重装载的值，你feed dog的时间要在W和0x40之间，feed成功后，Tr有可以重装载进去</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32-看门狗&quot;&gt;&lt;a href=&quot;#STM32-看门狗&quot; class=&quot;headerlink&quot; title=&quot;STM32 看门狗&quot;&gt;&lt;/a&gt;STM32 看门狗&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
  <entry>
    <title>stm32 定时器*</title>
    <link href="http://example.com/2025/12/24/stm32-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://example.com/2025/12/24/stm32-%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2025-12-24T15:14:25.000Z</published>
    <updated>2026-02-20T13:51:20.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32-定时器"><a href="#STM32-定时器" class="headerlink" title="STM32 定时器"></a>STM32 定时器</h1><h2 id="定时器硬件总线挂载情况"><a href="#定时器硬件总线挂载情况" class="headerlink" title="定时器硬件总线挂载情况"></a>定时器硬件总线挂载情况</h2><ul><li>APB1：TIM2-7</li><li>APB2：TIM1, TIM8</li></ul><h2 id="定时器资源"><a href="#定时器资源" class="headerlink" title="定时器资源"></a>定时器资源</h2><ol><li>2个<strong>基本</strong>定时器（TIM6, TIM7）</li><li>4个<strong>通用</strong>定时器（TIM2-5）</li><li>2个<strong>高级</strong>控制定时器（TIM1, TIM8）</li></ol><p>这些定时器彼此独立。</p><h2 id="基本定时器（6，7）"><a href="#基本定时器（6，7）" class="headerlink" title="基本定时器（6，7）"></a>基本定时器（6，7）</h2><p><strong>特点</strong>：</p><ol><li><code>16位自动重载**递增**计数器</code></li><li><code>16位可编程分频器</code>(倍频</li></ol><h3 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h3><p><img src="/../images/8.10.png" alt="alt text"></p><h3 id="硬件部分"><a href="#硬件部分" class="headerlink" title="硬件部分"></a>硬件部分</h3><h4 id="1-时钟源"><a href="#1-时钟源" class="headerlink" title="1. 时钟源"></a>1. 时钟源</h4><p>很明显，定时器，都需要时钟源</p><p>基本定时器时钟挂载在 <code>APB1 总线</code>，所以它的时钟来自于 APB1 总线.</p><p>但是基本定时器不是直接用的APB1总线的时钟，而是先经过一个<strong>倍频器</strong>，然后得到输入时钟。</p><blockquote><p><code>sys_stm32_clock_init</code> 时钟设置函数已经设置 <code>APB1 总线</code>时钟频率为 <code>36M</code>，APB1 总线的预分频器<code>分频系数是 2</code>，所以挂载在 APB1 总线的定时器时钟频率为 <code>72Mhz</code><br><img src="/../images/8.11.png" alt="alt text"></p></blockquote><h4 id="2-控制器"><a href="#2-控制器" class="headerlink" title="2. 控制器"></a>2. 控制器</h4><p>控制器除了控制定时器复位、使能、计数等功能之外，还可以用于触发 DAC 转换。</p><h4 id="3-时基单元"><a href="#3-时基单元" class="headerlink" title="3. 时基单元"></a>3. 时基单元</h4><p>时基单元包括：计数器寄存器(TIMx_<code>CNT</code>)、预<code>分频</code>器寄存器(TIMx_PSC)、<code>自动重载</code>寄存器<br>(TIMx_ARR) 。</p><p>这三个寄存器都是 <code>16 位</code>有效数字，即可设置值范围是 0~65535</p><blockquote><p>这里感觉就跟普通的systick定时器差不多了。</p></blockquote><p>从上面的框图，可以看到，<strong>预分频器 PSC</strong>，它有一个输入和一个输出。<strong>输入 CK_PSC</strong> 来源于控制器部分，<br>实际上就是来自于内部时钟（<code>CK_INT</code>），即 2 倍的 APB1 总线时钟频率（<code>72MHz</code>）。<strong>输出 CK_CNT</strong><br>是分频后的时钟，它是计数器<strong>实际的计数时钟</strong></p><p>所以通过分频器除一下，就可以得到，给<strong>时基单元计数用的时钟周期</strong>了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fCK_CNT= fCK_PSC / (PSC[<span class="number">15</span>:<span class="number">0</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>影子寄存器</strong></p><p>可以看到，预分频模块和自动重载模块有影子</p><p>实际上，预分频器寄存器只是起到<strong>缓存数据的作用</strong>，只有等到<strong>更新事件发生时</strong>，预分频器寄存器的<br>值才会被自动写入其影子寄存器中，这时才真正起作用。</p></blockquote><h3 id="更新事件"><a href="#更新事件" class="headerlink" title="更新事件"></a>更新事件</h3><p>更新事件，更新事件的产生有两种情况：</p><ol><li>由<strong>软件产生</strong>，将 TIMx_EGR 寄存器的位UG 置 1，产生更新事件后，硬件会自动将 UG 位清零</li><li>由硬件产生：<ol><li><code>计数器的值</code>（递增）等于<code>自动重装载寄存器影子寄存器</code>的值，TIMx_CNT 值与 TIMx_ARR 的设定值相等时，TIMx_CNT 的值就会被<code>自动清零</code>并且会<code>生成更新事件</code></li></ol></li></ol><p>说白了，更新事件，就是硬件计数到预定数字了，或者软件主动触发. </p><p>而这个<strong>更新事件</strong>，就是<strong>完成了一轮计数</strong>，可以此时就可以<strong>开启相应功能</strong>：</p><ol><li>产生 DMA 请求</li><li>产生中断信号</li><li>触发 DAC 同步电路</li></ol><blockquote><p>这也就是我们为什么要用定时器的理由，因为我们肯定时需要实现某些定时的功能的。计数到装载值，只是知道，现在到时间了，更新事件的触发效果，才是我们做想要的功能的开始</p></blockquote><blockquote><p>TIMx_CNT <code>等于</code>TIMx_ARR 时，我们称之为<code>定时器溢出</code>，因为是<code>递增计数</code>，故而又称为<code>定时器上溢</code>。定时器溢出就<code>伴随着更新事件的发生</code></p></blockquote><p>所以，只要设置<code>预分频寄存器</code>和<code>自动重载</code>寄存器的值就可以<strong>控制定时器更新事件发生的时间</strong>. 当计数器的<br>值等于自动重载寄存器的值时就会生成更新事件，<strong>硬件自动置位</strong>相关<strong>更新事件</strong>的<strong>标志位</strong>，</p><ul><li>如：更新中断标志位.</li></ul><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>我们在之前，设置主频72Mhz,然后，让systick定时器，1ms一次中断（裸机关中断），计算得到<code>systick定时器经过1us所需的计数</code>。延时靠数tick。</p><p>现在，我们新增一个基本定时器，延时500ms, 主频72Mhz给到分频器（<code>CK_INT 为 72MHz</code>）</p><ol><li><code>预分频</code>系数设置为 <code>7200</code>，即写入预分频寄存器的值为 7199，那么 <code>fCK_CNT</code>&#x3D;72MHz&#x2F;7200&#x3D;<code>10KHz</code>。</li><li>所以，计数+1 &#x3D; 0.1ms</li><li>需要 <code>500ms 的中断周期</code>，所以我们让计数器<code>计数 5000 个</code>数就能满足要求，即需要设置自动重载寄存器的值为4999</li><li>更新中断使能位 UIE 置 1，CEN 位也要置 1, <strong>开中断</strong>，让更新事件能够做事</li></ol><h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><h4 id="CR"><a href="#CR" class="headerlink" title="CR"></a>CR</h4><p><img src="/../images/8.12.png" alt="alt text"><br><img src="/../images/8.13.png" alt="alt text"><br><img src="/../images/8.14.png" alt="alt text"><br><img src="/../images/8.15.png" alt="alt text"></p><h4 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h4><p><img src="/../images/8.16.png" alt="alt text"></p><h4 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h4><p><img src="/../images/8.17.png" alt="alt text"></p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>上面已经详细梳理过，基本定时器的使用了，现在想要一个定时器中断，就比较简单了，涉及的外设</p><ol><li>TIM6</li><li>NVIC</li></ol><p>如果要中断中控制点灯：</p><ol start="3"><li>GPIO</li></ol><p>实验要求：定时器控制LED1 – PE5定时翻转</p><p><code>main</code>()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_Init();                             <span class="comment">/* 初始化HAL库 */</span></span><br><span class="line">sys_stm32_clock_init(RCC_PLL_MUL9);     <span class="comment">/* 设置时钟, 72Mhz */</span></span><br><span class="line">delay_init(<span class="number">72</span>);                         <span class="comment">/* 延时初始化 */</span></span><br><span class="line">usart_init(<span class="number">115200</span>);                     <span class="comment">/* 串口初始化为115200 */</span></span><br><span class="line">led_init();                             <span class="comment">/* 初始化LED */</span></span><br><span class="line"></span><br><span class="line">btim_timx_int_init(<span class="number">5000</span> - <span class="number">1</span>, <span class="number">7200</span> - <span class="number">1</span>); <span class="comment">/* 10Khz的计数频率，计数5K次为500ms */</span></span><br></pre></td></tr></table></figure><p>再来看看btim的bsp是如何实现的， 两块，一块是TIM6的配置，一块是NVIC的配置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">btim_timx_int_init</span><span class="params">(<span class="type">uint16_t</span> arr, <span class="type">uint16_t</span> psc)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_timx_handle.Instance = BTIM_TIMX_INT;                      <span class="comment">/* 通用定时器X */</span></span><br><span class="line">    g_timx_handle.Init.Prescaler = psc;                          <span class="comment">/* 设置预分频系数 */</span></span><br><span class="line">    g_timx_handle.Init.CounterMode = TIM_COUNTERMODE_UP;         <span class="comment">/* 递增计数模式 */</span></span><br><span class="line">    g_timx_handle.Init.Period = arr;                             <span class="comment">/* 自动装载值 */</span></span><br><span class="line">    HAL_TIM_Base_Init(&amp;g_timx_handle);</span><br><span class="line"></span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;g_timx_handle);    <span class="comment">/* 使能定时器x及其更新中断 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HAL_TIM_Base_Init</code>里面，先做一些前置配置：<code>HAL_TIM_Base_MspInit</code>，然后配置时基</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_TIM_Base_Init</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check the TIM handle allocation */</span></span><br><span class="line">  <span class="keyword">if</span> (htim == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> HAL_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_TIM_INSTANCE(htim-&gt;Instance));</span><br><span class="line">  assert_param(IS_TIM_COUNTER_MODE(htim-&gt;Init.CounterMode));</span><br><span class="line">  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim-&gt;Init.ClockDivision));</span><br><span class="line">  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim-&gt;Init.AutoReloadPreload));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;State == HAL_TIM_STATE_RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Allocate lock resource and initialize it */</span></span><br><span class="line">    htim-&gt;Lock = HAL_UNLOCKED;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_TIM_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">    <span class="comment">/* Reset interrupt callbacks to legacy weak callbacks */</span></span><br><span class="line">    TIM_ResetCallback(htim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Base_MspInitCallback == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      htim-&gt;Base_MspInitCallback = HAL_TIM_Base_MspInit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Init the low level hardware : GPIO, CLOCK, NVIC */</span></span><br><span class="line">    htim-&gt;Base_MspInitCallback(htim);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Init the low level hardware : GPIO, CLOCK, NVIC */</span></span><br><span class="line">    HAL_TIM_Base_MspInit(htim);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_HAL_TIM_REGISTER_CALLBACKS */</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the TIM state */</span></span><br><span class="line">  htim-&gt;State = HAL_TIM_STATE_BUSY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Time Base configuration */</span></span><br><span class="line">  TIM_Base_SetConfig(htim-&gt;Instance, &amp;htim-&gt;Init);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the DMA burst operation state */</span></span><br><span class="line">  htim-&gt;DMABurstState = HAL_DMA_BURST_STATE_READY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the TIM channels state */</span></span><br><span class="line">  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);</span><br><span class="line">  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the TIM state*/</span></span><br><span class="line">  htim-&gt;State = HAL_TIM_STATE_READY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       定时器底层驱动，开启时钟，设置中断优先级</span></span><br><span class="line"><span class="comment">                此函数会被HAL_TIM_Base_Init()函数调用</span></span><br><span class="line"><span class="comment"> * @param       htim:定时器句柄</span></span><br><span class="line"><span class="comment"> * @retval      无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_Base_MspInit</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Instance == BTIM_TIMX_INT)</span><br><span class="line">    &#123;</span><br><span class="line">        BTIM_TIMX_INT_CLK_ENABLE();                     <span class="comment">/* 使能TIM时钟 */</span></span><br><span class="line">        HAL_NVIC_SetPriority(BTIM_TIMX_INT_IRQn, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">/* 抢占1，子优先级3，组2 */</span></span><br><span class="line">        HAL_NVIC_EnableIRQ(BTIM_TIMX_INT_IRQn);         <span class="comment">/* 开启ITM3中断 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>一般套路</strong>都是：</p><ol><li>先确定好涉及的外设（NVIC，TIM6）</li><li>打开所需外设的时钟（TIM6）</li><li>设置相应的外设<ol><li>NVIC（中断优先级，开中断）</li><li>TIM6（分频，重装载值，更新中断使能）</li></ol></li></ol><p>中断向量表里面，中断处理函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DCD     TIM6_IRQHandler            ; TIM6</span><br></pre></td></tr></table></figure><p>虽然btim.h里面定义的, NVIC打开的中断号是TIM6_DAC_IRQn, 虽然带DAC字样，但是就是指的tim6的中断</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BTIM_TIMX_INT                       TIM6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTIM_TIMX_INT_IRQn                  TIM6_DAC_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTIM_TIMX_INT_IRQHandler            TIM6_DAC_IRQHandler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32xe.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM6_DAC_IRQn           TIM6_IRQn</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIM6_DAC_IRQHandler           TIM6_IRQHandler</span></span><br><span class="line"></span><br><span class="line">  TIM6_IRQn                   = <span class="number">54</span>,     <span class="comment">/*!&lt; TIM6 global Interrupt                                */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以，当产生更新事件后，实际调用的中断处理函数是：<code>TIM6_IRQHandler</code></p><p>可以看到，在bsp的定时器驱动程序中，将这个中断处理函数，重实现为HAL的公共处理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BTIM_TIMX_INT_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_IRQHandler(&amp;g_timx_handle); <span class="comment">/* 定时器中断公共处理函数 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断发生中断的原因-&gt; 更新事件，HAL里面，清除一些标志位。然后调用中断回调函数<code>HAL_TIM_PeriodElapsedCallback</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 对这个发生中断的定时器，进行分析，是不是通用定时器发生的输入捕获？输出比较？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* TIM Update event */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)</span><br><span class="line">    &#123;</span><br><span class="line">      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (USE_HAL_TIM_REGISTER_CALLBACKS == 1)</span></span><br><span class="line">      htim-&gt;PeriodElapsedCallback(htim);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      HAL_TIM_PeriodElapsedCallback(htim);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USE_HAL_TIM_REGISTER_CALLBACKS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个回调函数，是个弱定义，我们就在自己的bsp驱动程序中实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (htim-&gt;Instance == BTIM_TIMX_INT)</span><br><span class="line">    &#123;</span><br><span class="line">        LED1_TOGGLE(); <span class="comment">/* LED1反转 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通用定时器（2-5）"><a href="#通用定时器（2-5）" class="headerlink" title="通用定时器（2-5）"></a>通用定时器（2-5）</h2><p>和基本定时器区别：多了输入捕获，PWM输出，输出比较，单脉冲模式</p><p>下面是组成部分</p><h3 id="1-时钟源选择"><a href="#1-时钟源选择" class="headerlink" title="1. 时钟源选择"></a>1. 时钟源选择</h3><ol><li><p>内部时钟(CK_INT)</p></li><li><p>外部时钟模式 1：外部输入引脚(TIx)，x&#x3D;1，2（即只能来自于通道 1 或者通道 2）</p><pre><code> 外部时钟源信号→IO→TIMx_CH1（或者 TIMx_CH2）</code></pre></li><li><p>外部时钟模式 2：外部触发输入(ETR)</p></li><li><p>内部触发输入(ITRx)：使用一个定时器作为另一定时器的预分频器</p></li></ol><h3 id="2-控制器-1"><a href="#2-控制器-1" class="headerlink" title="2. 控制器"></a>2. 控制器</h3><h3 id="3-时基单元-1"><a href="#3-时基单元-1" class="headerlink" title="3. 时基单元"></a>3. 时基单元</h3><h3 id="4-输入捕获"><a href="#4-输入捕获" class="headerlink" title="4. 输入捕获"></a>4. 输入捕获</h3><h3 id="5-输入捕获和输出比较公用部分"><a href="#5-输入捕获和输出比较公用部分" class="headerlink" title="5. 输入捕获和输出比较公用部分"></a>5. 输入捕获和输出比较公用部分</h3><h3 id="6-输出比较"><a href="#6-输出比较" class="headerlink" title="6. 输出比较"></a>6. 输出比较</h3><h3 id="定时器中断实验"><a href="#定时器中断实验" class="headerlink" title="定时器中断实验"></a>定时器中断实验</h3><ol><li>TIMx_CR1   （时基单元）<ol><li>APRE（选择是否自动重载缓冲）</li><li>CMS 和 DIR (选择计数模式)</li><li>CEN 使能计数器</li></ol></li><li>TIMx_SMCR（从模式控制）  （时钟源选择）<ol><li>SMS （配置输入时钟来源）</li></ol></li><li>TIMx_DIER （DMA&#x2F;中断使能寄存器）  （配置溢出更新中断使能）<ol><li>UIE</li></ol></li><li>TIMx_SR  （状态寄存器） （显示中断标志位，通知产生了中断，需要手动清除）<ol><li>UIF</li></ol></li><li>TIMx_CNT  （计数寄存器）</li><li>TIMx_PSC  （预分频）</li><li>TIMx_ARR  （自动重载）</li></ol><p>通用定时器（TIM2-TIM5 等）虽然支持 4 种时钟源（内部时钟、外部 TIx、外部 ETR、内部触发 ITRx），但复位后默认选择的是 “内部时钟（CK_INT）”，这是由硬件寄存器的复位值决定的</p><p>可以尝试自己直接实现中断处理，最后清除中断flag即可</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">liangji_TIM3_IRQHandler</span>(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//HAL_TIM_IRQHandler(&amp;init_TIM3);</span></span><br><span class="line"><span class="built_in">if</span>(__HAL_TIM_GET_FLAG(&amp;init_TIM3, TIM_FLAG_UPDATE))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">LED1_TOGGLE</span>();</span><br><span class="line"><span class="built_in">__HAL_TIM_CLEAR_FLAG</span>(&amp;init_TIM3, TIM_FLAG_UPDATE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时器输出PWM波实验"><a href="#定时器输出PWM波实验" class="headerlink" title="定时器输出PWM波实验"></a>定时器输出PWM波实验</h3><p>实现原理<br><img src="/../images/8.2.png" alt="alt text"></p><p>使用寄存器，除了上面的中断用到的基本定时器相关寄存器之外<br>还有</p><ol><li>TIMx_CCMR1&#x2F;2 （捕获 &#x2F;比较模式寄 存器）</li><li>TIMx_CCER   （捕获&#x2F;比较使能寄存器）</li><li>TIMx_CCR1~4   （捕获&#x2F;比较寄存器）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TIM_HandleTypeDef init_TIM3;</span><br><span class="line">TIM_OC_InitTypeDef init_TIM3_OC;</span><br><span class="line">GPIO_InitTypeDef init_gpio7;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">liangji_init_TIM3_PWM</span><span class="params">(<span class="type">uint32_t</span> psc, <span class="type">uint32_t</span> period)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//enable clk</span></span><br><span class="line">__HAL_RCC_TIM3_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line"><span class="comment">//enable NVIC</span></span><br><span class="line"><span class="built_in">HAL_NVIC_SetPriority</span>(TIM3_IRQn,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">HAL_NVIC_EnableIRQ</span>(TIM3_IRQn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//io mux, PA7-&gt;TIM3_CH2, REMAP</span></span><br><span class="line">__HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">init_gpio<span class="number">7.</span>Pin = GPIO_PIN_5;</span><br><span class="line">init_gpio<span class="number">7.</span>Mode = GPIO_MODE_AF_PP;</span><br><span class="line">init_gpio<span class="number">7.</span>Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">init_gpio<span class="number">7.</span>Pull = GPIO_PULLUP;</span><br><span class="line"><span class="built_in">HAL_GPIO_Init</span>(GPIOB, &amp;init_gpio7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GTIM_TIMX_PWM_CHY_GPIO_REMAP();</span></span><br><span class="line">__HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line">__HAL_AFIO_REMAP_TIM3_PARTIAL();</span><br><span class="line"><span class="comment">//AFIO_BASE</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CLK src sel, default choose ck_int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//config TIM BASE</span></span><br><span class="line">init_TIM<span class="number">3.</span>Instance = TIM3;</span><br><span class="line">init_TIM<span class="number">3.</span>Init.Prescaler=psc;</span><br><span class="line">init_TIM<span class="number">3.</span>Init.CounterMode=TIM_COUNTERMODE_UP;</span><br><span class="line">init_TIM<span class="number">3.</span>Init.Period=period;</span><br><span class="line">init_TIM<span class="number">3.</span>Init.AutoReloadPreload=TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line"><span class="comment">//init_TIM3.Channel = HAL_TIM_ACTIVE_CHANNEL_2;</span></span><br><span class="line"><span class="built_in">HAL_TIM_PWM_Init</span>(&amp;init_TIM3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//config TIM compare and output</span></span><br><span class="line">init_TIM3_OC.OCMode=TIM_OCMODE_PWM1;</span><br><span class="line">init_TIM3_OC.Pulse=period/<span class="number">2</span>;</span><br><span class="line">init_TIM3_OC.OCPolarity=TIM_OCPOLARITY_LOW;</span><br><span class="line"><span class="built_in">HAL_TIM_PWM_ConfigChannel</span>(&amp;init_TIM3, &amp;init_TIM3_OC, TIM_CHANNEL_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM3 IT</span></span><br><span class="line"><span class="comment">//HAL_TIM_Base_Start_IT(&amp;init_TIM3);</span></span><br><span class="line"><span class="built_in">HAL_TIM_PWM_Start</span>(&amp;init_TIM3, TIM_CHANNEL_2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">liangji_pwm_led</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> dir = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> ledrpwmval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dir)</span><br><span class="line">ledrpwmval++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ledrpwmval--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch</span></span><br><span class="line"><span class="keyword">if</span> (ledrpwmval &gt; <span class="number">300</span>)</span><br><span class="line">dir = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (ledrpwmval == <span class="number">0</span>)</span><br><span class="line">dir = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;init_TIM3, TIM_CHANNEL_2, ledrpwmval);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：关于引脚复用，和引脚重映射，最终你用到那个IO，你就配置那个IO就行了，重映射的原来的那个IO不需要配置了。</p><p>TIM3方面</p><p><img src="/../images/8.3.png" alt="alt text"><br><img src="/../images/8.4.png" alt="alt text"><br><img src="/../images/8.5.png" alt="alt text"><br>主要配置：<br>时基<br>时钟源（无需配置，默认就行）<br>比较主电路<br>输出部分</p><h3 id="输入捕获实验"><a href="#输入捕获实验" class="headerlink" title="输入捕获实验"></a>输入捕获实验</h3><p><img src="/../images/8.6.png" alt="alt text"><br><img src="/../images/8.7.png" alt="alt text"></p><p>要做的事情</p><ol><li>给TIM时钟</li><li>配置时钟源</li><li>配置输入IO</li><li>配置时基</li><li>配置输入通道</li><li>配置捕获主电路</li><li>配置捕获中断</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//TIM COMMON - Capture Project</span></span><br><span class="line"><span class="comment">//PA0 -&gt; TIM5_CH1</span></span><br><span class="line">TIM_HandleTypeDef init_TIM5;</span><br><span class="line">GPIO_InitTypeDef init_gpio_capture;</span><br><span class="line">TIM_IC_InitTypeDef init_IC;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> liangji_TIM5_IRQHandler TIM5_IRQHandler</span></span><br><span class="line"><span class="type">uint8_t</span> g_timxchy_cap_sta = <span class="number">0</span>; <span class="comment">//this count N</span></span><br><span class="line"><span class="type">uint16_t</span> g_timxchy_cap_val = <span class="number">0</span>; <span class="comment">//count Once cnt &lt; arr</span></span><br><span class="line"><span class="type">uint16_t</span> count_up = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">liangji_init_TIM5_CAPTURE</span><span class="params">(<span class="type">uint32_t</span> psc, <span class="type">uint32_t</span> period)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//NVIC</span></span><br><span class="line"><span class="built_in">HAL_NVIC_SetPriority</span>(TIM5_IRQn,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">HAL_NVIC_EnableIRQ</span>(TIM5_IRQn);</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO</span></span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">init_gpio_capture.Pin = GPIO_PIN_0;</span><br><span class="line">init_gpio_capture.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">init_gpio_capture.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">init_gpio_capture.Pull = GPIO_PULLUP;</span><br><span class="line"><span class="built_in">HAL_GPIO_Init</span>(GPIOA, &amp;init_gpio_capture);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//enable TIM5 CLK</span></span><br><span class="line">__HAL_RCC_TIM5_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM5 CLK SOURCE SEL</span></span><br><span class="line"><span class="comment">//stay Default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM5 TIM BASE</span></span><br><span class="line">init_TIM<span class="number">5.</span>Instance = TIM5;</span><br><span class="line">init_TIM<span class="number">5.</span>Init.Prescaler=psc;</span><br><span class="line">init_TIM<span class="number">5.</span>Init.CounterMode=TIM_COUNTERMODE_UP;</span><br><span class="line">init_TIM<span class="number">5.</span>Init.Period=period;</span><br><span class="line">init_TIM<span class="number">5.</span>Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;</span><br><span class="line">init_TIM<span class="number">5.</span>Init.AutoReloadPreload=TIM_AUTORELOAD_PRELOAD_DISABLE;</span><br><span class="line">init_TIM<span class="number">5.</span>Channel = HAL_TIM_ACTIVE_CHANNEL_1;</span><br><span class="line"><span class="built_in">HAL_TIM_IC_Init</span>(&amp;init_TIM5);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM5 Capture</span></span><br><span class="line">init_IC.ICFilter = <span class="number">0</span>;<span class="comment">//dont use filter</span></span><br><span class="line">init_IC.ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">init_IC.ICSelection = TIM_ICSELECTION_DIRECTTI;</span><br><span class="line">init_IC.ICPolarity = TIM_ICPOLARITY_RISING;</span><br><span class="line"><span class="built_in">HAL_TIM_IC_ConfigChannel</span>(&amp;init_TIM5, &amp;init_IC, TIM_CHANNEL_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIM5 Capture IT and IT</span></span><br><span class="line"><span class="built_in">HAL_TIM_IC_Start_IT</span>(&amp;init_TIM5, TIM_CHANNEL_1);</span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;init_TIM5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">liangji_TIM5_Capture</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((g_timxchy_cap_sta &amp; <span class="number">0x80</span>)!= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//we get a pulse</span></span><br><span class="line"><span class="type">uint16_t</span> N = g_timxchy_cap_sta &amp; <span class="number">0x3F</span>;</span><br><span class="line">N*= <span class="number">65536</span>;</span><br><span class="line">N+=g_timxchy_cap_val;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HIGH PULSE : %d us \r\n&quot;</span>, N);</span><br><span class="line">g_timxchy_cap_sta = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//just LED0 TOGGLE</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> t = <span class="number">0</span>;</span><br><span class="line">t++;</span><br><span class="line"><span class="keyword">if</span>(t&gt;<span class="number">20</span>)&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">LED0_TOGGLE</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">liangji_TIM5_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HAL_TIM_IRQHandler</span>(&amp;init_TIM5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Update IT callback</span></span><br><span class="line"><span class="comment">impel in main, toggle led1, and count up ++</span></span><br><span class="line"><span class="comment">      HAL_TIM_PeriodElapsedCallback(htim);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (htim-&gt;Instance == TIM6)&#123;</span><br><span class="line"><span class="comment">//LED1_TOGGLE();</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (htim-&gt;Instance == TIM3)&#123;</span><br><span class="line"><span class="comment">//LED1_TOGGLE();</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (htim-&gt;Instance == TIM5) &#123;</span><br><span class="line"><span class="keyword">if</span>((g_timxchy_cap_sta &amp; <span class="number">0X80</span>) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(g_timxchy_cap_sta &amp; <span class="number">0X40</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> ((g_timxchy_cap_sta &amp; <span class="number">0X3F</span>) == <span class="number">0X3F</span>)&#123;</span><br><span class="line"><span class="comment">//  wait for falling, over the N max, is too long,think it is success, so re-wait for up, give up wait falling</span></span><br><span class="line"><span class="built_in">TIM_RESET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1);</span><br><span class="line"><span class="built_in">TIM_SET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);</span><br><span class="line">g_timxchy_cap_sta |= <span class="number">0x80</span>;     </span><br><span class="line">g_timxchy_cap_val = <span class="number">0xffff</span>; <span class="comment">//mean: N(max)*arr + N(max)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">g_timxchy_cap_sta++;  <span class="comment">//N +1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      HAL_TIM_IC_CaptureCallback(htim);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//get up cnt</span></span><br><span class="line"><span class="comment">//set fall detect</span></span><br><span class="line"><span class="keyword">if</span>((g_timxchy_cap_sta &amp; <span class="number">0X80</span>) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(g_timxchy_cap_sta &amp; <span class="number">0X40</span>)&#123; <span class="comment">//now 0 1, but now capture falling because when capture up, we detect falling</span></span><br><span class="line">g_timxchy_cap_sta |= <span class="number">0x80</span>;</span><br><span class="line">g_timxchy_cap_val = <span class="built_in">HAL_TIM_ReadCapturedValue</span>(&amp;init_TIM5, TIM_CHANNEL_1);<span class="comment">//get falling cnt t2 (t2&lt;arr)</span></span><br><span class="line"><span class="comment">//reset detect up</span></span><br><span class="line"><span class="built_in">TIM_RESET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1);</span><br><span class="line"><span class="built_in">TIM_SET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//now 0 0, wait for up edge, but now capture interupt, so start a new detect</span></span><br><span class="line">g_timxchy_cap_sta = <span class="number">0</span>;</span><br><span class="line">g_timxchy_cap_val = <span class="number">0</span>;</span><br><span class="line">g_timxchy_cap_sta |= <span class="number">0x40</span>;   <span class="comment">// set 0 1, we have get up edge</span></span><br><span class="line"><span class="comment">//set polo falling detect, no need to record now cnt t1, because t1 + N*arr + t2 = now</span></span><br><span class="line">__HAL_TIM_DISABLE(&amp;init_TIM5);</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;init_TIM5, <span class="number">0</span>); </span><br><span class="line"><span class="built_in">TIM_RESET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1);</span><br><span class="line"><span class="built_in">TIM_SET_CAPTUREPOLARITY</span>(&amp;init_TIM5, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING);</span><br><span class="line">__HAL_TIM_ENABLE(&amp;init_TIM5);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/8.8.png" alt="alt text"><br>重点在于在捕获中断和更新事件中断中，统计溢出次数N和上升下降沿。</p><h3 id="脉冲计数实验"><a href="#脉冲计数实验" class="headerlink" title="脉冲计数实验"></a>脉冲计数实验</h3><p>这次我们使用外部时钟模式1, 多一个配置控制器。</p><p><img src="/../images/8.9.png" alt="alt text"></p><p>注意所有功能的使能， 中断的使能</p><ol><li>时钟的使能</li><li>输入通道的使能（如果有）</li><li>更新事件中断使能</li></ol><h2 id="高级定时器（1-8）"><a href="#高级定时器（1-8）" class="headerlink" title="高级定时器（1,8）"></a>高级定时器（1,8）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32-定时器&quot;&gt;&lt;a href=&quot;#STM32-定时器&quot; class=&quot;headerlink&quot; title=&quot;STM32 定时器&quot;&gt;&lt;/a&gt;STM32 定时器&lt;/h1&gt;&lt;h2 id=&quot;定时器硬件总线挂载情况&quot;&gt;&lt;a href=&quot;#定时器硬件总线挂载情况&quot; c</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="嵌入式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="MCU" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/MCU/"/>
    
    
    <category term="嵌入式" scheme="http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="mcu" scheme="http://example.com/tags/mcu/"/>
    
    <category term="stm32" scheme="http://example.com/tags/stm32/"/>
    
  </entry>
  
</feed>
